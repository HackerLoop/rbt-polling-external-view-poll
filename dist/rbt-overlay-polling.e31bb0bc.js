// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"../../.nvm/versions/node/v11.10.1/lib/node_modules/parcel-bundler/src/builtins/bundle-url.js":[function(require,module,exports) {
var bundleURL = null;

function getBundleURLCached() {
  if (!bundleURL) {
    bundleURL = getBundleURL();
  }

  return bundleURL;
}

function getBundleURL() {
  // Attempt to find the URL of the current script and use that as the base URL
  try {
    throw new Error();
  } catch (err) {
    var matches = ('' + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\/\/[^)\n]+/g);

    if (matches) {
      return getBaseURL(matches[0]);
    }
  }

  return '/';
}

function getBaseURL(url) {
  return ('' + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\/\/.+)\/[^/]+$/, '$1') + '/';
}

exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
},{}],"../../.nvm/versions/node/v11.10.1/lib/node_modules/parcel-bundler/src/builtins/css-loader.js":[function(require,module,exports) {
var bundle = require('./bundle-url');

function updateLink(link) {
  var newLink = link.cloneNode();

  newLink.onload = function () {
    link.remove();
  };

  newLink.href = link.href.split('?')[0] + '?' + Date.now();
  link.parentNode.insertBefore(newLink, link.nextSibling);
}

var cssTimeout = null;

function reloadCSS() {
  if (cssTimeout) {
    return;
  }

  cssTimeout = setTimeout(function () {
    var links = document.querySelectorAll('link[rel="stylesheet"]');

    for (var i = 0; i < links.length; i++) {
      if (bundle.getBaseURL(links[i].href) === bundle.getBundleURL()) {
        updateLink(links[i]);
      }
    }

    cssTimeout = null;
  }, 50);
}

module.exports = reloadCSS;
},{"./bundle-url":"../../.nvm/versions/node/v11.10.1/lib/node_modules/parcel-bundler/src/builtins/bundle-url.js"}],"scss/main.scss":[function(require,module,exports) {
var reloadCSS = require('_css_loader');

module.hot.dispose(reloadCSS);
module.hot.accept(reloadCSS);
},{"_css_loader":"../../.nvm/versions/node/v11.10.1/lib/node_modules/parcel-bundler/src/builtins/css-loader.js"}],"../../.nvm/versions/node/v11.10.1/lib/node_modules/parcel-bundler/node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"../../.nvm/versions/node/v11.10.1/lib/node_modules/parcel-bundler/node_modules/ieee754/index.js":[function(require,module,exports) {
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"../../.nvm/versions/node/v11.10.1/lib/node_modules/parcel-bundler/node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"../../.nvm/versions/node/v11.10.1/lib/node_modules/parcel-bundler/node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"../../.nvm/versions/node/v11.10.1/lib/node_modules/parcel-bundler/node_modules/base64-js/index.js","ieee754":"../../.nvm/versions/node/v11.10.1/lib/node_modules/parcel-bundler/node_modules/ieee754/index.js","isarray":"../../.nvm/versions/node/v11.10.1/lib/node_modules/parcel-bundler/node_modules/isarray/index.js","buffer":"../../.nvm/versions/node/v11.10.1/lib/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"_medkit-prod.umd.js":[function(require,module,exports) {
var define;
var global = arguments[3];
var Buffer = require("buffer").Buffer;
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.Muxy = factory();
})(this, function () {
  'use strict';
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  	See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  /* global Reflect, Promise */

  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  function __extends(d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var _assign = function __assign() {
    _assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return _assign.apply(this, arguments);
  };

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
  }

  function createCommonjsModule(fn, module) {
    return module = {
      exports: {}
    }, fn(module, module.exports), module.exports;
  }

  var gumshoe = createCommonjsModule(function (module) {
    /* eslint-disable */
    // polyfill for String.prototype.trim for IE8
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim
    if (!String.prototype.trim) {
      (function () {
        // Make sure we trim BOM and NBSP
        var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

        String.prototype.trim = function () {
          return this.replace(rtrim, '');
        };
      })();
    } // Production steps of ECMA-262, Edition 5, 15.4.4.21
    // Reference: http://es5.github.io/#x15.4.4.21


    if (!Array.prototype.reduce) {
      Array.prototype.reduce = function (callback
      /*, initialValue*/
      ) {
        if (this == null) {
          throw new TypeError('Array.prototype.reduce called on null or undefined');
        }

        if (typeof callback !== 'function') {
          throw new TypeError(callback + ' is not a function');
        }

        var t = Object(this),
            len = t.length >>> 0,
            k = 0,
            value;

        if (arguments.length == 2) {
          value = arguments[1];
        } else {
          while (k < len && !k in t) {
            k++;
          }

          if (k >= len) {
            throw new TypeError('Reduce of empty array with no initial value');
          }

          value = t[k++];
        }

        for (; k < len; k++) {
          if (k in t) {
            value = callback(value, t[k], k, t);
          }
        }

        return value;
      };
    }
    /**
     * @file perfnow is a 0.14 kb window.performance.now high resolution timer polyfill with Date fallback
     * @author Daniel Lamb <dlamb.open.source@gmail.com>
     */


    function perfnow() {
      var perf = window.performance || {};

      perf.now = perf.now || perf.mozNow || perf.msNow || perf.oNow || perf.webkitNow || // fallback to Date
      Date.now || function () {
        return new Date().getTime();
      };

      return perf;
    }

    function gumshoeFactory() {
      // we need reqwest and store2 (and any other future deps)
      // to be solely within our context, so as they don't leak and conflict
      // with other versions of the same libs sites may be loading.
      // so we'll provide our own context.
      // root._gumshoe is only available in specs
      var context = {},
          queryString,
          store,

      /*jshint -W024 */
      undefined; // call contextSetup with 'context' as 'this' so all libs attach
      // to our context variable.

      (function contextSetup() {
        /*!
        	query-string
        	Parse and stringify URL query strings
        	https://github.com/sindresorhus/query-string
        	by Sindre Sorhus
        	MIT License
        */
        (function (c) {
          var queryString = {};

          queryString.parse = function (str) {
            if (typeof str !== 'string') {
              return {};
            }

            str = str.trim().replace(/^(\?|#)/, '');

            if (!str) {
              return {};
            }

            return str.trim().split('&').reduce(function (ret, param) {
              var parts = param.replace(/\+/g, ' ').split('=');
              var key = parts[0];
              var val = parts[1];
              key = decodeURIComponent(key); // missing `=` should be `null`:
              // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters

              val = val === undefined ? null : decodeURIComponent(val);

              if (!ret.hasOwnProperty(key)) {
                ret[key] = val;
              } else if (Array.isArray(ret[key])) {
                ret[key].push(val);
              } else {
                ret[key] = [ret[key], val];
              }

              return ret;
            }, {});
          };

          queryString.stringify = function (obj) {
            return obj ? Object.keys(obj).map(function (key) {
              var val = obj[key];

              if (Array.isArray(val)) {
                return val.map(function (val2) {
                  return encodeURIComponent(key) + '=' + encodeURIComponent(val2);
                }).join('&');
              }

              return encodeURIComponent(key) + '=' + encodeURIComponent(val);
            }).join('&') : '';
          };

          c.queryString = queryString;
        })(this);
        /*!
         * Reqwest! A general purpose XHR connection manager
         * license MIT (c) Dustin Diaz 2014
         * https://github.com/ded/reqwest
         */


        !function (name, context, definition) {
          context[name] = definition();
        }('reqwest', this, function () {
          var win = window,
              doc = document,
              httpsRe = /^http/,
              protocolRe = /(^\w+):\/\//,
              twoHundo = /^(20\d|1223)$/ //http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
          ,
              byTag = 'getElementsByTagName',
              readyState = 'readyState',
              contentType = 'Content-Type',
              requestedWith = 'X-Requested-With',
              head = doc[byTag]('head')[0],
              uniqid = 0,
              callbackPrefix = 'reqwest_' + +new Date(),
              lastValue // data stored by the most recent JSONP callback
          ,
              xmlHttpRequest = 'XMLHttpRequest',
              xDomainRequest = 'XDomainRequest',
              noop = function noop() {},
              isArray = typeof Array.isArray == 'function' ? Array.isArray : function (a) {
            return a instanceof Array;
          },
              defaultHeaders = {
            'contentType': 'application/x-www-form-urlencoded',
            'requestedWith': xmlHttpRequest,
            'accept': {
              '*': 'text/javascript, text/html, application/xml, text/xml, */*',
              'xml': 'application/xml, text/xml',
              'html': 'text/html',
              'text': 'text/plain',
              'json': 'application/json, text/javascript',
              'js': 'application/javascript, text/javascript'
            }
          },
              xhr = function xhr(o) {
            // is it x-domain
            if (o['crossOrigin'] === true) {
              var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null;

              if (xhr && 'withCredentials' in xhr) {
                return xhr;
              } else if (win[xDomainRequest]) {
                return new XDomainRequest();
              } else {
                throw new Error('Browser does not support cross-origin requests');
              }
            } else if (win[xmlHttpRequest]) {
              return new XMLHttpRequest();
            } else {
              return new ActiveXObject('Microsoft.XMLHTTP');
            }
          },
              globalSetupOptions = {
            dataFilter: function dataFilter(data) {
              return data;
            }
          };

          function succeed(r) {
            var protocol = protocolRe.exec(r.url);
            protocol = protocol && protocol[1] || window.location.protocol;
            return httpsRe.test(protocol) ? twoHundo.test(r.request.status) : !!r.request.responseText;
          }

          function handleReadyState(r, success, error) {
            return function () {
              // use _aborted to mitigate against IE err c00c023f
              // (can't read props on aborted request objects)
              if (r._aborted) return error(r.request);
              if (r._timedOut) return error(r.request, 'Request is aborted: timeout');

              if (r.request && r.request[readyState] == 4) {
                r.request.onreadystatechange = noop;
                if (succeed(r)) success(r.request);else error(r.request);
              }
            };
          }

          function setHeaders(http, o) {
            var headers = o['headers'] || {},
                h;
            headers['Accept'] = headers['Accept'] || defaultHeaders['accept'][o['type']] || defaultHeaders['accept']['*'];
            var isAFormData = typeof FormData === 'function' && o['data'] instanceof FormData; // breaks cross-origin requests with legacy browsers

            if (!o['crossOrigin'] && !headers[requestedWith]) headers[requestedWith] = defaultHeaders['requestedWith'];
            if (!headers[contentType] && !isAFormData) headers[contentType] = o['contentType'] || defaultHeaders['contentType'];

            for (h in headers) {
              headers.hasOwnProperty(h) && 'setRequestHeader' in http && http.setRequestHeader(h, headers[h]);
            }
          }

          function setCredentials(http, o) {
            if (typeof o['withCredentials'] !== 'undefined' && typeof http.withCredentials !== 'undefined') {
              http.withCredentials = !!o['withCredentials'];
            }
          }

          function generalCallback(data) {
            lastValue = data;
          }

          function urlappend(url, s) {
            return url + (/\?/.test(url) ? '&' : '?') + s;
          }

          function handleJsonp(o, fn, err, url) {
            var reqId = uniqid++,
                cbkey = o['jsonpCallback'] || 'callback' // the 'callback' key
            ,
                cbval = o['jsonpCallbackName'] || reqwest.getcallbackPrefix(reqId),
                cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)'),
                match = url.match(cbreg),
                script = doc.createElement('script'),
                loaded = 0,
                isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1;

            if (match) {
              if (match[3] === '?') {
                url = url.replace(cbreg, '$1=' + cbval); // wildcard callback func name
              } else {
                cbval = match[3]; // provided callback func name
              }
            } else {
              url = urlappend(url, cbkey + '=' + cbval); // no callback details, add 'em
            }

            win[cbval] = generalCallback;
            script.type = 'text/javascript';
            script.src = url;
            script.async = true;

            if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
              // need this for IE due to out-of-order onreadystatechange(), binding script
              // execution to an event listener gives us control over when the script
              // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
              script.htmlFor = script.id = '_reqwest_' + reqId;
            }

            script.onload = script.onreadystatechange = function () {
              if (script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded' || loaded) {
                return false;
              }

              script.onload = script.onreadystatechange = null;
              script.onclick && script.onclick(); // Call the user callback with the last value stored and clean up values and scripts.

              fn(lastValue);
              lastValue = undefined;
              head.removeChild(script);
              loaded = 1;
            }; // Add the script to the DOM head


            head.appendChild(script); // Enable JSONP timeout

            return {
              abort: function abort() {
                script.onload = script.onreadystatechange = null;
                err({}, 'Request is aborted: timeout', {});
                lastValue = undefined;
                head.removeChild(script);
                loaded = 1;
              }
            };
          }

          function getRequest(fn, err) {
            var o = this.o,
                method = (o['method'] || 'GET').toUpperCase(),
                url = typeof o === 'string' ? o : o['url'] // convert non-string objects to query-string form unless o['processData'] is false
            ,
                data = o['processData'] !== false && o['data'] && typeof o['data'] !== 'string' ? reqwest.toQueryString(o['data']) : o['data'] || null,
                http,
                sendWait = false; // if we're working on a GET request and we have data then we should append
            // query string to end of URL and not post data

            if ((o['type'] == 'jsonp' || method == 'GET') && data) {
              url = urlappend(url, data);
              data = null;
            }

            if (o['type'] == 'jsonp') return handleJsonp(o, fn, err, url); // get the xhr from the factory if passed
            // if the factory returns null, fall-back to ours

            http = o.xhr && o.xhr(o) || xhr(o);
            http.open(method, url, o['async'] === false ? false : true);
            setHeaders(http, o);
            setCredentials(http, o);

            if (win[xDomainRequest] && http instanceof win[xDomainRequest]) {
              http.onload = fn;
              http.onerror = err; // NOTE: see
              // http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/30ef3add-767c-4436-b8a9-f1ca19b4812e

              http.onprogress = function () {};

              sendWait = true;
            } else {
              http.onreadystatechange = handleReadyState(this, fn, err);
            }

            o['before'] && o['before'](http);

            if (sendWait) {
              setTimeout(function () {
                http.send(data);
              }, 200);
            } else {
              http.send(data);
            }

            return http;
          }

          function Reqwest(o, fn) {
            this.o = o;
            this.fn = fn;
            init.apply(this, arguments);
          }

          function setType(header) {
            // json, javascript, text/plain, text/html, xml
            if (header.match('json')) return 'json';
            if (header.match('javascript')) return 'js';
            if (header.match('text')) return 'html';
            if (header.match('xml')) return 'xml';
          }

          function init(o, fn) {
            this.url = typeof o == 'string' ? o : o['url'];
            this.timeout = null; // whether request has been fulfilled for purpose
            // of tracking the Promises

            this._fulfilled = false; // success handlers

            this._successHandler = function () {};

            this._fulfillmentHandlers = []; // error handlers

            this._errorHandlers = []; // complete (both success and fail) handlers

            this._completeHandlers = [];
            this._erred = false;
            this._responseArgs = {};
            var self = this;

            fn = fn || function () {};

            if (o['timeout']) {
              this.timeout = setTimeout(function () {
                timedOut();
              }, o['timeout']);
            }

            if (o['success']) {
              this._successHandler = function () {
                o['success'].apply(o, arguments);
              };
            }

            if (o['error']) {
              this._errorHandlers.push(function () {
                o['error'].apply(o, arguments);
              });
            }

            if (o['complete']) {
              this._completeHandlers.push(function () {
                o['complete'].apply(o, arguments);
              });
            }

            function complete(resp) {
              o['timeout'] && clearTimeout(self.timeout);
              self.timeout = null;

              while (self._completeHandlers.length > 0) {
                self._completeHandlers.shift()(resp);
              }
            }

            function success(resp) {
              var type = o['type'] || resp && setType(resp.getResponseHeader('Content-Type')); // resp can be undefined in IE

              resp = type !== 'jsonp' ? self.request : resp; // use global data filter on response text

              var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type),
                  r = filteredResponse;

              try {
                resp.responseText = r;
              } catch (e) {// can't assign this in IE<=8, just ignore
              }

              if (r) {
                switch (type) {
                  case 'json':
                    try {
                      resp = win.JSON.parse(r);
                    } catch (err) {
                      return error(resp, 'Could not parse JSON in response', err);
                    }

                    break;
                }
              }

              self._responseArgs.resp = resp;
              self._fulfilled = true;
              fn(resp);

              self._successHandler(resp);

              while (self._fulfillmentHandlers.length > 0) {
                resp = self._fulfillmentHandlers.shift()(resp);
              }

              complete(resp);
            }

            function timedOut() {
              self._timedOut = true;

              if (typeof self.request !== 'undefined' && typeof self.request.abort === 'function') {
                self.request.abort();
              }
            }

            function error(resp, msg, t) {
              resp = self.request;
              self._responseArgs.resp = resp;
              self._responseArgs.msg = msg;
              self._responseArgs.t = t;
              self._erred = true;

              while (self._errorHandlers.length > 0) {
                self._errorHandlers.shift()(resp, msg, t);
              }

              complete(resp);
            }

            this.request = getRequest.call(this, success, error);
          }

          Reqwest.prototype = {
            abort: function abort() {
              this._aborted = true;

              if (typeof this.request !== 'undefined' && typeof this.request.abort === 'function') {
                this.request.abort();
              }
            },
            retry: function retry() {
              this._aborted = false;
              this._timedOut = false;
              init.call(this, this.o, this.fn);
            }
            /**
             * Small deviation from the Promises A CommonJs specification
             * http://wiki.commonjs.org/wiki/Promises/A
             */

            /**
             * `then` will execute upon successful requests
             */
            ,
            then: function then(success, fail) {
              success = success || function () {};

              fail = fail || function () {};

              if (this._fulfilled) {
                this._responseArgs.resp = success(this._responseArgs.resp);
              } else if (this._erred) {
                fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t);
              } else {
                this._fulfillmentHandlers.push(success);

                this._errorHandlers.push(fail);
              }

              return this;
            }
            /**
             * `always` will execute whether the request succeeds or fails
             */
            ,
            always: function always(fn) {
              if (this._fulfilled || this._erred) {
                fn(this._responseArgs.resp);
              } else {
                this._completeHandlers.push(fn);
              }

              return this;
            }
            /**
             * `fail` will execute when the request fails
             */
            ,
            fail: function fail(fn) {
              if (this._erred) {
                fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t);
              } else {
                this._errorHandlers.push(fn);
              }

              return this;
            },
            'catch': function _catch(fn) {
              return this.fail(fn);
            }
          };

          function reqwest(o, fn) {
            return new Reqwest(o, fn);
          } // normalize newline variants according to spec -> CRLF


          function normalize(s) {
            return s ? s.replace(/\r?\n/g, '\r\n') : '';
          }

          function serial(el, cb) {
            var n = el.name,
                t = el.tagName.toLowerCase(),
                optCb = function optCb(o) {
              // IE gives value="" even where there is no value attribute
              // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273
              if (o && !o['disabled']) cb(n, normalize(o['attributes']['value'] && o['attributes']['value']['specified'] ? o['value'] : o['text']));
            },
                ch,
                ra,
                val,
                i; // don't serialize elements that are disabled or without a name


            if (el.disabled || !n) return;

            switch (t) {
              case 'input':
                if (!/reset|button|image|file/i.test(el.type)) {
                  ch = /checkbox/i.test(el.type);
                  ra = /radio/i.test(el.type);
                  val = el.value // WebKit gives us "" instead of "on" if a checkbox has no value, so correct it here
                  ;
                  (!(ch || ra) || el.checked) && cb(n, normalize(ch && val === '' ? 'on' : val));
                }

                break;

              case 'textarea':
                cb(n, normalize(el.value));
                break;

              case 'select':
                if (el.type.toLowerCase() === 'select-one') {
                  optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null);
                } else {
                  for (i = 0; el.length && i < el.length; i++) {
                    el.options[i].selected && optCb(el.options[i]);
                  }
                }

                break;
            }
          } // collect up all form elements found from the passed argument elements all
          // the way down to child elements; pass a '<form>' or form fields.
          // called with 'this'=callback to use for serial() on each element


          function eachFormElement() {
            var cb = this,
                e,
                i,
                serializeSubtags = function serializeSubtags(e, tags) {
              var i, j, fa;

              for (i = 0; i < tags.length; i++) {
                fa = e[byTag](tags[i]);

                for (j = 0; j < fa.length; j++) {
                  serial(fa[j], cb);
                }
              }
            };

            for (i = 0; i < arguments.length; i++) {
              e = arguments[i];
              if (/input|select|textarea/i.test(e.tagName)) serial(e, cb);
              serializeSubtags(e, ['input', 'select', 'textarea']);
            }
          } // standard query string style serialization


          function serializeQueryString() {
            return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments));
          } // { 'name': 'value', ... } style serialization


          function serializeHash() {
            var hash = {};
            eachFormElement.apply(function (name, value) {
              if (name in hash) {
                hash[name] && !isArray(hash[name]) && (hash[name] = [hash[name]]);
                hash[name].push(value);
              } else hash[name] = value;
            }, arguments);
            return hash;
          } // [ { name: 'name', value: 'value' }, ... ] style serialization


          reqwest.serializeArray = function () {
            var arr = [];
            eachFormElement.apply(function (name, value) {
              arr.push({
                name: name,
                value: value
              });
            }, arguments);
            return arr;
          };

          reqwest.serialize = function () {
            if (arguments.length === 0) return '';
            var opt,
                fn,
                args = Array.prototype.slice.call(arguments, 0);
            opt = args.pop();
            opt && opt.nodeType && args.push(opt) && (opt = null);
            opt && (opt = opt.type);
            if (opt == 'map') fn = serializeHash;else if (opt == 'array') fn = reqwest.serializeArray;else fn = serializeQueryString;
            return fn.apply(null, args);
          };

          reqwest.toQueryString = function (o, trad) {
            var prefix,
                i,
                traditional = trad || false,
                s = [],
                enc = encodeURIComponent,
                add = function add(key, value) {
              // If value is a function, invoke it and return its value
              value = 'function' === typeof value ? value() : value == null ? '' : value;
              s[s.length] = enc(key) + '=' + enc(value);
            }; // If an array was passed in, assume that it is an array of form elements.


            if (isArray(o)) {
              for (i = 0; o && i < o.length; i++) {
                add(o[i]['name'], o[i]['value']);
              }
            } else {
              // If traditional, encode the "old" way (the way 1.3.2 or older
              // did it), otherwise encode params recursively.
              for (prefix in o) {
                if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add);
              }
            } // spaces should be + according to spec


            return s.join('&').replace(/%20/g, '+');
          };

          function buildParams(prefix, obj, traditional, add) {
            var name,
                i,
                v,
                rbracket = /\[\]$/;

            if (isArray(obj)) {
              // Serialize array item.
              for (i = 0; obj && i < obj.length; i++) {
                v = obj[i];

                if (traditional || rbracket.test(prefix)) {
                  // Treat each array item as a scalar.
                  add(prefix, v);
                } else {
                  buildParams(prefix + '[' + (_typeof(v) === 'object' ? i : '') + ']', v, traditional, add);
                }
              }
            } else if (obj && obj.toString() === '[object Object]') {
              // Serialize object item.
              for (name in obj) {
                buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
              }
            } else {
              // Serialize scalar item.
              add(prefix, obj);
            }
          }

          reqwest.getcallbackPrefix = function () {
            return callbackPrefix;
          }; // jQuery and Zepto compatibility, differences can be remapped here so you can call
          // .ajax.compat(options, callback)


          reqwest.compat = function (o, fn) {
            if (o) {
              o['type'] && (o['method'] = o['type']) && delete o['type'];
              o['dataType'] && (o['type'] = o['dataType']);
              o['jsonpCallback'] && (o['jsonpCallbackName'] = o['jsonpCallback']) && delete o['jsonpCallback'];
              o['jsonp'] && (o['jsonpCallback'] = o['jsonp']);
            }

            return new Reqwest(o, fn);
          };

          reqwest.ajaxSetup = function (options) {
            options = options || {};

            for (var k in options) {
              globalSetupOptions[k] = options[k];
            }
          };

          return reqwest;
        });

        (function (window, define) {
          var _ = {
            version: "2.3.0",
            areas: {},
            apis: {},
            // utilities
            inherit: function inherit(api, o) {
              for (var p in api) {
                if (!o.hasOwnProperty(p)) {
                  o[p] = api[p];
                }
              }

              return o;
            },
            stringify: function stringify(d) {
              return d === undefined || typeof d === "function" ? d + '' : JSON.stringify(d);
            },
            parse: function parse(s) {
              // if it doesn't parse, return as is
              try {
                return JSON.parse(s);
              } catch (e) {
                return s;
              }
            },
            // extension hooks
            fn: function fn(name, _fn) {
              _.storeAPI[name] = _fn;

              for (var api in _.apis) {
                _.apis[api][name] = _fn;
              }
            },
            get: function get(area, key) {
              return area.getItem(key);
            },
            set: function set(area, key, string) {
              area.setItem(key, string);
            },
            remove: function remove(area, key) {
              area.removeItem(key);
            },
            key: function key(area, i) {
              return area.key(i);
            },
            length: function length(area) {
              return area.length;
            },
            clear: function clear(area) {
              area.clear();
            },
            // core functions
            Store: function Store(id, area, namespace) {
              var store = _.inherit(_.storeAPI, function (key, data, overwrite) {
                if (arguments.length === 0) {
                  return store.getAll();
                }

                if (data !== undefined) {
                  return store.set(key, data, overwrite);
                }

                if (typeof key === "string") {
                  return store.get(key);
                }

                if (!key) {
                  return store.clear();
                }

                return store.setAll(key, data); // overwrite=data, data=key
              });

              store._id = id;

              try {
                var testKey = '_safariPrivate_';
                area.setItem(testKey, 'sucks');
                store._area = area;
                area.removeItem(testKey);
              } catch (e) {}

              if (!store._area) {
                store._area = _.inherit(_.storageAPI, {
                  items: {},
                  name: 'fake'
                });
              }

              store._ns = namespace || '';

              if (!_.areas[id]) {
                _.areas[id] = store._area;
              }

              if (!_.apis[store._ns + store._id]) {
                _.apis[store._ns + store._id] = store;
              }

              return store;
            },
            storeAPI: {
              // admin functions
              area: function area(id, _area) {
                var store = this[id];

                if (!store || !store.area) {
                  store = _.Store(id, _area, this._ns); //new area-specific api in this namespace

                  if (!this[id]) {
                    this[id] = store;
                  }
                }

                return store;
              },
              namespace: function namespace(_namespace, noSession) {
                if (!_namespace) {
                  return this._ns ? this._ns.substring(0, this._ns.length - 1) : '';
                }

                var ns = _namespace,
                    store = this[ns];

                if (!store || !store.namespace) {
                  store = _.Store(this._id, this._area, this._ns + ns + '.'); //new namespaced api

                  if (!this[ns]) {
                    this[ns] = store;
                  }

                  if (!noSession) {
                    store.area('session', _.areas.session);
                  }
                }

                return store;
              },
              isFake: function isFake() {
                return this._area.name === 'fake';
              },
              toString: function toString() {
                return 'store' + (this._ns ? '.' + this.namespace() : '') + '[' + this._id + ']';
              },
              // storage functions
              has: function has(key) {
                if (this._area.has) {
                  return this._area.has(this._in(key)); //extension hook
                }

                return !!(this._in(key) in this._area);
              },
              size: function size() {
                return this.keys().length;
              },
              each: function each(fn, and) {
                for (var i = 0, m = _.length(this._area); i < m; i++) {
                  var key = this._out(_.key(this._area, i));

                  if (key !== undefined) {
                    if (fn.call(this, key, and || this.get(key)) === false) {
                      break;
                    }
                  }

                  if (m > _.length(this._area)) {
                    m--;
                    i--;
                  } // in case of removeItem

                }

                return and || this;
              },
              keys: function keys() {
                return this.each(function (k, list) {
                  list.push(k);
                }, []);
              },
              get: function get(key, alt) {
                var s = _.get(this._area, this._in(key));

                return s !== null ? _.parse(s) : alt || s; // support alt for easy default mgmt
              },
              getAll: function getAll() {
                return this.each(function (k, all) {
                  all[k] = this.get(k);
                }, {});
              },
              set: function set(key, data, overwrite) {
                var d = this.get(key);

                if (d != null && overwrite === false) {
                  return data;
                }

                return _.set(this._area, this._in(key), _.stringify(data), overwrite) || d;
              },
              setAll: function setAll(data, overwrite) {
                var changed, val;

                for (var key in data) {
                  val = data[key];

                  if (this.set(key, val, overwrite) !== val) {
                    changed = true;
                  }
                }

                return changed;
              },
              remove: function remove(key) {
                var d = this.get(key);

                _.remove(this._area, this._in(key));

                return d;
              },
              clear: function clear() {
                if (!this._ns) {
                  _.clear(this._area);
                } else {
                  this.each(function (k) {
                    _.remove(this._area, this._in(k));
                  }, 1);
                }

                return this;
              },
              clearAll: function clearAll() {
                var area = this._area;

                for (var id in _.areas) {
                  if (_.areas.hasOwnProperty(id)) {
                    this._area = _.areas[id];
                    this.clear();
                  }
                }

                this._area = area;
                return this;
              },
              // internal use functions
              _in: function _in(k) {
                if (typeof k !== "string") {
                  k = _.stringify(k);
                }

                return this._ns ? this._ns + k : k;
              },
              _out: function _out(k) {
                return this._ns ? k && k.indexOf(this._ns) === 0 ? k.substring(this._ns.length) : undefined : // so each() knows to skip it
                k;
              }
            },
            // end _.storeAPI
            storageAPI: {
              length: 0,
              has: function has(k) {
                return this.items.hasOwnProperty(k);
              },
              key: function key(i) {
                var c = 0;

                for (var k in this.items) {
                  if (this.has(k) && i === c++) {
                    return k;
                  }
                }
              },
              setItem: function setItem(k, v) {
                if (!this.has(k)) {
                  this.length++;
                }

                this.items[k] = v;
              },
              removeItem: function removeItem(k) {
                if (this.has(k)) {
                  delete this.items[k];
                  this.length--;
                }
              },
              getItem: function getItem(k) {
                return this.has(k) ? this.items[k] : null;
              },
              clear: function clear() {
                for (var k in this.list) {
                  this.removeItem(k);
                }
              },
              toString: function toString() {
                return this.length + ' items in ' + this.name + 'Storage';
              } // end _.storageAPI

            }
          }; // setup the primary store fn

          if (window.store) {
            _.conflict = window.store;
          }

          var store = // safely set this up (throws error in IE10/32bit mode for local files)
          _.Store("local");

          store.local = store; // for completeness

          store._ = _; // for extenders and debuggers...
          // safely setup store.session (throws exception in FF for file:/// urls)

          store.area("session"); //Expose store to the global object

          window.store = store;

          if (typeof define === 'function' && define.amd !== undefined) {
            define(function () {
              return store;
            });
          } else if (module.exports) {
            module.exports = store;
          }
        })(this, this.define);
      }).call(context);
      queryString = context.queryString;
      store = context.store;

      function extend(obj) {
        if (!isObject(obj)) {
          return obj;
        }

        var source, prop;

        for (var i = 1, length = arguments.length; i < length; i++) {
          source = arguments[i];

          for (prop in source) {
            obj[prop] = source[prop];
          }
        }

        return obj;
      }

      function isArray(obj) {
        return '[object Array]' === Object.prototype.toString.call(obj);
      }

      function isObject(obj) {
        var type = _typeof(obj);

        return type === 'function' || type === 'object' && !!obj;
      }

      function isString(value) {
        return typeof value == 'string' || value && _typeof(value) == 'object' && Object.prototype.toString.call(value) == '[object String]' || false;
      }

      function uuidv4() {
        var d = perfnow().now();
        var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
          var r = (d + Math.random() * 16) % 16 | 0;
          d = Math.floor(d / 16);
          return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);
        });
        return uuid;
      }

      var defaults = {
        transport: '',
        queueTimeout: 100
      },
          localStore = store.namespace('gumshoe'),
          storage = store.namespace('gumshoe').session,
          queue = storage('queue') || [],
          transports = {};

      if (!isArray(queue)) {
        queue = [];
      }

      function gumshoe(options) {
        var clientUuid = localStore('clientUuid');
        options = extend({}, defaults, options); // always ensure options.transport is an array.

        if (isString(options.transport)) {
          options.transport = [options.transport];
        } else if (!isArray(options.transport)) {
          throw 'Gumeshoe: Transport property must be a [String] or [Array].';
        } // store a client id to identify a client long-term. Google Analytics uses
        // the value, combined with other factors, to determine unique users. we
        // duplicate the same kind of value to assist GA.


        if (!clientUuid) {
          clientUuid = uuidv4();
          localStore({
            clientUuid: clientUuid
          });
        }

        options.clientUuid = clientUuid;
        session(options.sessionFn);
        gumshoe.options = options;
      }

      function each(obj, iterator, context) {
        if (obj === null) {
          return;
        }

        if (Array.prototype.forEach && obj.forEach === Array.prototype.forEach) {
          obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
          for (var i = 0, l = obj.length; i < l; i++) {
            if (iterator.call(context, obj[i], i, obj) === {}) {
              return;
            }
          }
        } else {
          for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
              if (iterator.call(context, obj[key], key, obj) === {}) {
                return;
              }
            }
          }
        }
      }

      function map(obj, iterator, context) {
        var results = [];

        if (!obj) {
          return results;
        }

        if (Array.prototype.map && obj.map === Array.prototype.map) {
          return obj.map(iterator, context);
        }

        each(obj, function (value, index, list) {
          results[results.length] = iterator.call(context, value, index, list);
        });
        return results;
      }

      function collectPlugins() {
        var result,
            plugins = navigator.plugins || [];
        result = map(plugins, function (plugin) {
          var mimeTypes = map(plugin, function (mimeType) {
            var type = mimeType.type;

            if (mimeType.suffixes) {
              type += '~' + mimeType.suffixes;
            }

            return type;
          });
          return {
            description: plugin.description,
            filename: plugin.filename,
            mimeTypes: mimeTypes,
            name: plugin.name
          };
        });
        return result;
      }

      function collect() {
        function getViewport() {
          var e = window,
              a = 'inner';

          if (!('innerWidth' in window)) {
            a = 'client';
            e = document.documentElement || document.body;
          }

          return {
            width: e[a + 'Width'],
            height: e[a + 'Height']
          };
        }

        var viewport = getViewport(),
            query = queryString.parse(location.search),
            result = {
          // utmcs Character set (e.g. ISO-8859-1)
          characterSet: document.characterSet || document.charset || document.inputEncoding || 'Unknown',
          // utmsc Screen colour depth (e.g. 24-bit)
          colorDepth: screen.colorDepth + '',
          // gclid Gclid is a globally unique tracking parameter (Google Click Identifier)
          googleClickId: query.gclid || '',
          hash: window.location.hash,
          host: window.location.host,
          // utmhn Hostname
          hostName: window.location.hostname,
          // utmip IP address
          ipAddress: '',
          // utmje Java enabled?
          javaEnabled: navigator.javaEnabled ? navigator.javaEnabled() : false,
          // utmul Language code (e.g. en-us)
          language: window.navigator.userLanguage || window.navigator.language || 'Unknown',
          // login key: ?lk=
          loginKey: query.lk || '',
          // IE9 doesn't support this
          origin: window.location.origin || '',
          // utmp  Page path
          path: window.location.pathname,
          platform: window.navigator.platform,
          plugins: collectPlugins(),
          port: window.location.port || 80,
          // promotional key: pkey
          promotionKey: query.pkey || '',
          protocol: window.location.protocol,
          queryString: window.location.search,
          // utmr  Full referral URL
          referer: document.referrer,
          screenAvailHeight: screen.availHeight,
          screenAvailWidth: screen.availWidth,
          screenHeight: screen.height,
          screenOrientationAngle: '',
          screenOrientationType: '',
          screenPixelDepth: screen.pixelDepth + '',
          // utmsr Screen resolution
          screenResolution: screen.width + 'x' + screen.height,
          screenWidth: screen.width,
          // utmdt Page title
          title: document.title,
          url: window.location.href,
          userAgent: window.navigator.userAgent,
          utmCampaign: query.utm_campaign || '',
          utmContent: query.utm_content || '',
          utmMedium: query.utm_medium || '',
          utmSource: query.utm_source || '',
          utmTerm: query.utm_term || '',
          // utmvp Viewport resolution
          viewportHeight: viewport.height,
          viewportResolution: viewport.width + 'x' + viewport.height,
          viewportWidth: viewport.width
        },
            intFields = ['port', 'screenAvailHeight', 'screenAvailWidth', 'screenHeight', 'screenOrientationAngle', 'screenWidth', 'viewportHeight', 'viewportWidth'],
            prop,
            value; // some browsers don't support navigator.javaEnabled(), it's always undefined.

        if (result.javaEnabled === undefined) {
          result.javaEnabled = false;
        } // IE 8, 9 don't support this. Yay.


        if (screen.orientation) {
          result.screenOrientationAngle = parseInt(screen.orientation.angle ? screen.orientation.angle : '0');
          result.screenOrientationType = screen.orientation.type ? screen.orientation.type : '';

          if (isNaN(result.screenOrientationAngle)) {
            result.screenOrientationAngle = 0;
          }
        } // assert that these values are ints


        for (var i = 0; i < intFields.length; i++) {
          prop = intFields[i];
          value = parseInt(result[prop]);

          if (isNaN(value)) {
            value = 0;
          }

          result[prop] = value;
        }

        return result;
      }
      /**
       * @private
       * @method session
       *
       * @note
       * Gumshoe Session Rules
       *
       *  Generate a new Session ID if any of the following criteria are met:
       *
       *  1. User opens new tab or window (browser default behavior)
       *  2. User has been inactive longer than 30 minutes
       *  3. User has visited withinin the same session, but a UTM
       *     query string parameter has changed.
       */


      function session(fn) {
        // returns a simple object containing utm parameters
        function getUtm() {
          return {
            campaign: query.utm_campaign || '',
            medium: query.utm_medium || '',
            source: query.utm_source || '',
            utmTerm: query.utm_term || ''
          };
        }

        var now = new Date().getTime(),
            query = queryString.parse(location.search),
            lastUtm = storage('utm') || getUtm(),
            utm = getUtm(),
            timestamp,
            difference; // save the current state of the utm parameters

        storage('utm', utm); // set a session based uuid

        if (!storage('uuid')) {
          storage('uuid', uuidv4());
          storage('timestamp', now);
        } else {
          timestamp = storage('timestamp');
          difference = now - timestamp;

          if (fn) {
            /* jshint validthis: true */
            if (fn.call(this, timestamp, difference, query)) {
              storage('uuid', uuidv4());
            }
          } else if (JSON.stringify(lastUtm) !== JSON.stringify(utm) || difference > 1000 * 60 * 30) {
            storage('uuid', uuidv4());
          }
        }
      }

      function send(eventName, eventData) {
        var pageData = collect(),
            baseData = {
          clientUuid: gumshoe.options.clientUuid,
          eventName: eventName,
          eventData: eventData || {},
          gumshoe: '0.8.1',
          pageData: pageData,
          sessionUuid: storage('uuid'),
          timestamp: new Date().getTime(),
          timezoneOffset: new Date().getTimezoneOffset(),
          uuid: uuidv4()
        }; // since we're dealing with timeouts now, we need to reassert the
        // session ID for each event sent.

        session(gumshoe.options.sessionFn);

        if (gumshoe.options.transport) {
          for (var i = 0; i < gumshoe.options.transport.length; i++) {
            var transportName = gumshoe.options.transport[i],
                transport,
                data;

            if (transportName && transports[transportName]) {
              transport = transports[transportName]; // allow each transport to extend the data with more information
              // or transform it how they'd like. transports cannot however,
              // modify eventData sent from the client.

              data = transport.map ? transport.map(baseData) : baseData; // extend our data with whatever came back from the transport

              data = extend(baseData, data); // TODO: remove this. gumshoe shouldn't care what format this is in

              if (!isString(data.eventData)) {
                data.eventData = JSON.stringify(data.eventData);
              } // TODO: remove this. gumshoe shouldn't care what format this is in


              if (!isString(data.pageData.plugins)) {
                data.pageData.plugins = JSON.stringify(data.pageData.plugins);
              } // TODO: remove this. temporary bugfix for apps


              if (!data.pageData.ipAddress) {
                data.pageData.ipAddress = '<unknown>';
              }

              pushEvent(eventName, transportName, data);
            } else {
              throw 'Gumshoe: The transport name: ' + transportName + ', doesn\'t map to a valid transport.';
            }
          }
        }
        /*if (!transportFound) {
        	throw 'Gumshoe: No valid transports were found.';
        }*/

      }

      function nextEvent() {
        if (!queue.length) {
          return;
        } // granb the next event from the queue and remove it.


        var nevent = queue.shift(),
            transport = transports[nevent.transportName];
        storage('queue', queue);
        transport.send(nevent.data, function (err, result) {
          // we care if an error was thrown, created, or captured
          // if there is an error, add the item back into the queue
          if (err) {
            console.warn('Gumshoe: Retrying. Error received from transport: ' + nevent.transportName + ', for event: ' + nevent.eventName);
            queue.push(nevent);
          }
        });
        setTimeout(nextEvent, gumshoe.options.queueTimeout);
      }

      function pushEvent(eventName, transportName, data) {
        var transport; // if we're dealing with a fake storage object
        // (eg. sessionStorage isn't available) then don't
        // even bother queueing the data.

        if (storage.isFake()) {
          transport = transports[transportName];
          transport.send(data);
          return;
        } // add the event data to the queue


        queue.push({
          eventName: eventName,
          transportName: transportName,
          data: data
        }); // put our newly modified queue in session storage

        storage('queue', queue);
        setTimeout(nextEvent, gumshoe.options.queueTimeout);
      }

      function transport(tp) {
        if (!tp.name) {
          throw 'Gumshoe: Transport [Object] must have a name defined.';
        }

        transports[tp.name] = tp;
      } // setup some static properties


      gumshoe.version = '0.8.1';
      gumshoe.options = {}; // setup some static methods

      gumshoe.extend = extend;
      gumshoe.reqwest = context.reqwest;
      gumshoe.send = send;
      gumshoe.transport = transport;
      gumshoe.uuid = uuidv4; // setup some internal stuff for access

      gumshoe._ = {
        collect: collect,
        localStorage: localStore,
        queryString: queryString,
        queue: queue,
        storage: storage,
        transports: transports
      };
      return gumshoe;
      /*
      if (root.gumshoe) {
      	if (root.gumshoe.ready) {
      		root.gumshoe.ready = gumshoe.ready = root.gumshoe.ready;
      		root.gumshoe = gumshoe;
      			if (!isFunction(root.gumshoe.ready.resolve)) {
      			throw 'Gumshoe: gumshoe.ready was predefined, but is not a Promise/A deferred.';
      		}
      			root.gumshoe.ready.resolve();
      	}
      }
      else {
      	root.gumshoe = gumshoe;
      }
      */
    }

    module.exports = gumshoeFactory;
  });
  /**
   * @module SDK
   */

  /**
   * The analytics collection endpoint.
   * @ignore
   */

  var ANALYTICS_ENDPOINT = 'https://info.muxy.io';
  /**
   * The Analytics class allows for sending events and metrics to Google Analytics
   * with a given UA_STRING.
   */

  var Analytics =
  /** @class */
  function () {
    function Analytics(uaString, loadPromise) {
      var _this = this;

      this.ready = false;
      this.uaString = uaString;
      this.loadPromise = loadPromise;
      this.user = null;
      this.gumshoe = gumshoe();
      this.gumshoe.transport({
        map: this.mapData.bind(this),
        name: 'muxy-extension-sdk',
        send: function send(data, fn) {
          var d = data; // Remove stuff that we don't want to send up

          delete d.pageData;
          delete d.clientUuid;
          delete d.uuid;
          delete d.sessionUuid;

          _this.gumshoe.reqwest({
            contentType: 'application/x-www-form-urlencoded',
            crossOrigin: true,
            data: d,
            method: 'POST',
            url: ANALYTICS_ENDPOINT
          }, function () {
            if (fn) {
              fn(null);
            }
          });
        }
      });
      this.gumshoe({
        transport: 'muxy-extension-sdk'
      });
      this.loadPromise.then(function () {
        _this.ready = true;
      });
    }
    /**
     * Internal function to map event data to GA format.
     * @private
     */


    Analytics.prototype.mapData = function (data) {
      var appName = 'Muxy';
      var ip = '<unknown ip>';
      var channelID = null;
      var opaqueID = null;
      var userID = null;
      var role = null;
      var game = null;
      var videoMode = null;
      var latency = null;
      var bitrate = null;

      if (this.user) {
        ip = this.user.ip;
        channelID = this.user.channelID;
        opaqueID = this.user.twitchOpaqueID;
        userID = !opaqueID || opaqueID[0] !== 'U' ? null : opaqueID;
        role = this.user.role;
        game = this.user.game;
        videoMode = this.user.videoMode;
        latency = this.user.latency;
        bitrate = this.user.bitrate;
      }

      var pd = data.pageData;
      pd.ipAddress = ip;
      var result = {
        aid: appName,
        an: appName,
        cd1: channelID,
        cd2: role,
        cd3: game,
        cd4: videoMode,
        cid: opaqueID || data.clientUuid || data.sessionUuid || '00000000-0000-0000-0000-000000000000',
        cm2: latency,
        cm3: bitrate,
        dh: pd.hostName,
        dl: pd.url,
        dp: pd.path,
        dr: pd.referer,
        dt: pd.title,
        ea: undefined,
        ec: undefined,
        el: undefined,
        ev: undefined,
        je: pd.javaEnabled,
        sr: pd.screenResolution,
        t: 'event',
        tid: this.uaString,
        ua: pd.userAgent,
        uid: userID,
        uip: ip,
        ul: pd.language,
        v: 1,
        vp: pd.viewportHeight + "x" + pd.viewportWidth
      };

      if (data.eventName === 'page.view') {
        result.t = 'pageview';
      } else {
        result.ec = data.eventName;
        result.ea = data.eventData.name;
        result.el = data.eventData.label;
        result.ev = data.eventData.value;
      }

      return result;
    };
    /**
     * Sends an arbitrary even to Google Analytics.
     *
     * @param {string} category - The high-level category to collect this event under.
     * @param {string} name - A unique identifier for this event.
     * @param {*} value - (optional) A value to associate with this event (defaults to 1).
     * @param {string} label - (optional) A human-readable label for this event.
     */


    Analytics.prototype.sendEvent = function (category, name, value, label) {
      if (value === void 0) {
        value = 1;
      }

      if (label === void 0) {
        label = '';
      }

      if (!this.ready) {
        throw new Error('muxy.Analytics used before ready');
      }

      var data = {
        name: name,
        value: value,
        label: label
      };
      this.gumshoe.send(category, data);
    };
    /**
     * Sends a simple page view event to Google Analytics.
     */


    Analytics.prototype.pageView = function () {
      if (!this.ready) {
        throw new Error('muxy.Analytics used before ready');
      }

      this.gumshoe.send('page.view', {});
    };

    return Analytics;
  }();

  var DebuggingOptions =
  /** @class */
  function () {
    function DebuggingOptions() {
      var noop = function noop() {
        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        /* Default to doing nothing on callback */

      };

      this.options = {
        onPubsubListen: noop,
        onPubsubReceive: noop,
        onPubsubSend: noop
      };

      if (window.location && window.location.search) {
        var qp = new URLSearchParams(window.location.search);
        this.options.url = this.readFromQuery(qp, 'url');
        this.options.url = this.readFromQuery(qp, 'channelID');
        this.options.url = this.readFromQuery(qp, 'userID');
        this.options.url = this.readFromQuery(qp, 'role');
        this.options.url = this.readFromQuery(qp, 'environment');
      }
    }

    DebuggingOptions.prototype.url = function (url) {
      this.options.url = /^https?:\/\//.test(url) ? url : "https://" + url;
      return this;
    };

    DebuggingOptions.prototype.channelID = function (cid) {
      this.options.channelID = cid;
      return this;
    };

    DebuggingOptions.prototype.userID = function (uid) {
      this.options.userID = uid;
      return this;
    };

    DebuggingOptions.prototype.role = function (r) {
      this.options.role = r;
      return this;
    };

    DebuggingOptions.prototype.jwt = function (j) {
      this.options.jwt = j;
      return this;
    };

    DebuggingOptions.prototype.environment = function (e) {
      this.options.environment = e;
      return this;
    };

    DebuggingOptions.prototype.onPubsubSend = function (cb) {
      this.options.onPubsubSend = cb;
      return this;
    };

    DebuggingOptions.prototype.onPubsubReceive = function (cb) {
      this.options.onPubsubReceive = cb;
      return this;
    };

    DebuggingOptions.prototype.onPubsubListen = function (cb) {
      this.options.onPubsubListen = cb;
      return this;
    };

    DebuggingOptions.prototype.readFromQuery = function (params, key) {
      return params.get("muxy_debug_" + key);
    };

    return DebuggingOptions;
  }();

  var pusher = createCommonjsModule(function (module, exports) {
    /*!
     * Pusher JavaScript Library v4.3.1
     * https://pusher.com/
     *
     * Copyright 2017, Pusher
     * Released under the MIT licence.
     */
    (function webpackUniversalModuleDefinition(root, factory) {
      module.exports = factory();
    })(commonjsGlobal, function () {
      return (
        /******/
        function (modules) {
          // webpackBootstrap

          /******/
          // The module cache

          /******/
          var installedModules = {};
          /******/
          // The require function

          /******/

          function __webpack_require__(moduleId) {
            /******/
            // Check if module is in cache

            /******/
            if (installedModules[moduleId])
              /******/
              return installedModules[moduleId].exports;
            /******/
            // Create a new module (and put it into the cache)

            /******/

            var module = installedModules[moduleId] = {
              /******/
              exports: {},

              /******/
              id: moduleId,

              /******/
              loaded: false
              /******/

            };
            /******/
            // Execute the module function

            /******/

            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /******/
            // Flag the module as loaded

            /******/

            module.loaded = true;
            /******/
            // Return the exports of the module

            /******/

            return module.exports;
            /******/
          }
          /******/
          // expose the modules object (__webpack_modules__)

          /******/


          __webpack_require__.m = modules;
          /******/
          // expose the module cache

          /******/

          __webpack_require__.c = installedModules;
          /******/
          // __webpack_public_path__

          /******/

          __webpack_require__.p = "";
          /******/
          // Load entry module and return exports

          /******/

          return __webpack_require__(0);
          /******/
        }(
        /************************************************************************/

        /******/
        [
        /* 0 */

        /***/
        function (module, exports, __webpack_require__) {
          var pusher_1 = __webpack_require__(1);

          module.exports = pusher_1["default"];
          /***/
        },
        /* 1 */

        /***/
        function (module, exports, __webpack_require__) {
          var runtime_1 = __webpack_require__(2);

          var Collections = __webpack_require__(9);

          var dispatcher_1 = __webpack_require__(24);

          var timeline_1 = __webpack_require__(39);

          var level_1 = __webpack_require__(40);

          var StrategyBuilder = __webpack_require__(41);

          var timers_1 = __webpack_require__(12);

          var defaults_1 = __webpack_require__(5);

          var DefaultConfig = __webpack_require__(71);

          var logger_1 = __webpack_require__(8);

          var factory_1 = __webpack_require__(43);

          var url_store_1 = __webpack_require__(14);

          var Pusher = function () {
            function Pusher(app_key, options) {
              var _this = this;

              checkAppKey(app_key);
              options = options || {};

              if (!options.cluster && !(options.wsHost || options.httpHost)) {
                var suffix = url_store_1["default"].buildLogSuffix("javascriptQuickStart");
                logger_1["default"].warn("You should always specify a cluster when connecting. " + suffix);
              }

              this.key = app_key;
              this.config = Collections.extend(DefaultConfig.getGlobalConfig(), options.cluster ? DefaultConfig.getClusterConfig(options.cluster) : {}, options);
              this.channels = factory_1["default"].createChannels();
              this.global_emitter = new dispatcher_1["default"]();
              this.sessionID = Math.floor(Math.random() * 1000000000);
              this.timeline = new timeline_1["default"](this.key, this.sessionID, {
                cluster: this.config.cluster,
                features: Pusher.getClientFeatures(),
                params: this.config.timelineParams || {},
                limit: 50,
                level: level_1["default"].INFO,
                version: defaults_1["default"].VERSION
              });

              if (!this.config.disableStats) {
                this.timelineSender = factory_1["default"].createTimelineSender(this.timeline, {
                  host: this.config.statsHost,
                  path: "/timeline/v2/" + runtime_1["default"].TimelineTransport.name
                });
              }

              var getStrategy = function getStrategy(options) {
                var config = Collections.extend({}, _this.config, options);
                return StrategyBuilder.build(runtime_1["default"].getDefaultStrategy(config), config);
              };

              this.connection = factory_1["default"].createConnectionManager(this.key, Collections.extend({
                getStrategy: getStrategy,
                timeline: this.timeline,
                activityTimeout: this.config.activity_timeout,
                pongTimeout: this.config.pong_timeout,
                unavailableTimeout: this.config.unavailable_timeout
              }, this.config, {
                useTLS: this.shouldUseTLS()
              }));
              this.connection.bind('connected', function () {
                _this.subscribeAll();

                if (_this.timelineSender) {
                  _this.timelineSender.send(_this.connection.isUsingTLS());
                }
              });
              this.connection.bind('message', function (params) {
                var internal = params.event.indexOf('pusher_internal:') === 0;

                if (params.channel) {
                  var channel = _this.channel(params.channel);

                  if (channel) {
                    channel.handleEvent(params.event, params.data);
                  }
                }

                if (!internal) {
                  _this.global_emitter.emit(params.event, params.data);
                }
              });
              this.connection.bind('connecting', function () {
                _this.channels.disconnect();
              });
              this.connection.bind('disconnected', function () {
                _this.channels.disconnect();
              });
              this.connection.bind('error', function (err) {
                logger_1["default"].warn('Error', err);
              });
              Pusher.instances.push(this);
              this.timeline.info({
                instances: Pusher.instances.length
              });

              if (Pusher.isReady) {
                this.connect();
              }
            }

            Pusher.ready = function () {
              Pusher.isReady = true;

              for (var i = 0, l = Pusher.instances.length; i < l; i++) {
                Pusher.instances[i].connect();
              }
            };

            Pusher.log = function (message) {
              if (Pusher.logToConsole && window.console && window.console.log) {
                window.console.log(message);
              }
            };

            Pusher.getClientFeatures = function () {
              return Collections.keys(Collections.filterObject({
                "ws": runtime_1["default"].Transports.ws
              }, function (t) {
                return t.isSupported({});
              }));
            };

            Pusher.prototype.channel = function (name) {
              return this.channels.find(name);
            };

            Pusher.prototype.allChannels = function () {
              return this.channels.all();
            };

            Pusher.prototype.connect = function () {
              this.connection.connect();

              if (this.timelineSender) {
                if (!this.timelineSenderTimer) {
                  var usingTLS = this.connection.isUsingTLS();
                  var timelineSender = this.timelineSender;
                  this.timelineSenderTimer = new timers_1.PeriodicTimer(60000, function () {
                    timelineSender.send(usingTLS);
                  });
                }
              }
            };

            Pusher.prototype.disconnect = function () {
              this.connection.disconnect();

              if (this.timelineSenderTimer) {
                this.timelineSenderTimer.ensureAborted();
                this.timelineSenderTimer = null;
              }
            };

            Pusher.prototype.bind = function (event_name, callback, context) {
              this.global_emitter.bind(event_name, callback, context);
              return this;
            };

            Pusher.prototype.unbind = function (event_name, callback, context) {
              this.global_emitter.unbind(event_name, callback, context);
              return this;
            };

            Pusher.prototype.bind_global = function (callback) {
              this.global_emitter.bind_global(callback);
              return this;
            };

            Pusher.prototype.unbind_global = function (callback) {
              this.global_emitter.unbind_global(callback);
              return this;
            };

            Pusher.prototype.unbind_all = function (callback) {
              this.global_emitter.unbind_all();
              return this;
            };

            Pusher.prototype.subscribeAll = function () {
              var channelName;

              for (channelName in this.channels.channels) {
                if (this.channels.channels.hasOwnProperty(channelName)) {
                  this.subscribe(channelName);
                }
              }
            };

            Pusher.prototype.subscribe = function (channel_name) {
              var channel = this.channels.add(channel_name, this);

              if (channel.subscriptionPending && channel.subscriptionCancelled) {
                channel.reinstateSubscription();
              } else if (!channel.subscriptionPending && this.connection.state === "connected") {
                channel.subscribe();
              }

              return channel;
            };

            Pusher.prototype.unsubscribe = function (channel_name) {
              var channel = this.channels.find(channel_name);

              if (channel && channel.subscriptionPending) {
                channel.cancelSubscription();
              } else {
                channel = this.channels.remove(channel_name);

                if (channel && this.connection.state === "connected") {
                  channel.unsubscribe();
                }
              }
            };

            Pusher.prototype.send_event = function (event_name, data, channel) {
              return this.connection.send_event(event_name, data, channel);
            };

            Pusher.prototype.shouldUseTLS = function () {
              if (runtime_1["default"].getProtocol() === "https:") {
                return true;
              } else if (this.config.forceTLS === true) {
                return true;
              } else {
                return Boolean(this.config.encrypted);
              }
            };

            Pusher.instances = [];
            Pusher.isReady = false;
            Pusher.logToConsole = false;
            Pusher.Runtime = runtime_1["default"];
            Pusher.ScriptReceivers = runtime_1["default"].ScriptReceivers;
            Pusher.DependenciesReceivers = runtime_1["default"].DependenciesReceivers;
            Pusher.auth_callbacks = runtime_1["default"].auth_callbacks;
            return Pusher;
          }();

          exports.__esModule = true;
          exports["default"] = Pusher;

          function checkAppKey(key) {
            if (key === null || key === undefined) {
              throw "You must pass your app key when you instantiate Pusher.";
            }
          }

          runtime_1["default"].setup(Pusher);
          /***/
        },
        /* 2 */

        /***/
        function (module, exports, __webpack_require__) {
          var dependencies_1 = __webpack_require__(3);

          var xhr_auth_1 = __webpack_require__(7);

          var jsonp_auth_1 = __webpack_require__(15);

          var script_request_1 = __webpack_require__(16);

          var jsonp_request_1 = __webpack_require__(17);

          var script_receiver_factory_1 = __webpack_require__(4);

          var jsonp_timeline_1 = __webpack_require__(18);

          var transports_1 = __webpack_require__(19);

          var net_info_1 = __webpack_require__(26);

          var default_strategy_1 = __webpack_require__(27);

          var transport_connection_initializer_1 = __webpack_require__(28);

          var http_1 = __webpack_require__(29);

          var Runtime = {
            nextAuthCallbackID: 1,
            auth_callbacks: {},
            ScriptReceivers: script_receiver_factory_1.ScriptReceivers,
            DependenciesReceivers: dependencies_1.DependenciesReceivers,
            getDefaultStrategy: default_strategy_1["default"],
            Transports: transports_1["default"],
            transportConnectionInitializer: transport_connection_initializer_1["default"],
            HTTPFactory: http_1["default"],
            TimelineTransport: jsonp_timeline_1["default"],
            getXHRAPI: function getXHRAPI() {
              return window.XMLHttpRequest;
            },
            getWebSocketAPI: function getWebSocketAPI() {
              return window.WebSocket || window.MozWebSocket;
            },
            setup: function setup(PusherClass) {
              var _this = this;

              window.Pusher = PusherClass;

              var initializeOnDocumentBody = function initializeOnDocumentBody() {
                _this.onDocumentBody(PusherClass.ready);
              };

              if (!window.JSON) {
                dependencies_1.Dependencies.load("json2", {}, initializeOnDocumentBody);
              } else {
                initializeOnDocumentBody();
              }
            },
            getDocument: function getDocument() {
              return document;
            },
            getProtocol: function getProtocol() {
              return this.getDocument().location.protocol;
            },
            getAuthorizers: function getAuthorizers() {
              return {
                ajax: xhr_auth_1["default"],
                jsonp: jsonp_auth_1["default"]
              };
            },
            onDocumentBody: function onDocumentBody(callback) {
              var _this = this;

              if (document.body) {
                callback();
              } else {
                setTimeout(function () {
                  _this.onDocumentBody(callback);
                }, 0);
              }
            },
            createJSONPRequest: function createJSONPRequest(url, data) {
              return new jsonp_request_1["default"](url, data);
            },
            createScriptRequest: function createScriptRequest(src) {
              return new script_request_1["default"](src);
            },
            getLocalStorage: function getLocalStorage() {
              try {
                return window.localStorage;
              } catch (e) {
                return undefined;
              }
            },
            createXHR: function createXHR() {
              if (this.getXHRAPI()) {
                return this.createXMLHttpRequest();
              } else {
                return this.createMicrosoftXHR();
              }
            },
            createXMLHttpRequest: function createXMLHttpRequest() {
              var Constructor = this.getXHRAPI();
              return new Constructor();
            },
            createMicrosoftXHR: function createMicrosoftXHR() {
              return new ActiveXObject("Microsoft.XMLHTTP");
            },
            getNetwork: function getNetwork() {
              return net_info_1.Network;
            },
            createWebSocket: function createWebSocket(url) {
              var Constructor = this.getWebSocketAPI();
              return new Constructor(url);
            },
            createSocketRequest: function createSocketRequest(method, url) {
              if (this.isXHRSupported()) {
                return this.HTTPFactory.createXHR(method, url);
              } else if (this.isXDRSupported(url.indexOf("https:") === 0)) {
                return this.HTTPFactory.createXDR(method, url);
              } else {
                throw "Cross-origin HTTP requests are not supported";
              }
            },
            isXHRSupported: function isXHRSupported() {
              var Constructor = this.getXHRAPI();
              return Boolean(Constructor) && new Constructor().withCredentials !== undefined;
            },
            isXDRSupported: function isXDRSupported(useTLS) {
              var protocol = useTLS ? "https:" : "http:";
              var documentProtocol = this.getProtocol();
              return Boolean(window['XDomainRequest']) && documentProtocol === protocol;
            },
            addUnloadListener: function addUnloadListener(listener) {
              if (window.addEventListener !== undefined) {
                window.addEventListener("unload", listener, false);
              } else if (window.attachEvent !== undefined) {
                window.attachEvent("onunload", listener);
              }
            },
            removeUnloadListener: function removeUnloadListener(listener) {
              if (window.addEventListener !== undefined) {
                window.removeEventListener("unload", listener, false);
              } else if (window.detachEvent !== undefined) {
                window.detachEvent("onunload", listener);
              }
            }
          };
          exports.__esModule = true;
          exports["default"] = Runtime;
          /***/
        },
        /* 3 */

        /***/
        function (module, exports, __webpack_require__) {
          var script_receiver_factory_1 = __webpack_require__(4);

          var defaults_1 = __webpack_require__(5);

          var dependency_loader_1 = __webpack_require__(6);

          exports.DependenciesReceivers = new script_receiver_factory_1.ScriptReceiverFactory("_pusher_dependencies", "Pusher.DependenciesReceivers");
          exports.Dependencies = new dependency_loader_1["default"]({
            cdn_http: defaults_1["default"].cdn_http,
            cdn_https: defaults_1["default"].cdn_https,
            version: defaults_1["default"].VERSION,
            suffix: defaults_1["default"].dependency_suffix,
            receivers: exports.DependenciesReceivers
          });
          /***/
        },
        /* 4 */

        /***/
        function (module, exports) {
          var ScriptReceiverFactory = function () {
            function ScriptReceiverFactory(prefix, name) {
              this.lastId = 0;
              this.prefix = prefix;
              this.name = name;
            }

            ScriptReceiverFactory.prototype.create = function (callback) {
              this.lastId++;
              var number = this.lastId;
              var id = this.prefix + number;
              var name = this.name + "[" + number + "]";
              var called = false;

              var callbackWrapper = function callbackWrapper() {
                if (!called) {
                  callback.apply(null, arguments);
                  called = true;
                }
              };

              this[number] = callbackWrapper;
              return {
                number: number,
                id: id,
                name: name,
                callback: callbackWrapper
              };
            };

            ScriptReceiverFactory.prototype.remove = function (receiver) {
              delete this[receiver.number];
            };

            return ScriptReceiverFactory;
          }();

          exports.ScriptReceiverFactory = ScriptReceiverFactory;
          exports.ScriptReceivers = new ScriptReceiverFactory("_pusher_script_", "Pusher.ScriptReceivers");
          /***/
        },
        /* 5 */

        /***/
        function (module, exports) {
          var Defaults = {
            VERSION: "4.3.1",
            PROTOCOL: 7,
            host: 'ws.pusherapp.com',
            ws_port: 80,
            wss_port: 443,
            ws_path: '',
            sockjs_host: 'sockjs.pusher.com',
            sockjs_http_port: 80,
            sockjs_https_port: 443,
            sockjs_path: "/pusher",
            stats_host: 'stats.pusher.com',
            channel_auth_endpoint: '/pusher/auth',
            channel_auth_transport: 'ajax',
            activity_timeout: 120000,
            pong_timeout: 30000,
            unavailable_timeout: 10000,
            cdn_http: 'http://js.pusher.com',
            cdn_https: 'https://js.pusher.com',
            dependency_suffix: ''
          };
          exports.__esModule = true;
          exports["default"] = Defaults;
          /***/
        },
        /* 6 */

        /***/
        function (module, exports, __webpack_require__) {
          var script_receiver_factory_1 = __webpack_require__(4);

          var runtime_1 = __webpack_require__(2);

          var DependencyLoader = function () {
            function DependencyLoader(options) {
              this.options = options;
              this.receivers = options.receivers || script_receiver_factory_1.ScriptReceivers;
              this.loading = {};
            }

            DependencyLoader.prototype.load = function (name, options, callback) {
              var self = this;

              if (self.loading[name] && self.loading[name].length > 0) {
                self.loading[name].push(callback);
              } else {
                self.loading[name] = [callback];
                var request = runtime_1["default"].createScriptRequest(self.getPath(name, options));
                var receiver = self.receivers.create(function (error) {
                  self.receivers.remove(receiver);

                  if (self.loading[name]) {
                    var callbacks = self.loading[name];
                    delete self.loading[name];

                    var successCallback = function successCallback(wasSuccessful) {
                      if (!wasSuccessful) {
                        request.cleanup();
                      }
                    };

                    for (var i = 0; i < callbacks.length; i++) {
                      callbacks[i](error, successCallback);
                    }
                  }
                });
                request.send(receiver);
              }
            };

            DependencyLoader.prototype.getRoot = function (options) {
              var cdn;
              var protocol = runtime_1["default"].getDocument().location.protocol;

              if (options && options.useTLS || protocol === "https:") {
                cdn = this.options.cdn_https;
              } else {
                cdn = this.options.cdn_http;
              }

              return cdn.replace(/\/*$/, "") + "/" + this.options.version;
            };

            DependencyLoader.prototype.getPath = function (name, options) {
              return this.getRoot(options) + '/' + name + this.options.suffix + '.js';
            };

            return DependencyLoader;
          }();

          exports.__esModule = true;
          exports["default"] = DependencyLoader;
          /***/
        },
        /* 7 */

        /***/
        function (module, exports, __webpack_require__) {
          var logger_1 = __webpack_require__(8);

          var runtime_1 = __webpack_require__(2);

          var url_store_1 = __webpack_require__(14);

          var ajax = function ajax(context, socketId, callback) {
            var self = this,
                xhr;
            xhr = runtime_1["default"].createXHR();
            xhr.open("POST", self.options.authEndpoint, true);
            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

            for (var headerName in this.authOptions.headers) {
              xhr.setRequestHeader(headerName, this.authOptions.headers[headerName]);
            }

            xhr.onreadystatechange = function () {
              if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                  var data,
                      parsed = false;

                  try {
                    data = JSON.parse(xhr.responseText);
                    parsed = true;
                  } catch (e) {
                    callback(true, 'JSON returned from webapp was invalid, yet status code was 200. Data was: ' + xhr.responseText);
                  }

                  if (parsed) {
                    callback(false, data);
                  }
                } else {
                  var suffix = url_store_1["default"].buildLogSuffix("authenticationEndpoint");
                  logger_1["default"].warn("Couldn't retrieve authentication info. " + xhr.status + ("Clients must be authenticated to join private or presence channels. " + suffix));
                  callback(true, xhr.status);
                }
              }
            };

            xhr.send(this.composeQuery(socketId));
            return xhr;
          };

          exports.__esModule = true;
          exports["default"] = ajax;
          /***/
        },
        /* 8 */

        /***/
        function (module, exports, __webpack_require__) {
          var collections_1 = __webpack_require__(9);

          var pusher_1 = __webpack_require__(1);

          var Logger = {
            debug: function debug() {
              var args = [];

              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
              }

              if (!pusher_1["default"].log) {
                return;
              }

              pusher_1["default"].log(collections_1.stringify.apply(this, arguments));
            },
            warn: function warn() {
              var args = [];

              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
              }

              var message = collections_1.stringify.apply(this, arguments);

              if (pusher_1["default"].log) {
                pusher_1["default"].log(message);
              } else if (window.console) {
                if (window.console.warn) {
                  window.console.warn(message);
                } else if (window.console.log) {
                  window.console.log(message);
                }
              }
            }
          };
          exports.__esModule = true;
          exports["default"] = Logger;
          /***/
        },
        /* 9 */

        /***/
        function (module, exports, __webpack_require__) {
          var base64_1 = __webpack_require__(10);

          var util_1 = __webpack_require__(11);

          function extend(target) {
            var sources = [];

            for (var _i = 1; _i < arguments.length; _i++) {
              sources[_i - 1] = arguments[_i];
            }

            for (var i = 0; i < sources.length; i++) {
              var extensions = sources[i];

              for (var property in extensions) {
                if (extensions[property] && extensions[property].constructor && extensions[property].constructor === Object) {
                  target[property] = extend(target[property] || {}, extensions[property]);
                } else {
                  target[property] = extensions[property];
                }
              }
            }

            return target;
          }

          exports.extend = extend;

          function stringify() {
            var m = ["Pusher"];

            for (var i = 0; i < arguments.length; i++) {
              if (typeof arguments[i] === "string") {
                m.push(arguments[i]);
              } else {
                m.push(safeJSONStringify(arguments[i]));
              }
            }

            return m.join(" : ");
          }

          exports.stringify = stringify;

          function arrayIndexOf(array, item) {
            var nativeIndexOf = Array.prototype.indexOf;

            if (array === null) {
              return -1;
            }

            if (nativeIndexOf && array.indexOf === nativeIndexOf) {
              return array.indexOf(item);
            }

            for (var i = 0, l = array.length; i < l; i++) {
              if (array[i] === item) {
                return i;
              }
            }

            return -1;
          }

          exports.arrayIndexOf = arrayIndexOf;

          function objectApply(object, f) {
            for (var key in object) {
              if (Object.prototype.hasOwnProperty.call(object, key)) {
                f(object[key], key, object);
              }
            }
          }

          exports.objectApply = objectApply;

          function keys(object) {
            var keys = [];
            objectApply(object, function (_, key) {
              keys.push(key);
            });
            return keys;
          }

          exports.keys = keys;

          function values(object) {
            var values = [];
            objectApply(object, function (value) {
              values.push(value);
            });
            return values;
          }

          exports.values = values;

          function apply(array, f, context) {
            for (var i = 0; i < array.length; i++) {
              f.call(context || window, array[i], i, array);
            }
          }

          exports.apply = apply;

          function map(array, f) {
            var result = [];

            for (var i = 0; i < array.length; i++) {
              result.push(f(array[i], i, array, result));
            }

            return result;
          }

          exports.map = map;

          function mapObject(object, f) {
            var result = {};
            objectApply(object, function (value, key) {
              result[key] = f(value);
            });
            return result;
          }

          exports.mapObject = mapObject;

          function filter(array, test) {
            test = test || function (value) {
              return !!value;
            };

            var result = [];

            for (var i = 0; i < array.length; i++) {
              if (test(array[i], i, array, result)) {
                result.push(array[i]);
              }
            }

            return result;
          }

          exports.filter = filter;

          function filterObject(object, test) {
            var result = {};
            objectApply(object, function (value, key) {
              if (test && test(value, key, object, result) || Boolean(value)) {
                result[key] = value;
              }
            });
            return result;
          }

          exports.filterObject = filterObject;

          function flatten(object) {
            var result = [];
            objectApply(object, function (value, key) {
              result.push([key, value]);
            });
            return result;
          }

          exports.flatten = flatten;

          function any(array, test) {
            for (var i = 0; i < array.length; i++) {
              if (test(array[i], i, array)) {
                return true;
              }
            }

            return false;
          }

          exports.any = any;

          function all(array, test) {
            for (var i = 0; i < array.length; i++) {
              if (!test(array[i], i, array)) {
                return false;
              }
            }

            return true;
          }

          exports.all = all;

          function encodeParamsObject(data) {
            return mapObject(data, function (value) {
              if (_typeof(value) === "object") {
                value = safeJSONStringify(value);
              }

              return encodeURIComponent(base64_1["default"](value.toString()));
            });
          }

          exports.encodeParamsObject = encodeParamsObject;

          function buildQueryString(data) {
            var params = filterObject(data, function (value) {
              return value !== undefined;
            });
            var query = map(flatten(encodeParamsObject(params)), util_1["default"].method("join", "=")).join("&");
            return query;
          }

          exports.buildQueryString = buildQueryString;

          function decycleObject(object) {
            var objects = [],
                paths = [];
            return function derez(value, path) {
              var i, name, nu;

              switch (_typeof(value)) {
                case 'object':
                  if (!value) {
                    return null;
                  }

                  for (i = 0; i < objects.length; i += 1) {
                    if (objects[i] === value) {
                      return {
                        $ref: paths[i]
                      };
                    }
                  }

                  objects.push(value);
                  paths.push(path);

                  if (Object.prototype.toString.apply(value) === '[object Array]') {
                    nu = [];

                    for (i = 0; i < value.length; i += 1) {
                      nu[i] = derez(value[i], path + '[' + i + ']');
                    }
                  } else {
                    nu = {};

                    for (name in value) {
                      if (Object.prototype.hasOwnProperty.call(value, name)) {
                        nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');
                      }
                    }
                  }

                  return nu;

                case 'number':
                case 'string':
                case 'boolean':
                  return value;
              }
            }(object, '$');
          }

          exports.decycleObject = decycleObject;

          function safeJSONStringify(source) {
            try {
              return JSON.stringify(source);
            } catch (e) {
              return JSON.stringify(decycleObject(source));
            }
          }

          exports.safeJSONStringify = safeJSONStringify;
          /***/
        },
        /* 10 */

        /***/
        function (module, exports, __webpack_require__) {
          function encode(s) {
            return btoa(utob(s));
          }

          exports.__esModule = true;
          exports["default"] = encode;
          var fromCharCode = String.fromCharCode;
          var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

          var cb_utob = function cb_utob(c) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c : cc < 0x800 ? fromCharCode(0xc0 | cc >>> 6) + fromCharCode(0x80 | cc & 0x3f) : fromCharCode(0xe0 | cc >>> 12 & 0x0f) + fromCharCode(0x80 | cc >>> 6 & 0x3f) + fromCharCode(0x80 | cc & 0x3f);
          };

          var utob = function utob(u) {
            return u.replace(/[^\x00-\x7F]/g, cb_utob);
          };

          var cb_encode = function cb_encode(ccc) {
            var padlen = [0, 2, 1][ccc.length % 3];
            var ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0);
            var chars = [b64chars.charAt(ord >>> 18), b64chars.charAt(ord >>> 12 & 63), padlen >= 2 ? '=' : b64chars.charAt(ord >>> 6 & 63), padlen >= 1 ? '=' : b64chars.charAt(ord & 63)];
            return chars.join('');
          };

          var btoa = window.btoa || function (b) {
            return b.replace(/[\s\S]{1,3}/g, cb_encode);
          };
          /***/

        },
        /* 11 */

        /***/
        function (module, exports, __webpack_require__) {
          var timers_1 = __webpack_require__(12);

          var Util = {
            now: function now() {
              if (Date.now) {
                return Date.now();
              } else {
                return new Date().valueOf();
              }
            },
            defer: function defer(callback) {
              return new timers_1.OneOffTimer(0, callback);
            },
            method: function method(name) {
              var args = [];

              for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
              }

              var boundArguments = Array.prototype.slice.call(arguments, 1);
              return function (object) {
                return object[name].apply(object, boundArguments.concat(arguments));
              };
            }
          };
          exports.__esModule = true;
          exports["default"] = Util;
          /***/
        },
        /* 12 */

        /***/
        function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };

          var abstract_timer_1 = __webpack_require__(13);

          function clearTimeout(timer) {
            window.clearTimeout(timer);
          }

          function clearInterval(timer) {
            window.clearInterval(timer);
          }

          var OneOffTimer = function (_super) {
            __extends(OneOffTimer, _super);

            function OneOffTimer(delay, callback) {
              _super.call(this, setTimeout, clearTimeout, delay, function (timer) {
                callback();
                return null;
              });
            }

            return OneOffTimer;
          }(abstract_timer_1["default"]);

          exports.OneOffTimer = OneOffTimer;

          var PeriodicTimer = function (_super) {
            __extends(PeriodicTimer, _super);

            function PeriodicTimer(delay, callback) {
              _super.call(this, setInterval, clearInterval, delay, function (timer) {
                callback();
                return timer;
              });
            }

            return PeriodicTimer;
          }(abstract_timer_1["default"]);

          exports.PeriodicTimer = PeriodicTimer;
          /***/
        },
        /* 13 */

        /***/
        function (module, exports) {
          var Timer = function () {
            function Timer(set, clear, delay, callback) {
              var _this = this;

              this.clear = clear;
              this.timer = set(function () {
                if (_this.timer) {
                  _this.timer = callback(_this.timer);
                }
              }, delay);
            }

            Timer.prototype.isRunning = function () {
              return this.timer !== null;
            };

            Timer.prototype.ensureAborted = function () {
              if (this.timer) {
                this.clear(this.timer);
                this.timer = null;
              }
            };

            return Timer;
          }();

          exports.__esModule = true;
          exports["default"] = Timer;
          /***/
        },
        /* 14 */

        /***/
        function (module, exports) {
          var urlStore = {
            baseUrl: "https://pusher.com",
            urls: {
              authenticationEndpoint: {
                path: "/docs/authenticating_users"
              },
              javascriptQuickStart: {
                path: "/docs/javascript_quick_start"
              }
            }
          };

          var buildLogSuffix = function buildLogSuffix(key) {
            var urlPrefix = "See:";
            var urlObj = urlStore.urls[key];
            if (!urlObj) return "";
            var url;

            if (urlObj.fullUrl) {
              url = urlObj.fullUrl;
            } else if (urlObj.path) {
              url = urlStore.baseUrl + urlObj.path;
            }

            if (!url) return "";
            return urlPrefix + " " + url;
          };

          exports.__esModule = true;
          exports["default"] = {
            buildLogSuffix: buildLogSuffix
          };
          /***/
        },
        /* 15 */

        /***/
        function (module, exports, __webpack_require__) {
          var logger_1 = __webpack_require__(8);

          var jsonp = function jsonp(context, socketId, callback) {
            if (this.authOptions.headers !== undefined) {
              logger_1["default"].warn("Warn", "To send headers with the auth request, you must use AJAX, rather than JSONP.");
            }

            var callbackName = context.nextAuthCallbackID.toString();
            context.nextAuthCallbackID++;
            var document = context.getDocument();
            var script = document.createElement("script");

            context.auth_callbacks[callbackName] = function (data) {
              callback(false, data);
            };

            var callback_name = "Pusher.auth_callbacks['" + callbackName + "']";
            script.src = this.options.authEndpoint + '?callback=' + encodeURIComponent(callback_name) + '&' + this.composeQuery(socketId);
            var head = document.getElementsByTagName("head")[0] || document.documentElement;
            head.insertBefore(script, head.firstChild);
          };

          exports.__esModule = true;
          exports["default"] = jsonp;
          /***/
        },
        /* 16 */

        /***/
        function (module, exports) {
          var ScriptRequest = function () {
            function ScriptRequest(src) {
              this.src = src;
            }

            ScriptRequest.prototype.send = function (receiver) {
              var self = this;
              var errorString = "Error loading " + self.src;
              self.script = document.createElement("script");
              self.script.id = receiver.id;
              self.script.src = self.src;
              self.script.type = "text/javascript";
              self.script.charset = "UTF-8";

              if (self.script.addEventListener) {
                self.script.onerror = function () {
                  receiver.callback(errorString);
                };

                self.script.onload = function () {
                  receiver.callback(null);
                };
              } else {
                self.script.onreadystatechange = function () {
                  if (self.script.readyState === 'loaded' || self.script.readyState === 'complete') {
                    receiver.callback(null);
                  }
                };
              }

              if (self.script.async === undefined && document.attachEvent && /opera/i.test(navigator.userAgent)) {
                self.errorScript = document.createElement("script");
                self.errorScript.id = receiver.id + "_error";
                self.errorScript.text = receiver.name + "('" + errorString + "');";
                self.script.async = self.errorScript.async = false;
              } else {
                self.script.async = true;
              }

              var head = document.getElementsByTagName('head')[0];
              head.insertBefore(self.script, head.firstChild);

              if (self.errorScript) {
                head.insertBefore(self.errorScript, self.script.nextSibling);
              }
            };

            ScriptRequest.prototype.cleanup = function () {
              if (this.script) {
                this.script.onload = this.script.onerror = null;
                this.script.onreadystatechange = null;
              }

              if (this.script && this.script.parentNode) {
                this.script.parentNode.removeChild(this.script);
              }

              if (this.errorScript && this.errorScript.parentNode) {
                this.errorScript.parentNode.removeChild(this.errorScript);
              }

              this.script = null;
              this.errorScript = null;
            };

            return ScriptRequest;
          }();

          exports.__esModule = true;
          exports["default"] = ScriptRequest;
          /***/
        },
        /* 17 */

        /***/
        function (module, exports, __webpack_require__) {
          var Collections = __webpack_require__(9);

          var runtime_1 = __webpack_require__(2);

          var JSONPRequest = function () {
            function JSONPRequest(url, data) {
              this.url = url;
              this.data = data;
            }

            JSONPRequest.prototype.send = function (receiver) {
              if (this.request) {
                return;
              }

              var query = Collections.buildQueryString(this.data);
              var url = this.url + "/" + receiver.number + "?" + query;
              this.request = runtime_1["default"].createScriptRequest(url);
              this.request.send(receiver);
            };

            JSONPRequest.prototype.cleanup = function () {
              if (this.request) {
                this.request.cleanup();
              }
            };

            return JSONPRequest;
          }();

          exports.__esModule = true;
          exports["default"] = JSONPRequest;
          /***/
        },
        /* 18 */

        /***/
        function (module, exports, __webpack_require__) {
          var runtime_1 = __webpack_require__(2);

          var script_receiver_factory_1 = __webpack_require__(4);

          var getAgent = function getAgent(sender, useTLS) {
            return function (data, callback) {
              var scheme = "http" + (useTLS ? "s" : "") + "://";
              var url = scheme + (sender.host || sender.options.host) + sender.options.path;
              var request = runtime_1["default"].createJSONPRequest(url, data);
              var receiver = runtime_1["default"].ScriptReceivers.create(function (error, result) {
                script_receiver_factory_1.ScriptReceivers.remove(receiver);
                request.cleanup();

                if (result && result.host) {
                  sender.host = result.host;
                }

                if (callback) {
                  callback(error, result);
                }
              });
              request.send(receiver);
            };
          };

          var jsonp = {
            name: 'jsonp',
            getAgent: getAgent
          };
          exports.__esModule = true;
          exports["default"] = jsonp;
          /***/
        },
        /* 19 */

        /***/
        function (module, exports, __webpack_require__) {
          var transports_1 = __webpack_require__(20);

          var transport_1 = __webpack_require__(22);

          var URLSchemes = __webpack_require__(21);

          var runtime_1 = __webpack_require__(2);

          var dependencies_1 = __webpack_require__(3);

          var Collections = __webpack_require__(9);

          var SockJSTransport = new transport_1["default"]({
            file: "sockjs",
            urls: URLSchemes.sockjs,
            handlesActivityChecks: true,
            supportsPing: false,
            isSupported: function isSupported() {
              return true;
            },
            isInitialized: function isInitialized() {
              return window.SockJS !== undefined;
            },
            getSocket: function getSocket(url, options) {
              return new window.SockJS(url, null, {
                js_path: dependencies_1.Dependencies.getPath("sockjs", {
                  useTLS: options.useTLS
                }),
                ignore_null_origin: options.ignoreNullOrigin
              });
            },
            beforeOpen: function beforeOpen(socket, path) {
              socket.send(JSON.stringify({
                path: path
              }));
            }
          });
          var xdrConfiguration = {
            isSupported: function isSupported(environment) {
              var yes = runtime_1["default"].isXDRSupported(environment.useTLS);
              return yes;
            }
          };
          var XDRStreamingTransport = new transport_1["default"](Collections.extend({}, transports_1.streamingConfiguration, xdrConfiguration));
          var XDRPollingTransport = new transport_1["default"](Collections.extend({}, transports_1.pollingConfiguration, xdrConfiguration));
          transports_1["default"].xdr_streaming = XDRStreamingTransport;
          transports_1["default"].xdr_polling = XDRPollingTransport;
          transports_1["default"].sockjs = SockJSTransport;
          exports.__esModule = true;
          exports["default"] = transports_1["default"];
          /***/
        },
        /* 20 */

        /***/
        function (module, exports, __webpack_require__) {
          var URLSchemes = __webpack_require__(21);

          var transport_1 = __webpack_require__(22);

          var Collections = __webpack_require__(9);

          var runtime_1 = __webpack_require__(2);

          var WSTransport = new transport_1["default"]({
            urls: URLSchemes.ws,
            handlesActivityChecks: false,
            supportsPing: false,
            isInitialized: function isInitialized() {
              return Boolean(runtime_1["default"].getWebSocketAPI());
            },
            isSupported: function isSupported() {
              return Boolean(runtime_1["default"].getWebSocketAPI());
            },
            getSocket: function getSocket(url) {
              return runtime_1["default"].createWebSocket(url);
            }
          });
          var httpConfiguration = {
            urls: URLSchemes.http,
            handlesActivityChecks: false,
            supportsPing: true,
            isInitialized: function isInitialized() {
              return true;
            }
          };
          exports.streamingConfiguration = Collections.extend({
            getSocket: function getSocket(url) {
              return runtime_1["default"].HTTPFactory.createStreamingSocket(url);
            }
          }, httpConfiguration);
          exports.pollingConfiguration = Collections.extend({
            getSocket: function getSocket(url) {
              return runtime_1["default"].HTTPFactory.createPollingSocket(url);
            }
          }, httpConfiguration);
          var xhrConfiguration = {
            isSupported: function isSupported() {
              return runtime_1["default"].isXHRSupported();
            }
          };
          var XHRStreamingTransport = new transport_1["default"](Collections.extend({}, exports.streamingConfiguration, xhrConfiguration));
          var XHRPollingTransport = new transport_1["default"](Collections.extend({}, exports.pollingConfiguration, xhrConfiguration));
          var Transports = {
            ws: WSTransport,
            xhr_streaming: XHRStreamingTransport,
            xhr_polling: XHRPollingTransport
          };
          exports.__esModule = true;
          exports["default"] = Transports;
          /***/
        },
        /* 21 */

        /***/
        function (module, exports, __webpack_require__) {
          var defaults_1 = __webpack_require__(5);

          function getGenericURL(baseScheme, params, path) {
            var scheme = baseScheme + (params.useTLS ? "s" : "");
            var host = params.useTLS ? params.hostTLS : params.hostNonTLS;
            return scheme + "://" + host + path;
          }

          function getGenericPath(key, queryString) {
            var path = "/app/" + key;
            var query = "?protocol=" + defaults_1["default"].PROTOCOL + "&client=js" + "&version=" + defaults_1["default"].VERSION + (queryString ? "&" + queryString : "");
            return path + query;
          }

          exports.ws = {
            getInitial: function getInitial(key, params) {
              var path = (params.httpPath || "") + getGenericPath(key, "flash=false");
              return getGenericURL("ws", params, path);
            }
          };
          exports.http = {
            getInitial: function getInitial(key, params) {
              var path = (params.httpPath || "/pusher") + getGenericPath(key);
              return getGenericURL("http", params, path);
            }
          };
          exports.sockjs = {
            getInitial: function getInitial(key, params) {
              return getGenericURL("http", params, params.httpPath || "/pusher");
            },
            getPath: function getPath(key, params) {
              return getGenericPath(key);
            }
          };
          /***/
        },
        /* 22 */

        /***/
        function (module, exports, __webpack_require__) {
          var transport_connection_1 = __webpack_require__(23);

          var Transport = function () {
            function Transport(hooks) {
              this.hooks = hooks;
            }

            Transport.prototype.isSupported = function (environment) {
              return this.hooks.isSupported(environment);
            };

            Transport.prototype.createConnection = function (name, priority, key, options) {
              return new transport_connection_1["default"](this.hooks, name, priority, key, options);
            };

            return Transport;
          }();

          exports.__esModule = true;
          exports["default"] = Transport;
          /***/
        },
        /* 23 */

        /***/
        function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };

          var util_1 = __webpack_require__(11);

          var Collections = __webpack_require__(9);

          var dispatcher_1 = __webpack_require__(24);

          var logger_1 = __webpack_require__(8);

          var runtime_1 = __webpack_require__(2);

          var TransportConnection = function (_super) {
            __extends(TransportConnection, _super);

            function TransportConnection(hooks, name, priority, key, options) {
              _super.call(this);

              this.initialize = runtime_1["default"].transportConnectionInitializer;
              this.hooks = hooks;
              this.name = name;
              this.priority = priority;
              this.key = key;
              this.options = options;
              this.state = "new";
              this.timeline = options.timeline;
              this.activityTimeout = options.activityTimeout;
              this.id = this.timeline.generateUniqueID();
            }

            TransportConnection.prototype.handlesActivityChecks = function () {
              return Boolean(this.hooks.handlesActivityChecks);
            };

            TransportConnection.prototype.supportsPing = function () {
              return Boolean(this.hooks.supportsPing);
            };

            TransportConnection.prototype.connect = function () {
              var _this = this;

              if (this.socket || this.state !== "initialized") {
                return false;
              }

              var url = this.hooks.urls.getInitial(this.key, this.options);

              try {
                this.socket = this.hooks.getSocket(url, this.options);
              } catch (e) {
                util_1["default"].defer(function () {
                  _this.onError(e);

                  _this.changeState("closed");
                });
                return false;
              }

              this.bindListeners();
              logger_1["default"].debug("Connecting", {
                transport: this.name,
                url: url
              });
              this.changeState("connecting");
              return true;
            };

            TransportConnection.prototype.close = function () {
              if (this.socket) {
                this.socket.close();
                return true;
              } else {
                return false;
              }
            };

            TransportConnection.prototype.send = function (data) {
              var _this = this;

              if (this.state === "open") {
                util_1["default"].defer(function () {
                  if (_this.socket) {
                    _this.socket.send(data);
                  }
                });
                return true;
              } else {
                return false;
              }
            };

            TransportConnection.prototype.ping = function () {
              if (this.state === "open" && this.supportsPing()) {
                this.socket.ping();
              }
            };

            TransportConnection.prototype.onOpen = function () {
              if (this.hooks.beforeOpen) {
                this.hooks.beforeOpen(this.socket, this.hooks.urls.getPath(this.key, this.options));
              }

              this.changeState("open");
              this.socket.onopen = undefined;
            };

            TransportConnection.prototype.onError = function (error) {
              this.emit("error", {
                type: 'WebSocketError',
                error: error
              });
              this.timeline.error(this.buildTimelineMessage({
                error: error.toString()
              }));
            };

            TransportConnection.prototype.onClose = function (closeEvent) {
              if (closeEvent) {
                this.changeState("closed", {
                  code: closeEvent.code,
                  reason: closeEvent.reason,
                  wasClean: closeEvent.wasClean
                });
              } else {
                this.changeState("closed");
              }

              this.unbindListeners();
              this.socket = undefined;
            };

            TransportConnection.prototype.onMessage = function (message) {
              this.emit("message", message);
            };

            TransportConnection.prototype.onActivity = function () {
              this.emit("activity");
            };

            TransportConnection.prototype.bindListeners = function () {
              var _this = this;

              this.socket.onopen = function () {
                _this.onOpen();
              };

              this.socket.onerror = function (error) {
                _this.onError(error);
              };

              this.socket.onclose = function (closeEvent) {
                _this.onClose(closeEvent);
              };

              this.socket.onmessage = function (message) {
                _this.onMessage(message);
              };

              if (this.supportsPing()) {
                this.socket.onactivity = function () {
                  _this.onActivity();
                };
              }
            };

            TransportConnection.prototype.unbindListeners = function () {
              if (this.socket) {
                this.socket.onopen = undefined;
                this.socket.onerror = undefined;
                this.socket.onclose = undefined;
                this.socket.onmessage = undefined;

                if (this.supportsPing()) {
                  this.socket.onactivity = undefined;
                }
              }
            };

            TransportConnection.prototype.changeState = function (state, params) {
              this.state = state;
              this.timeline.info(this.buildTimelineMessage({
                state: state,
                params: params
              }));
              this.emit(state, params);
            };

            TransportConnection.prototype.buildTimelineMessage = function (message) {
              return Collections.extend({
                cid: this.id
              }, message);
            };

            return TransportConnection;
          }(dispatcher_1["default"]);

          exports.__esModule = true;
          exports["default"] = TransportConnection;
          /***/
        },
        /* 24 */

        /***/
        function (module, exports, __webpack_require__) {
          var Collections = __webpack_require__(9);

          var callback_registry_1 = __webpack_require__(25);

          var Dispatcher = function () {
            function Dispatcher(failThrough) {
              this.callbacks = new callback_registry_1["default"]();
              this.global_callbacks = [];
              this.failThrough = failThrough;
            }

            Dispatcher.prototype.bind = function (eventName, callback, context) {
              this.callbacks.add(eventName, callback, context);
              return this;
            };

            Dispatcher.prototype.bind_global = function (callback) {
              this.global_callbacks.push(callback);
              return this;
            };

            Dispatcher.prototype.unbind = function (eventName, callback, context) {
              this.callbacks.remove(eventName, callback, context);
              return this;
            };

            Dispatcher.prototype.unbind_global = function (callback) {
              if (!callback) {
                this.global_callbacks = [];
                return this;
              }

              this.global_callbacks = Collections.filter(this.global_callbacks || [], function (c) {
                return c !== callback;
              });
              return this;
            };

            Dispatcher.prototype.unbind_all = function () {
              this.unbind();
              this.unbind_global();
              return this;
            };

            Dispatcher.prototype.emit = function (eventName, data) {
              var i;

              for (i = 0; i < this.global_callbacks.length; i++) {
                this.global_callbacks[i](eventName, data);
              }

              var callbacks = this.callbacks.get(eventName);

              if (callbacks && callbacks.length > 0) {
                for (i = 0; i < callbacks.length; i++) {
                  callbacks[i].fn.call(callbacks[i].context || window, data);
                }
              } else if (this.failThrough) {
                this.failThrough(eventName, data);
              }

              return this;
            };

            return Dispatcher;
          }();

          exports.__esModule = true;
          exports["default"] = Dispatcher;
          /***/
        },
        /* 25 */

        /***/
        function (module, exports, __webpack_require__) {
          var Collections = __webpack_require__(9);

          var CallbackRegistry = function () {
            function CallbackRegistry() {
              this._callbacks = {};
            }

            CallbackRegistry.prototype.get = function (name) {
              return this._callbacks[prefix(name)];
            };

            CallbackRegistry.prototype.add = function (name, callback, context) {
              var prefixedEventName = prefix(name);
              this._callbacks[prefixedEventName] = this._callbacks[prefixedEventName] || [];

              this._callbacks[prefixedEventName].push({
                fn: callback,
                context: context
              });
            };

            CallbackRegistry.prototype.remove = function (name, callback, context) {
              if (!name && !callback && !context) {
                this._callbacks = {};
                return;
              }

              var names = name ? [prefix(name)] : Collections.keys(this._callbacks);

              if (callback || context) {
                this.removeCallback(names, callback, context);
              } else {
                this.removeAllCallbacks(names);
              }
            };

            CallbackRegistry.prototype.removeCallback = function (names, callback, context) {
              Collections.apply(names, function (name) {
                this._callbacks[name] = Collections.filter(this._callbacks[name] || [], function (binding) {
                  return callback && callback !== binding.fn || context && context !== binding.context;
                });

                if (this._callbacks[name].length === 0) {
                  delete this._callbacks[name];
                }
              }, this);
            };

            CallbackRegistry.prototype.removeAllCallbacks = function (names) {
              Collections.apply(names, function (name) {
                delete this._callbacks[name];
              }, this);
            };

            return CallbackRegistry;
          }();

          exports.__esModule = true;
          exports["default"] = CallbackRegistry;

          function prefix(name) {
            return "_" + name;
          }
          /***/

        },
        /* 26 */

        /***/
        function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };

          var dispatcher_1 = __webpack_require__(24);

          var NetInfo = function (_super) {
            __extends(NetInfo, _super);

            function NetInfo() {
              _super.call(this);

              var self = this;

              if (window.addEventListener !== undefined) {
                window.addEventListener("online", function () {
                  self.emit('online');
                }, false);
                window.addEventListener("offline", function () {
                  self.emit('offline');
                }, false);
              }
            }

            NetInfo.prototype.isOnline = function () {
              if (window.navigator.onLine === undefined) {
                return true;
              } else {
                return window.navigator.onLine;
              }
            };

            return NetInfo;
          }(dispatcher_1["default"]);

          exports.NetInfo = NetInfo;
          exports.Network = new NetInfo();
          /***/
        },
        /* 27 */

        /***/
        function (module, exports) {
          var getDefaultStrategy = function getDefaultStrategy(config) {
            var wsStrategy;

            if (config.useTLS) {
              wsStrategy = [":best_connected_ever", ":ws_loop", [":delayed", 2000, [":http_fallback_loop"]]];
            } else {
              wsStrategy = [":best_connected_ever", ":ws_loop", [":delayed", 2000, [":wss_loop"]], [":delayed", 5000, [":http_fallback_loop"]]];
            }

            return [[":def", "ws_options", {
              hostNonTLS: config.wsHost + ":" + config.wsPort,
              hostTLS: config.wsHost + ":" + config.wssPort,
              httpPath: config.wsPath
            }], [":def", "wss_options", [":extend", ":ws_options", {
              useTLS: true
            }]], [":def", "sockjs_options", {
              hostNonTLS: config.httpHost + ":" + config.httpPort,
              hostTLS: config.httpHost + ":" + config.httpsPort,
              httpPath: config.httpPath
            }], [":def", "timeouts", {
              loop: true,
              timeout: 15000,
              timeoutLimit: 60000
            }], [":def", "ws_manager", [":transport_manager", {
              lives: 2,
              minPingDelay: 10000,
              maxPingDelay: config.activity_timeout
            }]], [":def", "streaming_manager", [":transport_manager", {
              lives: 2,
              minPingDelay: 10000,
              maxPingDelay: config.activity_timeout
            }]], [":def_transport", "ws", "ws", 3, ":ws_options", ":ws_manager"], [":def_transport", "wss", "ws", 3, ":wss_options", ":ws_manager"], [":def_transport", "sockjs", "sockjs", 1, ":sockjs_options"], [":def_transport", "xhr_streaming", "xhr_streaming", 1, ":sockjs_options", ":streaming_manager"], [":def_transport", "xdr_streaming", "xdr_streaming", 1, ":sockjs_options", ":streaming_manager"], [":def_transport", "xhr_polling", "xhr_polling", 1, ":sockjs_options"], [":def_transport", "xdr_polling", "xdr_polling", 1, ":sockjs_options"], [":def", "ws_loop", [":sequential", ":timeouts", ":ws"]], [":def", "wss_loop", [":sequential", ":timeouts", ":wss"]], [":def", "sockjs_loop", [":sequential", ":timeouts", ":sockjs"]], [":def", "streaming_loop", [":sequential", ":timeouts", [":if", [":is_supported", ":xhr_streaming"], ":xhr_streaming", ":xdr_streaming"]]], [":def", "polling_loop", [":sequential", ":timeouts", [":if", [":is_supported", ":xhr_polling"], ":xhr_polling", ":xdr_polling"]]], [":def", "http_loop", [":if", [":is_supported", ":streaming_loop"], [":best_connected_ever", ":streaming_loop", [":delayed", 4000, [":polling_loop"]]], [":polling_loop"]]], [":def", "http_fallback_loop", [":if", [":is_supported", ":http_loop"], [":http_loop"], [":sockjs_loop"]]], [":def", "strategy", [":cached", 1800000, [":first_connected", [":if", [":is_supported", ":ws"], wsStrategy, ":http_fallback_loop"]]]]];
          };

          exports.__esModule = true;
          exports["default"] = getDefaultStrategy;
          /***/
        },
        /* 28 */

        /***/
        function (module, exports, __webpack_require__) {
          var dependencies_1 = __webpack_require__(3);

          function default_1() {
            var self = this;
            self.timeline.info(self.buildTimelineMessage({
              transport: self.name + (self.options.useTLS ? "s" : "")
            }));

            if (self.hooks.isInitialized()) {
              self.changeState("initialized");
            } else if (self.hooks.file) {
              self.changeState("initializing");
              dependencies_1.Dependencies.load(self.hooks.file, {
                useTLS: self.options.useTLS
              }, function (error, callback) {
                if (self.hooks.isInitialized()) {
                  self.changeState("initialized");
                  callback(true);
                } else {
                  if (error) {
                    self.onError(error);
                  }

                  self.onClose();
                  callback(false);
                }
              });
            } else {
              self.onClose();
            }
          }

          exports.__esModule = true;
          exports["default"] = default_1;
          /***/
        },
        /* 29 */

        /***/
        function (module, exports, __webpack_require__) {
          var http_xdomain_request_1 = __webpack_require__(30);

          var http_1 = __webpack_require__(32);

          http_1["default"].createXDR = function (method, url) {
            return this.createRequest(http_xdomain_request_1["default"], method, url);
          };

          exports.__esModule = true;
          exports["default"] = http_1["default"];
          /***/
        },
        /* 30 */

        /***/
        function (module, exports, __webpack_require__) {
          var Errors = __webpack_require__(31);

          var hooks = {
            getRequest: function getRequest(socket) {
              var xdr = new window.XDomainRequest();

              xdr.ontimeout = function () {
                socket.emit("error", new Errors.RequestTimedOut());
                socket.close();
              };

              xdr.onerror = function (e) {
                socket.emit("error", e);
                socket.close();
              };

              xdr.onprogress = function () {
                if (xdr.responseText && xdr.responseText.length > 0) {
                  socket.onChunk(200, xdr.responseText);
                }
              };

              xdr.onload = function () {
                if (xdr.responseText && xdr.responseText.length > 0) {
                  socket.onChunk(200, xdr.responseText);
                }

                socket.emit("finished", 200);
                socket.close();
              };

              return xdr;
            },
            abortRequest: function abortRequest(xdr) {
              xdr.ontimeout = xdr.onerror = xdr.onprogress = xdr.onload = null;
              xdr.abort();
            }
          };
          exports.__esModule = true;
          exports["default"] = hooks;
          /***/
        },
        /* 31 */

        /***/
        function (module, exports) {
          var __extends = this && this.__extends || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };

          var BadEventName = function (_super) {
            __extends(BadEventName, _super);

            function BadEventName() {
              _super.apply(this, arguments);
            }

            return BadEventName;
          }(Error);

          exports.BadEventName = BadEventName;

          var RequestTimedOut = function (_super) {
            __extends(RequestTimedOut, _super);

            function RequestTimedOut() {
              _super.apply(this, arguments);
            }

            return RequestTimedOut;
          }(Error);

          exports.RequestTimedOut = RequestTimedOut;

          var TransportPriorityTooLow = function (_super) {
            __extends(TransportPriorityTooLow, _super);

            function TransportPriorityTooLow() {
              _super.apply(this, arguments);
            }

            return TransportPriorityTooLow;
          }(Error);

          exports.TransportPriorityTooLow = TransportPriorityTooLow;

          var TransportClosed = function (_super) {
            __extends(TransportClosed, _super);

            function TransportClosed() {
              _super.apply(this, arguments);
            }

            return TransportClosed;
          }(Error);

          exports.TransportClosed = TransportClosed;

          var UnsupportedFeature = function (_super) {
            __extends(UnsupportedFeature, _super);

            function UnsupportedFeature() {
              _super.apply(this, arguments);
            }

            return UnsupportedFeature;
          }(Error);

          exports.UnsupportedFeature = UnsupportedFeature;

          var UnsupportedTransport = function (_super) {
            __extends(UnsupportedTransport, _super);

            function UnsupportedTransport() {
              _super.apply(this, arguments);
            }

            return UnsupportedTransport;
          }(Error);

          exports.UnsupportedTransport = UnsupportedTransport;

          var UnsupportedStrategy = function (_super) {
            __extends(UnsupportedStrategy, _super);

            function UnsupportedStrategy() {
              _super.apply(this, arguments);
            }

            return UnsupportedStrategy;
          }(Error);

          exports.UnsupportedStrategy = UnsupportedStrategy;
          /***/
        },
        /* 32 */

        /***/
        function (module, exports, __webpack_require__) {
          var http_request_1 = __webpack_require__(33);

          var http_socket_1 = __webpack_require__(34);

          var http_streaming_socket_1 = __webpack_require__(36);

          var http_polling_socket_1 = __webpack_require__(37);

          var http_xhr_request_1 = __webpack_require__(38);

          var HTTP = {
            createStreamingSocket: function createStreamingSocket(url) {
              return this.createSocket(http_streaming_socket_1["default"], url);
            },
            createPollingSocket: function createPollingSocket(url) {
              return this.createSocket(http_polling_socket_1["default"], url);
            },
            createSocket: function createSocket(hooks, url) {
              return new http_socket_1["default"](hooks, url);
            },
            createXHR: function createXHR(method, url) {
              return this.createRequest(http_xhr_request_1["default"], method, url);
            },
            createRequest: function createRequest(hooks, method, url) {
              return new http_request_1["default"](hooks, method, url);
            }
          };
          exports.__esModule = true;
          exports["default"] = HTTP;
          /***/
        },
        /* 33 */

        /***/
        function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };

          var runtime_1 = __webpack_require__(2);

          var dispatcher_1 = __webpack_require__(24);

          var MAX_BUFFER_LENGTH = 256 * 1024;

          var HTTPRequest = function (_super) {
            __extends(HTTPRequest, _super);

            function HTTPRequest(hooks, method, url) {
              _super.call(this);

              this.hooks = hooks;
              this.method = method;
              this.url = url;
            }

            HTTPRequest.prototype.start = function (payload) {
              var _this = this;

              this.position = 0;
              this.xhr = this.hooks.getRequest(this);

              this.unloader = function () {
                _this.close();
              };

              runtime_1["default"].addUnloadListener(this.unloader);
              this.xhr.open(this.method, this.url, true);

              if (this.xhr.setRequestHeader) {
                this.xhr.setRequestHeader("Content-Type", "application/json");
              }

              this.xhr.send(payload);
            };

            HTTPRequest.prototype.close = function () {
              if (this.unloader) {
                runtime_1["default"].removeUnloadListener(this.unloader);
                this.unloader = null;
              }

              if (this.xhr) {
                this.hooks.abortRequest(this.xhr);
                this.xhr = null;
              }
            };

            HTTPRequest.prototype.onChunk = function (status, data) {
              while (true) {
                var chunk = this.advanceBuffer(data);

                if (chunk) {
                  this.emit("chunk", {
                    status: status,
                    data: chunk
                  });
                } else {
                  break;
                }
              }

              if (this.isBufferTooLong(data)) {
                this.emit("buffer_too_long");
              }
            };

            HTTPRequest.prototype.advanceBuffer = function (buffer) {
              var unreadData = buffer.slice(this.position);
              var endOfLinePosition = unreadData.indexOf("\n");

              if (endOfLinePosition !== -1) {
                this.position += endOfLinePosition + 1;
                return unreadData.slice(0, endOfLinePosition);
              } else {
                return null;
              }
            };

            HTTPRequest.prototype.isBufferTooLong = function (buffer) {
              return this.position === buffer.length && buffer.length > MAX_BUFFER_LENGTH;
            };

            return HTTPRequest;
          }(dispatcher_1["default"]);

          exports.__esModule = true;
          exports["default"] = HTTPRequest;
          /***/
        },
        /* 34 */

        /***/
        function (module, exports, __webpack_require__) {
          var state_1 = __webpack_require__(35);

          var util_1 = __webpack_require__(11);

          var runtime_1 = __webpack_require__(2);

          var autoIncrement = 1;

          var HTTPSocket = function () {
            function HTTPSocket(hooks, url) {
              this.hooks = hooks;
              this.session = randomNumber(1000) + "/" + randomString(8);
              this.location = getLocation(url);
              this.readyState = state_1["default"].CONNECTING;
              this.openStream();
            }

            HTTPSocket.prototype.send = function (payload) {
              return this.sendRaw(JSON.stringify([payload]));
            };

            HTTPSocket.prototype.ping = function () {
              this.hooks.sendHeartbeat(this);
            };

            HTTPSocket.prototype.close = function (code, reason) {
              this.onClose(code, reason, true);
            };

            HTTPSocket.prototype.sendRaw = function (payload) {
              if (this.readyState === state_1["default"].OPEN) {
                try {
                  runtime_1["default"].createSocketRequest("POST", getUniqueURL(getSendURL(this.location, this.session))).start(payload);
                  return true;
                } catch (e) {
                  return false;
                }
              } else {
                return false;
              }
            };

            HTTPSocket.prototype.reconnect = function () {
              this.closeStream();
              this.openStream();
            };

            HTTPSocket.prototype.onClose = function (code, reason, wasClean) {
              this.closeStream();
              this.readyState = state_1["default"].CLOSED;

              if (this.onclose) {
                this.onclose({
                  code: code,
                  reason: reason,
                  wasClean: wasClean
                });
              }
            };

            HTTPSocket.prototype.onChunk = function (chunk) {
              if (chunk.status !== 200) {
                return;
              }

              if (this.readyState === state_1["default"].OPEN) {
                this.onActivity();
              }

              var payload;
              var type = chunk.data.slice(0, 1);

              switch (type) {
                case 'o':
                  payload = JSON.parse(chunk.data.slice(1) || '{}');
                  this.onOpen(payload);
                  break;

                case 'a':
                  payload = JSON.parse(chunk.data.slice(1) || '[]');

                  for (var i = 0; i < payload.length; i++) {
                    this.onEvent(payload[i]);
                  }

                  break;

                case 'm':
                  payload = JSON.parse(chunk.data.slice(1) || 'null');
                  this.onEvent(payload);
                  break;

                case 'h':
                  this.hooks.onHeartbeat(this);
                  break;

                case 'c':
                  payload = JSON.parse(chunk.data.slice(1) || '[]');
                  this.onClose(payload[0], payload[1], true);
                  break;
              }
            };

            HTTPSocket.prototype.onOpen = function (options) {
              if (this.readyState === state_1["default"].CONNECTING) {
                if (options && options.hostname) {
                  this.location.base = replaceHost(this.location.base, options.hostname);
                }

                this.readyState = state_1["default"].OPEN;

                if (this.onopen) {
                  this.onopen();
                }
              } else {
                this.onClose(1006, "Server lost session", true);
              }
            };

            HTTPSocket.prototype.onEvent = function (event) {
              if (this.readyState === state_1["default"].OPEN && this.onmessage) {
                this.onmessage({
                  data: event
                });
              }
            };

            HTTPSocket.prototype.onActivity = function () {
              if (this.onactivity) {
                this.onactivity();
              }
            };

            HTTPSocket.prototype.onError = function (error) {
              if (this.onerror) {
                this.onerror(error);
              }
            };

            HTTPSocket.prototype.openStream = function () {
              var _this = this;

              this.stream = runtime_1["default"].createSocketRequest("POST", getUniqueURL(this.hooks.getReceiveURL(this.location, this.session)));
              this.stream.bind("chunk", function (chunk) {
                _this.onChunk(chunk);
              });
              this.stream.bind("finished", function (status) {
                _this.hooks.onFinished(_this, status);
              });
              this.stream.bind("buffer_too_long", function () {
                _this.reconnect();
              });

              try {
                this.stream.start();
              } catch (error) {
                util_1["default"].defer(function () {
                  _this.onError(error);

                  _this.onClose(1006, "Could not start streaming", false);
                });
              }
            };

            HTTPSocket.prototype.closeStream = function () {
              if (this.stream) {
                this.stream.unbind_all();
                this.stream.close();
                this.stream = null;
              }
            };

            return HTTPSocket;
          }();

          function getLocation(url) {
            var parts = /([^\?]*)\/*(\??.*)/.exec(url);
            return {
              base: parts[1],
              queryString: parts[2]
            };
          }

          function getSendURL(url, session) {
            return url.base + "/" + session + "/xhr_send";
          }

          function getUniqueURL(url) {
            var separator = url.indexOf('?') === -1 ? "?" : "&";
            return url + separator + "t=" + +new Date() + "&n=" + autoIncrement++;
          }

          function replaceHost(url, hostname) {
            var urlParts = /(https?:\/\/)([^\/:]+)((\/|:)?.*)/.exec(url);
            return urlParts[1] + hostname + urlParts[3];
          }

          function randomNumber(max) {
            return Math.floor(Math.random() * max);
          }

          function randomString(length) {
            var result = [];

            for (var i = 0; i < length; i++) {
              result.push(randomNumber(32).toString(32));
            }

            return result.join('');
          }

          exports.__esModule = true;
          exports["default"] = HTTPSocket;
          /***/
        },
        /* 35 */

        /***/
        function (module, exports) {
          var State;

          (function (State) {
            State[State["CONNECTING"] = 0] = "CONNECTING";
            State[State["OPEN"] = 1] = "OPEN";
            State[State["CLOSED"] = 3] = "CLOSED";
          })(State || (State = {}));

          exports.__esModule = true;
          exports["default"] = State;
          /***/
        },
        /* 36 */

        /***/
        function (module, exports) {
          var hooks = {
            getReceiveURL: function getReceiveURL(url, session) {
              return url.base + "/" + session + "/xhr_streaming" + url.queryString;
            },
            onHeartbeat: function onHeartbeat(socket) {
              socket.sendRaw("[]");
            },
            sendHeartbeat: function sendHeartbeat(socket) {
              socket.sendRaw("[]");
            },
            onFinished: function onFinished(socket, status) {
              socket.onClose(1006, "Connection interrupted (" + status + ")", false);
            }
          };
          exports.__esModule = true;
          exports["default"] = hooks;
          /***/
        },
        /* 37 */

        /***/
        function (module, exports) {
          var hooks = {
            getReceiveURL: function getReceiveURL(url, session) {
              return url.base + "/" + session + "/xhr" + url.queryString;
            },
            onHeartbeat: function onHeartbeat() {},
            sendHeartbeat: function sendHeartbeat(socket) {
              socket.sendRaw("[]");
            },
            onFinished: function onFinished(socket, status) {
              if (status === 200) {
                socket.reconnect();
              } else {
                socket.onClose(1006, "Connection interrupted (" + status + ")", false);
              }
            }
          };
          exports.__esModule = true;
          exports["default"] = hooks;
          /***/
        },
        /* 38 */

        /***/
        function (module, exports, __webpack_require__) {
          var runtime_1 = __webpack_require__(2);

          var hooks = {
            getRequest: function getRequest(socket) {
              var Constructor = runtime_1["default"].getXHRAPI();
              var xhr = new Constructor();

              xhr.onreadystatechange = xhr.onprogress = function () {
                switch (xhr.readyState) {
                  case 3:
                    if (xhr.responseText && xhr.responseText.length > 0) {
                      socket.onChunk(xhr.status, xhr.responseText);
                    }

                    break;

                  case 4:
                    if (xhr.responseText && xhr.responseText.length > 0) {
                      socket.onChunk(xhr.status, xhr.responseText);
                    }

                    socket.emit("finished", xhr.status);
                    socket.close();
                    break;
                }
              };

              return xhr;
            },
            abortRequest: function abortRequest(xhr) {
              xhr.onreadystatechange = null;
              xhr.abort();
            }
          };
          exports.__esModule = true;
          exports["default"] = hooks;
          /***/
        },
        /* 39 */

        /***/
        function (module, exports, __webpack_require__) {
          var Collections = __webpack_require__(9);

          var util_1 = __webpack_require__(11);

          var level_1 = __webpack_require__(40);

          var Timeline = function () {
            function Timeline(key, session, options) {
              this.key = key;
              this.session = session;
              this.events = [];
              this.options = options || {};
              this.sent = 0;
              this.uniqueID = 0;
            }

            Timeline.prototype.log = function (level, event) {
              if (level <= this.options.level) {
                this.events.push(Collections.extend({}, event, {
                  timestamp: util_1["default"].now()
                }));

                if (this.options.limit && this.events.length > this.options.limit) {
                  this.events.shift();
                }
              }
            };

            Timeline.prototype.error = function (event) {
              this.log(level_1["default"].ERROR, event);
            };

            Timeline.prototype.info = function (event) {
              this.log(level_1["default"].INFO, event);
            };

            Timeline.prototype.debug = function (event) {
              this.log(level_1["default"].DEBUG, event);
            };

            Timeline.prototype.isEmpty = function () {
              return this.events.length === 0;
            };

            Timeline.prototype.send = function (sendfn, callback) {
              var _this = this;

              var data = Collections.extend({
                session: this.session,
                bundle: this.sent + 1,
                key: this.key,
                lib: "js",
                version: this.options.version,
                cluster: this.options.cluster,
                features: this.options.features,
                timeline: this.events
              }, this.options.params);
              this.events = [];
              sendfn(data, function (error, result) {
                if (!error) {
                  _this.sent++;
                }

                if (callback) {
                  callback(error, result);
                }
              });
              return true;
            };

            Timeline.prototype.generateUniqueID = function () {
              this.uniqueID++;
              return this.uniqueID;
            };

            return Timeline;
          }();

          exports.__esModule = true;
          exports["default"] = Timeline;
          /***/
        },
        /* 40 */

        /***/
        function (module, exports) {
          var TimelineLevel;

          (function (TimelineLevel) {
            TimelineLevel[TimelineLevel["ERROR"] = 3] = "ERROR";
            TimelineLevel[TimelineLevel["INFO"] = 6] = "INFO";
            TimelineLevel[TimelineLevel["DEBUG"] = 7] = "DEBUG";
          })(TimelineLevel || (TimelineLevel = {}));

          exports.__esModule = true;
          exports["default"] = TimelineLevel;
          /***/
        },
        /* 41 */

        /***/
        function (module, exports, __webpack_require__) {
          var Collections = __webpack_require__(9);

          var util_1 = __webpack_require__(11);

          var transport_manager_1 = __webpack_require__(42);

          var Errors = __webpack_require__(31);

          var transport_strategy_1 = __webpack_require__(64);

          var sequential_strategy_1 = __webpack_require__(65);

          var best_connected_ever_strategy_1 = __webpack_require__(66);

          var cached_strategy_1 = __webpack_require__(67);

          var delayed_strategy_1 = __webpack_require__(68);

          var if_strategy_1 = __webpack_require__(69);

          var first_connected_strategy_1 = __webpack_require__(70);

          var runtime_1 = __webpack_require__(2);

          var Transports = runtime_1["default"].Transports;

          exports.build = function (scheme, options) {
            var context = Collections.extend({}, globalContext, options);
            return evaluate(scheme, context)[1].strategy;
          };

          var UnsupportedStrategy = {
            isSupported: function isSupported() {
              return false;
            },
            connect: function connect(_, callback) {
              var deferred = util_1["default"].defer(function () {
                callback(new Errors.UnsupportedStrategy());
              });
              return {
                abort: function abort() {
                  deferred.ensureAborted();
                },
                forceMinPriority: function forceMinPriority() {}
              };
            }
          };

          function returnWithOriginalContext(f) {
            return function (context) {
              return [f.apply(this, arguments), context];
            };
          }

          var globalContext = {
            extend: function extend(context, first, second) {
              return [Collections.extend({}, first, second), context];
            },
            def: function def(context, name, value) {
              if (context[name] !== undefined) {
                throw "Redefining symbol " + name;
              }

              context[name] = value;
              return [undefined, context];
            },
            def_transport: function def_transport(context, name, type, priority, options, manager) {
              var transportClass = Transports[type];

              if (!transportClass) {
                throw new Errors.UnsupportedTransport(type);
              }

              var enabled = (!context.enabledTransports || Collections.arrayIndexOf(context.enabledTransports, name) !== -1) && (!context.disabledTransports || Collections.arrayIndexOf(context.disabledTransports, name) === -1);
              var transport;

              if (enabled) {
                transport = new transport_strategy_1["default"](name, priority, manager ? manager.getAssistant(transportClass) : transportClass, Collections.extend({
                  key: context.key,
                  useTLS: context.useTLS,
                  timeline: context.timeline,
                  ignoreNullOrigin: context.ignoreNullOrigin
                }, options));
              } else {
                transport = UnsupportedStrategy;
              }

              var newContext = context.def(context, name, transport)[1];
              newContext.Transports = context.Transports || {};
              newContext.Transports[name] = transport;
              return [undefined, newContext];
            },
            transport_manager: returnWithOriginalContext(function (_, options) {
              return new transport_manager_1["default"](options);
            }),
            sequential: returnWithOriginalContext(function (_, options) {
              var strategies = Array.prototype.slice.call(arguments, 2);
              return new sequential_strategy_1["default"](strategies, options);
            }),
            cached: returnWithOriginalContext(function (context, ttl, strategy) {
              return new cached_strategy_1["default"](strategy, context.Transports, {
                ttl: ttl,
                timeline: context.timeline,
                useTLS: context.useTLS
              });
            }),
            first_connected: returnWithOriginalContext(function (_, strategy) {
              return new first_connected_strategy_1["default"](strategy);
            }),
            best_connected_ever: returnWithOriginalContext(function () {
              var strategies = Array.prototype.slice.call(arguments, 1);
              return new best_connected_ever_strategy_1["default"](strategies);
            }),
            delayed: returnWithOriginalContext(function (_, delay, strategy) {
              return new delayed_strategy_1["default"](strategy, {
                delay: delay
              });
            }),
            "if": returnWithOriginalContext(function (_, test, trueBranch, falseBranch) {
              return new if_strategy_1["default"](test, trueBranch, falseBranch);
            }),
            is_supported: returnWithOriginalContext(function (_, strategy) {
              return function () {
                return strategy.isSupported();
              };
            })
          };

          function isSymbol(expression) {
            return typeof expression === "string" && expression.charAt(0) === ":";
          }

          function getSymbolValue(expression, context) {
            return context[expression.slice(1)];
          }

          function evaluateListOfExpressions(expressions, context) {
            if (expressions.length === 0) {
              return [[], context];
            }

            var head = evaluate(expressions[0], context);
            var tail = evaluateListOfExpressions(expressions.slice(1), head[1]);
            return [[head[0]].concat(tail[0]), tail[1]];
          }

          function evaluateString(expression, context) {
            if (!isSymbol(expression)) {
              return [expression, context];
            }

            var value = getSymbolValue(expression, context);

            if (value === undefined) {
              throw "Undefined symbol " + expression;
            }

            return [value, context];
          }

          function evaluateArray(expression, context) {
            if (isSymbol(expression[0])) {
              var f = getSymbolValue(expression[0], context);

              if (expression.length > 1) {
                if (typeof f !== "function") {
                  throw "Calling non-function " + expression[0];
                }

                var args = [Collections.extend({}, context)].concat(Collections.map(expression.slice(1), function (arg) {
                  return evaluate(arg, Collections.extend({}, context))[0];
                }));
                return f.apply(this, args);
              } else {
                return [f, context];
              }
            } else {
              return evaluateListOfExpressions(expression, context);
            }
          }

          function evaluate(expression, context) {
            if (typeof expression === "string") {
              return evaluateString(expression, context);
            } else if (_typeof(expression) === "object") {
              if (expression instanceof Array && expression.length > 0) {
                return evaluateArray(expression, context);
              }
            }

            return [expression, context];
          }
          /***/

        },
        /* 42 */

        /***/
        function (module, exports, __webpack_require__) {
          var factory_1 = __webpack_require__(43);

          var TransportManager = function () {
            function TransportManager(options) {
              this.options = options || {};
              this.livesLeft = this.options.lives || Infinity;
            }

            TransportManager.prototype.getAssistant = function (transport) {
              return factory_1["default"].createAssistantToTheTransportManager(this, transport, {
                minPingDelay: this.options.minPingDelay,
                maxPingDelay: this.options.maxPingDelay
              });
            };

            TransportManager.prototype.isAlive = function () {
              return this.livesLeft > 0;
            };

            TransportManager.prototype.reportDeath = function () {
              this.livesLeft -= 1;
            };

            return TransportManager;
          }();

          exports.__esModule = true;
          exports["default"] = TransportManager;
          /***/
        },
        /* 43 */

        /***/
        function (module, exports, __webpack_require__) {
          var assistant_to_the_transport_manager_1 = __webpack_require__(44);

          var handshake_1 = __webpack_require__(45);

          var pusher_authorizer_1 = __webpack_require__(48);

          var timeline_sender_1 = __webpack_require__(49);

          var presence_channel_1 = __webpack_require__(50);

          var private_channel_1 = __webpack_require__(51);

          var encrypted_channel_1 = __webpack_require__(54);

          var channel_1 = __webpack_require__(52);

          var connection_manager_1 = __webpack_require__(62);

          var channels_1 = __webpack_require__(63);

          var Factory = {
            createChannels: function createChannels() {
              return new channels_1["default"]();
            },
            createConnectionManager: function createConnectionManager(key, options) {
              return new connection_manager_1["default"](key, options);
            },
            createChannel: function createChannel(name, pusher) {
              return new channel_1["default"](name, pusher);
            },
            createPrivateChannel: function createPrivateChannel(name, pusher) {
              return new private_channel_1["default"](name, pusher);
            },
            createPresenceChannel: function createPresenceChannel(name, pusher) {
              return new presence_channel_1["default"](name, pusher);
            },
            createEncryptedChannel: function createEncryptedChannel(name, pusher) {
              return new encrypted_channel_1["default"](name, pusher);
            },
            createTimelineSender: function createTimelineSender(timeline, options) {
              return new timeline_sender_1["default"](timeline, options);
            },
            createAuthorizer: function createAuthorizer(channel, options) {
              if (options.authorizer) {
                return options.authorizer(channel, options);
              }

              return new pusher_authorizer_1["default"](channel, options);
            },
            createHandshake: function createHandshake(transport, callback) {
              return new handshake_1["default"](transport, callback);
            },
            createAssistantToTheTransportManager: function createAssistantToTheTransportManager(manager, transport, options) {
              return new assistant_to_the_transport_manager_1["default"](manager, transport, options);
            }
          };
          exports.__esModule = true;
          exports["default"] = Factory;
          /***/
        },
        /* 44 */

        /***/
        function (module, exports, __webpack_require__) {
          var util_1 = __webpack_require__(11);

          var Collections = __webpack_require__(9);

          var AssistantToTheTransportManager = function () {
            function AssistantToTheTransportManager(manager, transport, options) {
              this.manager = manager;
              this.transport = transport;
              this.minPingDelay = options.minPingDelay;
              this.maxPingDelay = options.maxPingDelay;
              this.pingDelay = undefined;
            }

            AssistantToTheTransportManager.prototype.createConnection = function (name, priority, key, options) {
              var _this = this;

              options = Collections.extend({}, options, {
                activityTimeout: this.pingDelay
              });
              var connection = this.transport.createConnection(name, priority, key, options);
              var openTimestamp = null;

              var onOpen = function onOpen() {
                connection.unbind("open", onOpen);
                connection.bind("closed", onClosed);
                openTimestamp = util_1["default"].now();
              };

              var onClosed = function onClosed(closeEvent) {
                connection.unbind("closed", onClosed);

                if (closeEvent.code === 1002 || closeEvent.code === 1003) {
                  _this.manager.reportDeath();
                } else if (!closeEvent.wasClean && openTimestamp) {
                  var lifespan = util_1["default"].now() - openTimestamp;

                  if (lifespan < 2 * _this.maxPingDelay) {
                    _this.manager.reportDeath();

                    _this.pingDelay = Math.max(lifespan / 2, _this.minPingDelay);
                  }
                }
              };

              connection.bind("open", onOpen);
              return connection;
            };

            AssistantToTheTransportManager.prototype.isSupported = function (environment) {
              return this.manager.isAlive() && this.transport.isSupported(environment);
            };

            return AssistantToTheTransportManager;
          }();

          exports.__esModule = true;
          exports["default"] = AssistantToTheTransportManager;
          /***/
        },
        /* 45 */

        /***/
        function (module, exports, __webpack_require__) {
          var Collections = __webpack_require__(9);

          var Protocol = __webpack_require__(46);

          var connection_1 = __webpack_require__(47);

          var Handshake = function () {
            function Handshake(transport, callback) {
              this.transport = transport;
              this.callback = callback;
              this.bindListeners();
            }

            Handshake.prototype.close = function () {
              this.unbindListeners();
              this.transport.close();
            };

            Handshake.prototype.bindListeners = function () {
              var _this = this;

              this.onMessage = function (m) {
                _this.unbindListeners();

                var result;

                try {
                  result = Protocol.processHandshake(m);
                } catch (e) {
                  _this.finish("error", {
                    error: e
                  });

                  _this.transport.close();

                  return;
                }

                if (result.action === "connected") {
                  _this.finish("connected", {
                    connection: new connection_1["default"](result.id, _this.transport),
                    activityTimeout: result.activityTimeout
                  });
                } else {
                  _this.finish(result.action, {
                    error: result.error
                  });

                  _this.transport.close();
                }
              };

              this.onClosed = function (closeEvent) {
                _this.unbindListeners();

                var action = Protocol.getCloseAction(closeEvent) || "backoff";
                var error = Protocol.getCloseError(closeEvent);

                _this.finish(action, {
                  error: error
                });
              };

              this.transport.bind("message", this.onMessage);
              this.transport.bind("closed", this.onClosed);
            };

            Handshake.prototype.unbindListeners = function () {
              this.transport.unbind("message", this.onMessage);
              this.transport.unbind("closed", this.onClosed);
            };

            Handshake.prototype.finish = function (action, params) {
              this.callback(Collections.extend({
                transport: this.transport,
                action: action
              }, params));
            };

            return Handshake;
          }();

          exports.__esModule = true;
          exports["default"] = Handshake;
          /***/
        },
        /* 46 */

        /***/
        function (module, exports) {
          exports.decodeMessage = function (message) {
            try {
              var params = JSON.parse(message.data);

              if (typeof params.data === 'string') {
                try {
                  params.data = JSON.parse(params.data);
                } catch (e) {
                  if (!(e instanceof SyntaxError)) {
                    throw e;
                  }
                }
              }

              return params;
            } catch (e) {
              throw {
                type: 'MessageParseError',
                error: e,
                data: message.data
              };
            }
          };

          exports.encodeMessage = function (message) {
            return JSON.stringify(message);
          };

          exports.processHandshake = function (message) {
            message = exports.decodeMessage(message);

            if (message.event === "pusher:connection_established") {
              if (!message.data.activity_timeout) {
                throw "No activity timeout specified in handshake";
              }

              return {
                action: "connected",
                id: message.data.socket_id,
                activityTimeout: message.data.activity_timeout * 1000
              };
            } else if (message.event === "pusher:error") {
              return {
                action: this.getCloseAction(message.data),
                error: this.getCloseError(message.data)
              };
            } else {
              throw "Invalid handshake";
            }
          };

          exports.getCloseAction = function (closeEvent) {
            if (closeEvent.code < 4000) {
              if (closeEvent.code >= 1002 && closeEvent.code <= 1004) {
                return "backoff";
              } else {
                return null;
              }
            } else if (closeEvent.code === 4000) {
              return "tls_only";
            } else if (closeEvent.code < 4100) {
              return "refused";
            } else if (closeEvent.code < 4200) {
              return "backoff";
            } else if (closeEvent.code < 4300) {
              return "retry";
            } else {
              return "refused";
            }
          };

          exports.getCloseError = function (closeEvent) {
            if (closeEvent.code !== 1000 && closeEvent.code !== 1001) {
              return {
                type: 'PusherError',
                data: {
                  code: closeEvent.code,
                  message: closeEvent.reason || closeEvent.message
                }
              };
            } else {
              return null;
            }
          };
          /***/

        },
        /* 47 */

        /***/
        function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };

          var Collections = __webpack_require__(9);

          var dispatcher_1 = __webpack_require__(24);

          var Protocol = __webpack_require__(46);

          var logger_1 = __webpack_require__(8);

          var Connection = function (_super) {
            __extends(Connection, _super);

            function Connection(id, transport) {
              _super.call(this);

              this.id = id;
              this.transport = transport;
              this.activityTimeout = transport.activityTimeout;
              this.bindListeners();
            }

            Connection.prototype.handlesActivityChecks = function () {
              return this.transport.handlesActivityChecks();
            };

            Connection.prototype.send = function (data) {
              return this.transport.send(data);
            };

            Connection.prototype.send_event = function (name, data, channel) {
              var message = {
                event: name,
                data: data
              };

              if (channel) {
                message.channel = channel;
              }

              logger_1["default"].debug('Event sent', message);
              return this.send(Protocol.encodeMessage(message));
            };

            Connection.prototype.ping = function () {
              if (this.transport.supportsPing()) {
                this.transport.ping();
              } else {
                this.send_event('pusher:ping', {});
              }
            };

            Connection.prototype.close = function () {
              this.transport.close();
            };

            Connection.prototype.bindListeners = function () {
              var _this = this;

              var listeners = {
                message: function message(m) {
                  var message;

                  try {
                    message = Protocol.decodeMessage(m);
                  } catch (e) {
                    _this.emit('error', {
                      type: 'MessageParseError',
                      error: e,
                      data: m.data
                    });
                  }

                  if (message !== undefined) {
                    logger_1["default"].debug('Event recd', message);

                    switch (message.event) {
                      case 'pusher:error':
                        _this.emit('error', {
                          type: 'PusherError',
                          data: message.data
                        });

                        break;

                      case 'pusher:ping':
                        _this.emit("ping");

                        break;

                      case 'pusher:pong':
                        _this.emit("pong");

                        break;
                    }

                    _this.emit('message', message);
                  }
                },
                activity: function activity() {
                  _this.emit("activity");
                },
                error: function error(_error) {
                  _this.emit("error", {
                    type: "WebSocketError",
                    error: _error
                  });
                },
                closed: function closed(closeEvent) {
                  unbindListeners();

                  if (closeEvent && closeEvent.code) {
                    _this.handleCloseEvent(closeEvent);
                  }

                  _this.transport = null;

                  _this.emit("closed");
                }
              };

              var unbindListeners = function unbindListeners() {
                Collections.objectApply(listeners, function (listener, event) {
                  _this.transport.unbind(event, listener);
                });
              };

              Collections.objectApply(listeners, function (listener, event) {
                _this.transport.bind(event, listener);
              });
            };

            Connection.prototype.handleCloseEvent = function (closeEvent) {
              var action = Protocol.getCloseAction(closeEvent);
              var error = Protocol.getCloseError(closeEvent);

              if (error) {
                this.emit('error', error);
              }

              if (action) {
                this.emit(action, {
                  action: action,
                  error: error
                });
              }
            };

            return Connection;
          }(dispatcher_1["default"]);

          exports.__esModule = true;
          exports["default"] = Connection;
          /***/
        },
        /* 48 */

        /***/
        function (module, exports, __webpack_require__) {
          var runtime_1 = __webpack_require__(2);

          var PusherAuthorizer = function () {
            function PusherAuthorizer(channel, options) {
              this.channel = channel;
              var authTransport = options.authTransport;

              if (typeof runtime_1["default"].getAuthorizers()[authTransport] === "undefined") {
                throw "'" + authTransport + "' is not a recognized auth transport";
              }

              this.type = authTransport;
              this.options = options;
              this.authOptions = (options || {}).auth || {};
            }

            PusherAuthorizer.prototype.composeQuery = function (socketId) {
              var query = 'socket_id=' + encodeURIComponent(socketId) + '&channel_name=' + encodeURIComponent(this.channel.name);

              for (var i in this.authOptions.params) {
                query += "&" + encodeURIComponent(i) + "=" + encodeURIComponent(this.authOptions.params[i]);
              }

              return query;
            };

            PusherAuthorizer.prototype.authorize = function (socketId, callback) {
              PusherAuthorizer.authorizers = PusherAuthorizer.authorizers || runtime_1["default"].getAuthorizers();
              return PusherAuthorizer.authorizers[this.type].call(this, runtime_1["default"], socketId, callback);
            };

            return PusherAuthorizer;
          }();

          exports.__esModule = true;
          exports["default"] = PusherAuthorizer;
          /***/
        },
        /* 49 */

        /***/
        function (module, exports, __webpack_require__) {
          var runtime_1 = __webpack_require__(2);

          var TimelineSender = function () {
            function TimelineSender(timeline, options) {
              this.timeline = timeline;
              this.options = options || {};
            }

            TimelineSender.prototype.send = function (useTLS, callback) {
              if (this.timeline.isEmpty()) {
                return;
              }

              this.timeline.send(runtime_1["default"].TimelineTransport.getAgent(this, useTLS), callback);
            };

            return TimelineSender;
          }();

          exports.__esModule = true;
          exports["default"] = TimelineSender;
          /***/
        },
        /* 50 */

        /***/
        function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };

          var private_channel_1 = __webpack_require__(51);

          var logger_1 = __webpack_require__(8);

          var members_1 = __webpack_require__(53);

          var url_store_1 = __webpack_require__(14);

          var PresenceChannel = function (_super) {
            __extends(PresenceChannel, _super);

            function PresenceChannel(name, pusher) {
              _super.call(this, name, pusher);

              this.members = new members_1["default"]();
            }

            PresenceChannel.prototype.authorize = function (socketId, callback) {
              var _this = this;

              _super.prototype.authorize.call(this, socketId, function (error, authData) {
                if (!error) {
                  if (authData.channel_data === undefined) {
                    var suffix = url_store_1["default"].buildLogSuffix("authenticationEndpoint");
                    logger_1["default"].warn("Invalid auth response for channel '" + _this.name + "'," + ("expected 'channel_data' field. " + suffix));
                    callback("Invalid auth response");
                    return;
                  }

                  var channelData = JSON.parse(authData.channel_data);

                  _this.members.setMyID(channelData.user_id);
                }

                callback(error, authData);
              });
            };

            PresenceChannel.prototype.handleEvent = function (event, data) {
              switch (event) {
                case "pusher_internal:subscription_succeeded":
                  this.subscriptionPending = false;
                  this.subscribed = true;

                  if (this.subscriptionCancelled) {
                    this.pusher.unsubscribe(this.name);
                  } else {
                    this.members.onSubscription(data);
                    this.emit("pusher:subscription_succeeded", this.members);
                  }

                  break;

                case "pusher_internal:member_added":
                  var addedMember = this.members.addMember(data);
                  this.emit('pusher:member_added', addedMember);
                  break;

                case "pusher_internal:member_removed":
                  var removedMember = this.members.removeMember(data);

                  if (removedMember) {
                    this.emit('pusher:member_removed', removedMember);
                  }

                  break;

                default:
                  private_channel_1["default"].prototype.handleEvent.call(this, event, data);
              }
            };

            PresenceChannel.prototype.disconnect = function () {
              this.members.reset();

              _super.prototype.disconnect.call(this);
            };

            return PresenceChannel;
          }(private_channel_1["default"]);

          exports.__esModule = true;
          exports["default"] = PresenceChannel;
          /***/
        },
        /* 51 */

        /***/
        function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };

          var factory_1 = __webpack_require__(43);

          var channel_1 = __webpack_require__(52);

          var PrivateChannel = function (_super) {
            __extends(PrivateChannel, _super);

            function PrivateChannel() {
              _super.apply(this, arguments);
            }

            PrivateChannel.prototype.authorize = function (socketId, callback) {
              var authorizer = factory_1["default"].createAuthorizer(this, this.pusher.config);
              return authorizer.authorize(socketId, callback);
            };

            return PrivateChannel;
          }(channel_1["default"]);

          exports.__esModule = true;
          exports["default"] = PrivateChannel;
          /***/
        },
        /* 52 */

        /***/
        function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };

          var dispatcher_1 = __webpack_require__(24);

          var Errors = __webpack_require__(31);

          var logger_1 = __webpack_require__(8);

          var Channel = function (_super) {
            __extends(Channel, _super);

            function Channel(name, pusher) {
              _super.call(this, function (event, data) {
                logger_1["default"].debug('No callbacks on ' + name + ' for ' + event);
              });

              this.name = name;
              this.pusher = pusher;
              this.subscribed = false;
              this.subscriptionPending = false;
              this.subscriptionCancelled = false;
            }

            Channel.prototype.authorize = function (socketId, callback) {
              return callback(false, {});
            };

            Channel.prototype.trigger = function (event, data) {
              if (event.indexOf("client-") !== 0) {
                throw new Errors.BadEventName("Event '" + event + "' does not start with 'client-'");
              }

              return this.pusher.send_event(event, data, this.name);
            };

            Channel.prototype.disconnect = function () {
              this.subscribed = false;
              this.subscriptionPending = false;
            };

            Channel.prototype.handleEvent = function (event, data) {
              if (event.indexOf("pusher_internal:") === 0) {
                if (event === "pusher_internal:subscription_succeeded") {
                  this.subscriptionPending = false;
                  this.subscribed = true;

                  if (this.subscriptionCancelled) {
                    this.pusher.unsubscribe(this.name);
                  } else {
                    this.emit("pusher:subscription_succeeded", data);
                  }
                }
              } else {
                this.emit(event, data);
              }
            };

            Channel.prototype.subscribe = function () {
              var _this = this;

              if (this.subscribed) {
                return;
              }

              this.subscriptionPending = true;
              this.subscriptionCancelled = false;
              this.authorize(this.pusher.connection.socket_id, function (error, data) {
                if (error) {
                  _this.handleEvent('pusher:subscription_error', data);
                } else {
                  _this.pusher.send_event('pusher:subscribe', {
                    auth: data.auth,
                    channel_data: data.channel_data,
                    channel: _this.name
                  });
                }
              });
            };

            Channel.prototype.unsubscribe = function () {
              this.subscribed = false;
              this.pusher.send_event('pusher:unsubscribe', {
                channel: this.name
              });
            };

            Channel.prototype.cancelSubscription = function () {
              this.subscriptionCancelled = true;
            };

            Channel.prototype.reinstateSubscription = function () {
              this.subscriptionCancelled = false;
            };

            return Channel;
          }(dispatcher_1["default"]);

          exports.__esModule = true;
          exports["default"] = Channel;
          /***/
        },
        /* 53 */

        /***/
        function (module, exports, __webpack_require__) {
          var Collections = __webpack_require__(9);

          var Members = function () {
            function Members() {
              this.reset();
            }

            Members.prototype.get = function (id) {
              if (Object.prototype.hasOwnProperty.call(this.members, id)) {
                return {
                  id: id,
                  info: this.members[id]
                };
              } else {
                return null;
              }
            };

            Members.prototype.each = function (callback) {
              var _this = this;

              Collections.objectApply(this.members, function (member, id) {
                callback(_this.get(id));
              });
            };

            Members.prototype.setMyID = function (id) {
              this.myID = id;
            };

            Members.prototype.onSubscription = function (subscriptionData) {
              this.members = subscriptionData.presence.hash;
              this.count = subscriptionData.presence.count;
              this.me = this.get(this.myID);
            };

            Members.prototype.addMember = function (memberData) {
              if (this.get(memberData.user_id) === null) {
                this.count++;
              }

              this.members[memberData.user_id] = memberData.user_info;
              return this.get(memberData.user_id);
            };

            Members.prototype.removeMember = function (memberData) {
              var member = this.get(memberData.user_id);

              if (member) {
                delete this.members[memberData.user_id];
                this.count--;
              }

              return member;
            };

            Members.prototype.reset = function () {
              this.members = {};
              this.count = 0;
              this.myID = null;
              this.me = null;
            };

            return Members;
          }();

          exports.__esModule = true;
          exports["default"] = Members;
          /***/
        },
        /* 54 */

        /***/
        function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };

          var private_channel_1 = __webpack_require__(51);

          var Errors = __webpack_require__(31);

          var logger_1 = __webpack_require__(8);

          var tweetnacl_1 = __webpack_require__(55);

          var tweetnacl_util_1 = __webpack_require__(57);

          var EncryptedChannel = function (_super) {
            __extends(EncryptedChannel, _super);

            function EncryptedChannel() {
              _super.apply(this, arguments);

              this.key = null;
            }

            EncryptedChannel.prototype.authorize = function (socketId, callback) {
              var _this = this;

              _super.prototype.authorize.call(this, socketId, function (error, authData) {
                if (error) {
                  callback(true, authData);
                  return;
                }

                var sharedSecret = authData["shared_secret"];

                if (!sharedSecret) {
                  var errorMsg = "No shared_secret key in auth payload for encrypted channel: " + _this.name;
                  callback(true, errorMsg);
                  logger_1["default"].warn("Error: " + errorMsg);
                  return;
                }

                _this.key = tweetnacl_util_1.decodeBase64(sharedSecret);
                delete authData["shared_secret"];
                callback(false, authData);
              });
            };

            EncryptedChannel.prototype.trigger = function (event, data) {
              throw new Errors.UnsupportedFeature('Client events are not currently supported for encrypted channels');
            };

            EncryptedChannel.prototype.handleEvent = function (event, data) {
              if (event.indexOf("pusher_internal:") === 0 || event.indexOf("pusher:") === 0) {
                _super.prototype.handleEvent.call(this, event, data);

                return;
              }

              this.handleEncryptedEvent(event, data);
            };

            EncryptedChannel.prototype.handleEncryptedEvent = function (event, data) {
              var _this = this;

              if (!this.key) {
                logger_1["default"].debug('Received encrypted event before key has been retrieved from the authEndpoint');
                return;
              }

              if (!data.ciphertext || !data.nonce) {
                logger_1["default"].warn('Unexpected format for encrypted event, expected object with `ciphertext` and `nonce` fields, got: ' + data);
                return;
              }

              var cipherText = tweetnacl_util_1.decodeBase64(data.ciphertext);

              if (cipherText.length < tweetnacl_1.secretbox.overheadLength) {
                logger_1["default"].warn("Expected encrypted event ciphertext length to be " + tweetnacl_1.secretbox.overheadLength + ", got: " + cipherText.length);
                return;
              }

              var nonce = tweetnacl_util_1.decodeBase64(data.nonce);

              if (nonce.length < tweetnacl_1.secretbox.nonceLength) {
                logger_1["default"].warn("Expected encrypted event nonce length to be " + tweetnacl_1.secretbox.nonceLength + ", got: " + nonce.length);
                return;
              }

              var bytes = tweetnacl_1.secretbox.open(cipherText, nonce, this.key);

              if (bytes === null) {
                logger_1["default"].debug('Failed to decrypted an event, probably because it was encrypted with a different key. Fetching a new key from the authEndpoint...');
                this.authorize(this.pusher.connection.socket_id, function (error, authData) {
                  if (error) {
                    logger_1["default"].warn("Failed to make a request to the authEndpoint: " + authData + ". Unable to fetch new key, so dropping encrypted event");
                    return;
                  }

                  bytes = tweetnacl_1.secretbox.open(cipherText, nonce, _this.key);

                  if (bytes === null) {
                    logger_1["default"].warn("Failed to decrypt event with new key. Dropping encrypted event");
                    return;
                  }

                  _this.emitJSON(event, tweetnacl_util_1.encodeUTF8(bytes));

                  return;
                });
                return;
              }

              this.emitJSON(event, tweetnacl_util_1.encodeUTF8(bytes));
            };

            EncryptedChannel.prototype.emitJSON = function (eventName, data) {
              try {
                this.emit(eventName, JSON.parse(data));
              } catch (e) {
                this.emit(eventName, data);
              }

              return this;
            };

            return EncryptedChannel;
          }(private_channel_1["default"]);

          exports.__esModule = true;
          exports["default"] = EncryptedChannel;
          /***/
        },
        /* 55 */

        /***/
        function (module, exports, __webpack_require__) {
          (function (nacl) {
            // Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
            // Public domain.
            //
            // Implementation derived from TweetNaCl version 20140427.
            // See for details: http://tweetnacl.cr.yp.to/
            var gf = function gf(init) {
              var i,
                  r = new Float64Array(16);
              if (init) for (i = 0; i < init.length; i++) {
                r[i] = init[i];
              }
              return r;
            }; //  Pluggable, initialized in high-level API below.


            var randombytes = function randombytes()
            /* x, n */
            {
              throw new Error('no PRNG');
            };

            var _0 = new Uint8Array(16);

            var _9 = new Uint8Array(32);

            _9[0] = 9;

            var gf0 = gf(),
                gf1 = gf([1]),
                _121665 = gf([0xdb41, 1]),
                D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
                D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
                X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
                Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
                I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

            function ts64(x, i, h, l) {
              x[i] = h >> 24 & 0xff;
              x[i + 1] = h >> 16 & 0xff;
              x[i + 2] = h >> 8 & 0xff;
              x[i + 3] = h & 0xff;
              x[i + 4] = l >> 24 & 0xff;
              x[i + 5] = l >> 16 & 0xff;
              x[i + 6] = l >> 8 & 0xff;
              x[i + 7] = l & 0xff;
            }

            function vn(x, xi, y, yi, n) {
              var i,
                  d = 0;

              for (i = 0; i < n; i++) {
                d |= x[xi + i] ^ y[yi + i];
              }

              return (1 & d - 1 >>> 8) - 1;
            }

            function crypto_verify_16(x, xi, y, yi) {
              return vn(x, xi, y, yi, 16);
            }

            function crypto_verify_32(x, xi, y, yi) {
              return vn(x, xi, y, yi, 32);
            }

            function core_salsa20(o, p, k, c) {
              var j0 = c[0] & 0xff | (c[1] & 0xff) << 8 | (c[2] & 0xff) << 16 | (c[3] & 0xff) << 24,
                  j1 = k[0] & 0xff | (k[1] & 0xff) << 8 | (k[2] & 0xff) << 16 | (k[3] & 0xff) << 24,
                  j2 = k[4] & 0xff | (k[5] & 0xff) << 8 | (k[6] & 0xff) << 16 | (k[7] & 0xff) << 24,
                  j3 = k[8] & 0xff | (k[9] & 0xff) << 8 | (k[10] & 0xff) << 16 | (k[11] & 0xff) << 24,
                  j4 = k[12] & 0xff | (k[13] & 0xff) << 8 | (k[14] & 0xff) << 16 | (k[15] & 0xff) << 24,
                  j5 = c[4] & 0xff | (c[5] & 0xff) << 8 | (c[6] & 0xff) << 16 | (c[7] & 0xff) << 24,
                  j6 = p[0] & 0xff | (p[1] & 0xff) << 8 | (p[2] & 0xff) << 16 | (p[3] & 0xff) << 24,
                  j7 = p[4] & 0xff | (p[5] & 0xff) << 8 | (p[6] & 0xff) << 16 | (p[7] & 0xff) << 24,
                  j8 = p[8] & 0xff | (p[9] & 0xff) << 8 | (p[10] & 0xff) << 16 | (p[11] & 0xff) << 24,
                  j9 = p[12] & 0xff | (p[13] & 0xff) << 8 | (p[14] & 0xff) << 16 | (p[15] & 0xff) << 24,
                  j10 = c[8] & 0xff | (c[9] & 0xff) << 8 | (c[10] & 0xff) << 16 | (c[11] & 0xff) << 24,
                  j11 = k[16] & 0xff | (k[17] & 0xff) << 8 | (k[18] & 0xff) << 16 | (k[19] & 0xff) << 24,
                  j12 = k[20] & 0xff | (k[21] & 0xff) << 8 | (k[22] & 0xff) << 16 | (k[23] & 0xff) << 24,
                  j13 = k[24] & 0xff | (k[25] & 0xff) << 8 | (k[26] & 0xff) << 16 | (k[27] & 0xff) << 24,
                  j14 = k[28] & 0xff | (k[29] & 0xff) << 8 | (k[30] & 0xff) << 16 | (k[31] & 0xff) << 24,
                  j15 = c[12] & 0xff | (c[13] & 0xff) << 8 | (c[14] & 0xff) << 16 | (c[15] & 0xff) << 24;
              var x0 = j0,
                  x1 = j1,
                  x2 = j2,
                  x3 = j3,
                  x4 = j4,
                  x5 = j5,
                  x6 = j6,
                  x7 = j7,
                  x8 = j8,
                  x9 = j9,
                  x10 = j10,
                  x11 = j11,
                  x12 = j12,
                  x13 = j13,
                  x14 = j14,
                  x15 = j15,
                  u;

              for (var i = 0; i < 20; i += 2) {
                u = x0 + x12 | 0;
                x4 ^= u << 7 | u >>> 32 - 7;
                u = x4 + x0 | 0;
                x8 ^= u << 9 | u >>> 32 - 9;
                u = x8 + x4 | 0;
                x12 ^= u << 13 | u >>> 32 - 13;
                u = x12 + x8 | 0;
                x0 ^= u << 18 | u >>> 32 - 18;
                u = x5 + x1 | 0;
                x9 ^= u << 7 | u >>> 32 - 7;
                u = x9 + x5 | 0;
                x13 ^= u << 9 | u >>> 32 - 9;
                u = x13 + x9 | 0;
                x1 ^= u << 13 | u >>> 32 - 13;
                u = x1 + x13 | 0;
                x5 ^= u << 18 | u >>> 32 - 18;
                u = x10 + x6 | 0;
                x14 ^= u << 7 | u >>> 32 - 7;
                u = x14 + x10 | 0;
                x2 ^= u << 9 | u >>> 32 - 9;
                u = x2 + x14 | 0;
                x6 ^= u << 13 | u >>> 32 - 13;
                u = x6 + x2 | 0;
                x10 ^= u << 18 | u >>> 32 - 18;
                u = x15 + x11 | 0;
                x3 ^= u << 7 | u >>> 32 - 7;
                u = x3 + x15 | 0;
                x7 ^= u << 9 | u >>> 32 - 9;
                u = x7 + x3 | 0;
                x11 ^= u << 13 | u >>> 32 - 13;
                u = x11 + x7 | 0;
                x15 ^= u << 18 | u >>> 32 - 18;
                u = x0 + x3 | 0;
                x1 ^= u << 7 | u >>> 32 - 7;
                u = x1 + x0 | 0;
                x2 ^= u << 9 | u >>> 32 - 9;
                u = x2 + x1 | 0;
                x3 ^= u << 13 | u >>> 32 - 13;
                u = x3 + x2 | 0;
                x0 ^= u << 18 | u >>> 32 - 18;
                u = x5 + x4 | 0;
                x6 ^= u << 7 | u >>> 32 - 7;
                u = x6 + x5 | 0;
                x7 ^= u << 9 | u >>> 32 - 9;
                u = x7 + x6 | 0;
                x4 ^= u << 13 | u >>> 32 - 13;
                u = x4 + x7 | 0;
                x5 ^= u << 18 | u >>> 32 - 18;
                u = x10 + x9 | 0;
                x11 ^= u << 7 | u >>> 32 - 7;
                u = x11 + x10 | 0;
                x8 ^= u << 9 | u >>> 32 - 9;
                u = x8 + x11 | 0;
                x9 ^= u << 13 | u >>> 32 - 13;
                u = x9 + x8 | 0;
                x10 ^= u << 18 | u >>> 32 - 18;
                u = x15 + x14 | 0;
                x12 ^= u << 7 | u >>> 32 - 7;
                u = x12 + x15 | 0;
                x13 ^= u << 9 | u >>> 32 - 9;
                u = x13 + x12 | 0;
                x14 ^= u << 13 | u >>> 32 - 13;
                u = x14 + x13 | 0;
                x15 ^= u << 18 | u >>> 32 - 18;
              }

              x0 = x0 + j0 | 0;
              x1 = x1 + j1 | 0;
              x2 = x2 + j2 | 0;
              x3 = x3 + j3 | 0;
              x4 = x4 + j4 | 0;
              x5 = x5 + j5 | 0;
              x6 = x6 + j6 | 0;
              x7 = x7 + j7 | 0;
              x8 = x8 + j8 | 0;
              x9 = x9 + j9 | 0;
              x10 = x10 + j10 | 0;
              x11 = x11 + j11 | 0;
              x12 = x12 + j12 | 0;
              x13 = x13 + j13 | 0;
              x14 = x14 + j14 | 0;
              x15 = x15 + j15 | 0;
              o[0] = x0 >>> 0 & 0xff;
              o[1] = x0 >>> 8 & 0xff;
              o[2] = x0 >>> 16 & 0xff;
              o[3] = x0 >>> 24 & 0xff;
              o[4] = x1 >>> 0 & 0xff;
              o[5] = x1 >>> 8 & 0xff;
              o[6] = x1 >>> 16 & 0xff;
              o[7] = x1 >>> 24 & 0xff;
              o[8] = x2 >>> 0 & 0xff;
              o[9] = x2 >>> 8 & 0xff;
              o[10] = x2 >>> 16 & 0xff;
              o[11] = x2 >>> 24 & 0xff;
              o[12] = x3 >>> 0 & 0xff;
              o[13] = x3 >>> 8 & 0xff;
              o[14] = x3 >>> 16 & 0xff;
              o[15] = x3 >>> 24 & 0xff;
              o[16] = x4 >>> 0 & 0xff;
              o[17] = x4 >>> 8 & 0xff;
              o[18] = x4 >>> 16 & 0xff;
              o[19] = x4 >>> 24 & 0xff;
              o[20] = x5 >>> 0 & 0xff;
              o[21] = x5 >>> 8 & 0xff;
              o[22] = x5 >>> 16 & 0xff;
              o[23] = x5 >>> 24 & 0xff;
              o[24] = x6 >>> 0 & 0xff;
              o[25] = x6 >>> 8 & 0xff;
              o[26] = x6 >>> 16 & 0xff;
              o[27] = x6 >>> 24 & 0xff;
              o[28] = x7 >>> 0 & 0xff;
              o[29] = x7 >>> 8 & 0xff;
              o[30] = x7 >>> 16 & 0xff;
              o[31] = x7 >>> 24 & 0xff;
              o[32] = x8 >>> 0 & 0xff;
              o[33] = x8 >>> 8 & 0xff;
              o[34] = x8 >>> 16 & 0xff;
              o[35] = x8 >>> 24 & 0xff;
              o[36] = x9 >>> 0 & 0xff;
              o[37] = x9 >>> 8 & 0xff;
              o[38] = x9 >>> 16 & 0xff;
              o[39] = x9 >>> 24 & 0xff;
              o[40] = x10 >>> 0 & 0xff;
              o[41] = x10 >>> 8 & 0xff;
              o[42] = x10 >>> 16 & 0xff;
              o[43] = x10 >>> 24 & 0xff;
              o[44] = x11 >>> 0 & 0xff;
              o[45] = x11 >>> 8 & 0xff;
              o[46] = x11 >>> 16 & 0xff;
              o[47] = x11 >>> 24 & 0xff;
              o[48] = x12 >>> 0 & 0xff;
              o[49] = x12 >>> 8 & 0xff;
              o[50] = x12 >>> 16 & 0xff;
              o[51] = x12 >>> 24 & 0xff;
              o[52] = x13 >>> 0 & 0xff;
              o[53] = x13 >>> 8 & 0xff;
              o[54] = x13 >>> 16 & 0xff;
              o[55] = x13 >>> 24 & 0xff;
              o[56] = x14 >>> 0 & 0xff;
              o[57] = x14 >>> 8 & 0xff;
              o[58] = x14 >>> 16 & 0xff;
              o[59] = x14 >>> 24 & 0xff;
              o[60] = x15 >>> 0 & 0xff;
              o[61] = x15 >>> 8 & 0xff;
              o[62] = x15 >>> 16 & 0xff;
              o[63] = x15 >>> 24 & 0xff;
            }

            function core_hsalsa20(o, p, k, c) {
              var j0 = c[0] & 0xff | (c[1] & 0xff) << 8 | (c[2] & 0xff) << 16 | (c[3] & 0xff) << 24,
                  j1 = k[0] & 0xff | (k[1] & 0xff) << 8 | (k[2] & 0xff) << 16 | (k[3] & 0xff) << 24,
                  j2 = k[4] & 0xff | (k[5] & 0xff) << 8 | (k[6] & 0xff) << 16 | (k[7] & 0xff) << 24,
                  j3 = k[8] & 0xff | (k[9] & 0xff) << 8 | (k[10] & 0xff) << 16 | (k[11] & 0xff) << 24,
                  j4 = k[12] & 0xff | (k[13] & 0xff) << 8 | (k[14] & 0xff) << 16 | (k[15] & 0xff) << 24,
                  j5 = c[4] & 0xff | (c[5] & 0xff) << 8 | (c[6] & 0xff) << 16 | (c[7] & 0xff) << 24,
                  j6 = p[0] & 0xff | (p[1] & 0xff) << 8 | (p[2] & 0xff) << 16 | (p[3] & 0xff) << 24,
                  j7 = p[4] & 0xff | (p[5] & 0xff) << 8 | (p[6] & 0xff) << 16 | (p[7] & 0xff) << 24,
                  j8 = p[8] & 0xff | (p[9] & 0xff) << 8 | (p[10] & 0xff) << 16 | (p[11] & 0xff) << 24,
                  j9 = p[12] & 0xff | (p[13] & 0xff) << 8 | (p[14] & 0xff) << 16 | (p[15] & 0xff) << 24,
                  j10 = c[8] & 0xff | (c[9] & 0xff) << 8 | (c[10] & 0xff) << 16 | (c[11] & 0xff) << 24,
                  j11 = k[16] & 0xff | (k[17] & 0xff) << 8 | (k[18] & 0xff) << 16 | (k[19] & 0xff) << 24,
                  j12 = k[20] & 0xff | (k[21] & 0xff) << 8 | (k[22] & 0xff) << 16 | (k[23] & 0xff) << 24,
                  j13 = k[24] & 0xff | (k[25] & 0xff) << 8 | (k[26] & 0xff) << 16 | (k[27] & 0xff) << 24,
                  j14 = k[28] & 0xff | (k[29] & 0xff) << 8 | (k[30] & 0xff) << 16 | (k[31] & 0xff) << 24,
                  j15 = c[12] & 0xff | (c[13] & 0xff) << 8 | (c[14] & 0xff) << 16 | (c[15] & 0xff) << 24;
              var x0 = j0,
                  x1 = j1,
                  x2 = j2,
                  x3 = j3,
                  x4 = j4,
                  x5 = j5,
                  x6 = j6,
                  x7 = j7,
                  x8 = j8,
                  x9 = j9,
                  x10 = j10,
                  x11 = j11,
                  x12 = j12,
                  x13 = j13,
                  x14 = j14,
                  x15 = j15,
                  u;

              for (var i = 0; i < 20; i += 2) {
                u = x0 + x12 | 0;
                x4 ^= u << 7 | u >>> 32 - 7;
                u = x4 + x0 | 0;
                x8 ^= u << 9 | u >>> 32 - 9;
                u = x8 + x4 | 0;
                x12 ^= u << 13 | u >>> 32 - 13;
                u = x12 + x8 | 0;
                x0 ^= u << 18 | u >>> 32 - 18;
                u = x5 + x1 | 0;
                x9 ^= u << 7 | u >>> 32 - 7;
                u = x9 + x5 | 0;
                x13 ^= u << 9 | u >>> 32 - 9;
                u = x13 + x9 | 0;
                x1 ^= u << 13 | u >>> 32 - 13;
                u = x1 + x13 | 0;
                x5 ^= u << 18 | u >>> 32 - 18;
                u = x10 + x6 | 0;
                x14 ^= u << 7 | u >>> 32 - 7;
                u = x14 + x10 | 0;
                x2 ^= u << 9 | u >>> 32 - 9;
                u = x2 + x14 | 0;
                x6 ^= u << 13 | u >>> 32 - 13;
                u = x6 + x2 | 0;
                x10 ^= u << 18 | u >>> 32 - 18;
                u = x15 + x11 | 0;
                x3 ^= u << 7 | u >>> 32 - 7;
                u = x3 + x15 | 0;
                x7 ^= u << 9 | u >>> 32 - 9;
                u = x7 + x3 | 0;
                x11 ^= u << 13 | u >>> 32 - 13;
                u = x11 + x7 | 0;
                x15 ^= u << 18 | u >>> 32 - 18;
                u = x0 + x3 | 0;
                x1 ^= u << 7 | u >>> 32 - 7;
                u = x1 + x0 | 0;
                x2 ^= u << 9 | u >>> 32 - 9;
                u = x2 + x1 | 0;
                x3 ^= u << 13 | u >>> 32 - 13;
                u = x3 + x2 | 0;
                x0 ^= u << 18 | u >>> 32 - 18;
                u = x5 + x4 | 0;
                x6 ^= u << 7 | u >>> 32 - 7;
                u = x6 + x5 | 0;
                x7 ^= u << 9 | u >>> 32 - 9;
                u = x7 + x6 | 0;
                x4 ^= u << 13 | u >>> 32 - 13;
                u = x4 + x7 | 0;
                x5 ^= u << 18 | u >>> 32 - 18;
                u = x10 + x9 | 0;
                x11 ^= u << 7 | u >>> 32 - 7;
                u = x11 + x10 | 0;
                x8 ^= u << 9 | u >>> 32 - 9;
                u = x8 + x11 | 0;
                x9 ^= u << 13 | u >>> 32 - 13;
                u = x9 + x8 | 0;
                x10 ^= u << 18 | u >>> 32 - 18;
                u = x15 + x14 | 0;
                x12 ^= u << 7 | u >>> 32 - 7;
                u = x12 + x15 | 0;
                x13 ^= u << 9 | u >>> 32 - 9;
                u = x13 + x12 | 0;
                x14 ^= u << 13 | u >>> 32 - 13;
                u = x14 + x13 | 0;
                x15 ^= u << 18 | u >>> 32 - 18;
              }

              o[0] = x0 >>> 0 & 0xff;
              o[1] = x0 >>> 8 & 0xff;
              o[2] = x0 >>> 16 & 0xff;
              o[3] = x0 >>> 24 & 0xff;
              o[4] = x5 >>> 0 & 0xff;
              o[5] = x5 >>> 8 & 0xff;
              o[6] = x5 >>> 16 & 0xff;
              o[7] = x5 >>> 24 & 0xff;
              o[8] = x10 >>> 0 & 0xff;
              o[9] = x10 >>> 8 & 0xff;
              o[10] = x10 >>> 16 & 0xff;
              o[11] = x10 >>> 24 & 0xff;
              o[12] = x15 >>> 0 & 0xff;
              o[13] = x15 >>> 8 & 0xff;
              o[14] = x15 >>> 16 & 0xff;
              o[15] = x15 >>> 24 & 0xff;
              o[16] = x6 >>> 0 & 0xff;
              o[17] = x6 >>> 8 & 0xff;
              o[18] = x6 >>> 16 & 0xff;
              o[19] = x6 >>> 24 & 0xff;
              o[20] = x7 >>> 0 & 0xff;
              o[21] = x7 >>> 8 & 0xff;
              o[22] = x7 >>> 16 & 0xff;
              o[23] = x7 >>> 24 & 0xff;
              o[24] = x8 >>> 0 & 0xff;
              o[25] = x8 >>> 8 & 0xff;
              o[26] = x8 >>> 16 & 0xff;
              o[27] = x8 >>> 24 & 0xff;
              o[28] = x9 >>> 0 & 0xff;
              o[29] = x9 >>> 8 & 0xff;
              o[30] = x9 >>> 16 & 0xff;
              o[31] = x9 >>> 24 & 0xff;
            }

            function crypto_core_salsa20(out, inp, k, c) {
              core_salsa20(out, inp, k, c);
            }

            function crypto_core_hsalsa20(out, inp, k, c) {
              core_hsalsa20(out, inp, k, c);
            }

            var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]); // "expand 32-byte k"

            function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
              var z = new Uint8Array(16),
                  x = new Uint8Array(64);
              var u, i;

              for (i = 0; i < 16; i++) {
                z[i] = 0;
              }

              for (i = 0; i < 8; i++) {
                z[i] = n[i];
              }

              while (b >= 64) {
                crypto_core_salsa20(x, z, k, sigma);

                for (i = 0; i < 64; i++) {
                  c[cpos + i] = m[mpos + i] ^ x[i];
                }

                u = 1;

                for (i = 8; i < 16; i++) {
                  u = u + (z[i] & 0xff) | 0;
                  z[i] = u & 0xff;
                  u >>>= 8;
                }

                b -= 64;
                cpos += 64;
                mpos += 64;
              }

              if (b > 0) {
                crypto_core_salsa20(x, z, k, sigma);

                for (i = 0; i < b; i++) {
                  c[cpos + i] = m[mpos + i] ^ x[i];
                }
              }

              return 0;
            }

            function crypto_stream_salsa20(c, cpos, b, n, k) {
              var z = new Uint8Array(16),
                  x = new Uint8Array(64);
              var u, i;

              for (i = 0; i < 16; i++) {
                z[i] = 0;
              }

              for (i = 0; i < 8; i++) {
                z[i] = n[i];
              }

              while (b >= 64) {
                crypto_core_salsa20(x, z, k, sigma);

                for (i = 0; i < 64; i++) {
                  c[cpos + i] = x[i];
                }

                u = 1;

                for (i = 8; i < 16; i++) {
                  u = u + (z[i] & 0xff) | 0;
                  z[i] = u & 0xff;
                  u >>>= 8;
                }

                b -= 64;
                cpos += 64;
              }

              if (b > 0) {
                crypto_core_salsa20(x, z, k, sigma);

                for (i = 0; i < b; i++) {
                  c[cpos + i] = x[i];
                }
              }

              return 0;
            }

            function crypto_stream(c, cpos, d, n, k) {
              var s = new Uint8Array(32);
              crypto_core_hsalsa20(s, n, k, sigma);
              var sn = new Uint8Array(8);

              for (var i = 0; i < 8; i++) {
                sn[i] = n[i + 16];
              }

              return crypto_stream_salsa20(c, cpos, d, sn, s);
            }

            function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
              var s = new Uint8Array(32);
              crypto_core_hsalsa20(s, n, k, sigma);
              var sn = new Uint8Array(8);

              for (var i = 0; i < 8; i++) {
                sn[i] = n[i + 16];
              }

              return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
            }
            /*
            * Port of Andrew Moon's Poly1305-donna-16. Public domain.
            * https://github.com/floodyberry/poly1305-donna
            */


            var poly1305 = function poly1305(key) {
              this.buffer = new Uint8Array(16);
              this.r = new Uint16Array(10);
              this.h = new Uint16Array(10);
              this.pad = new Uint16Array(8);
              this.leftover = 0;
              this.fin = 0;
              var t0, t1, t2, t3, t4, t5, t6, t7;
              t0 = key[0] & 0xff | (key[1] & 0xff) << 8;
              this.r[0] = t0 & 0x1fff;
              t1 = key[2] & 0xff | (key[3] & 0xff) << 8;
              this.r[1] = (t0 >>> 13 | t1 << 3) & 0x1fff;
              t2 = key[4] & 0xff | (key[5] & 0xff) << 8;
              this.r[2] = (t1 >>> 10 | t2 << 6) & 0x1f03;
              t3 = key[6] & 0xff | (key[7] & 0xff) << 8;
              this.r[3] = (t2 >>> 7 | t3 << 9) & 0x1fff;
              t4 = key[8] & 0xff | (key[9] & 0xff) << 8;
              this.r[4] = (t3 >>> 4 | t4 << 12) & 0x00ff;
              this.r[5] = t4 >>> 1 & 0x1ffe;
              t5 = key[10] & 0xff | (key[11] & 0xff) << 8;
              this.r[6] = (t4 >>> 14 | t5 << 2) & 0x1fff;
              t6 = key[12] & 0xff | (key[13] & 0xff) << 8;
              this.r[7] = (t5 >>> 11 | t6 << 5) & 0x1f81;
              t7 = key[14] & 0xff | (key[15] & 0xff) << 8;
              this.r[8] = (t6 >>> 8 | t7 << 8) & 0x1fff;
              this.r[9] = t7 >>> 5 & 0x007f;
              this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
              this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
              this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
              this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
              this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
              this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
              this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
              this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
            };

            poly1305.prototype.blocks = function (m, mpos, bytes) {
              var hibit = this.fin ? 0 : 1 << 11;
              var t0, t1, t2, t3, t4, t5, t6, t7, c;
              var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
              var h0 = this.h[0],
                  h1 = this.h[1],
                  h2 = this.h[2],
                  h3 = this.h[3],
                  h4 = this.h[4],
                  h5 = this.h[5],
                  h6 = this.h[6],
                  h7 = this.h[7],
                  h8 = this.h[8],
                  h9 = this.h[9];
              var r0 = this.r[0],
                  r1 = this.r[1],
                  r2 = this.r[2],
                  r3 = this.r[3],
                  r4 = this.r[4],
                  r5 = this.r[5],
                  r6 = this.r[6],
                  r7 = this.r[7],
                  r8 = this.r[8],
                  r9 = this.r[9];

              while (bytes >= 16) {
                t0 = m[mpos + 0] & 0xff | (m[mpos + 1] & 0xff) << 8;
                h0 += t0 & 0x1fff;
                t1 = m[mpos + 2] & 0xff | (m[mpos + 3] & 0xff) << 8;
                h1 += (t0 >>> 13 | t1 << 3) & 0x1fff;
                t2 = m[mpos + 4] & 0xff | (m[mpos + 5] & 0xff) << 8;
                h2 += (t1 >>> 10 | t2 << 6) & 0x1fff;
                t3 = m[mpos + 6] & 0xff | (m[mpos + 7] & 0xff) << 8;
                h3 += (t2 >>> 7 | t3 << 9) & 0x1fff;
                t4 = m[mpos + 8] & 0xff | (m[mpos + 9] & 0xff) << 8;
                h4 += (t3 >>> 4 | t4 << 12) & 0x1fff;
                h5 += t4 >>> 1 & 0x1fff;
                t5 = m[mpos + 10] & 0xff | (m[mpos + 11] & 0xff) << 8;
                h6 += (t4 >>> 14 | t5 << 2) & 0x1fff;
                t6 = m[mpos + 12] & 0xff | (m[mpos + 13] & 0xff) << 8;
                h7 += (t5 >>> 11 | t6 << 5) & 0x1fff;
                t7 = m[mpos + 14] & 0xff | (m[mpos + 15] & 0xff) << 8;
                h8 += (t6 >>> 8 | t7 << 8) & 0x1fff;
                h9 += t7 >>> 5 | hibit;
                c = 0;
                d0 = c;
                d0 += h0 * r0;
                d0 += h1 * (5 * r9);
                d0 += h2 * (5 * r8);
                d0 += h3 * (5 * r7);
                d0 += h4 * (5 * r6);
                c = d0 >>> 13;
                d0 &= 0x1fff;
                d0 += h5 * (5 * r5);
                d0 += h6 * (5 * r4);
                d0 += h7 * (5 * r3);
                d0 += h8 * (5 * r2);
                d0 += h9 * (5 * r1);
                c += d0 >>> 13;
                d0 &= 0x1fff;
                d1 = c;
                d1 += h0 * r1;
                d1 += h1 * r0;
                d1 += h2 * (5 * r9);
                d1 += h3 * (5 * r8);
                d1 += h4 * (5 * r7);
                c = d1 >>> 13;
                d1 &= 0x1fff;
                d1 += h5 * (5 * r6);
                d1 += h6 * (5 * r5);
                d1 += h7 * (5 * r4);
                d1 += h8 * (5 * r3);
                d1 += h9 * (5 * r2);
                c += d1 >>> 13;
                d1 &= 0x1fff;
                d2 = c;
                d2 += h0 * r2;
                d2 += h1 * r1;
                d2 += h2 * r0;
                d2 += h3 * (5 * r9);
                d2 += h4 * (5 * r8);
                c = d2 >>> 13;
                d2 &= 0x1fff;
                d2 += h5 * (5 * r7);
                d2 += h6 * (5 * r6);
                d2 += h7 * (5 * r5);
                d2 += h8 * (5 * r4);
                d2 += h9 * (5 * r3);
                c += d2 >>> 13;
                d2 &= 0x1fff;
                d3 = c;
                d3 += h0 * r3;
                d3 += h1 * r2;
                d3 += h2 * r1;
                d3 += h3 * r0;
                d3 += h4 * (5 * r9);
                c = d3 >>> 13;
                d3 &= 0x1fff;
                d3 += h5 * (5 * r8);
                d3 += h6 * (5 * r7);
                d3 += h7 * (5 * r6);
                d3 += h8 * (5 * r5);
                d3 += h9 * (5 * r4);
                c += d3 >>> 13;
                d3 &= 0x1fff;
                d4 = c;
                d4 += h0 * r4;
                d4 += h1 * r3;
                d4 += h2 * r2;
                d4 += h3 * r1;
                d4 += h4 * r0;
                c = d4 >>> 13;
                d4 &= 0x1fff;
                d4 += h5 * (5 * r9);
                d4 += h6 * (5 * r8);
                d4 += h7 * (5 * r7);
                d4 += h8 * (5 * r6);
                d4 += h9 * (5 * r5);
                c += d4 >>> 13;
                d4 &= 0x1fff;
                d5 = c;
                d5 += h0 * r5;
                d5 += h1 * r4;
                d5 += h2 * r3;
                d5 += h3 * r2;
                d5 += h4 * r1;
                c = d5 >>> 13;
                d5 &= 0x1fff;
                d5 += h5 * r0;
                d5 += h6 * (5 * r9);
                d5 += h7 * (5 * r8);
                d5 += h8 * (5 * r7);
                d5 += h9 * (5 * r6);
                c += d5 >>> 13;
                d5 &= 0x1fff;
                d6 = c;
                d6 += h0 * r6;
                d6 += h1 * r5;
                d6 += h2 * r4;
                d6 += h3 * r3;
                d6 += h4 * r2;
                c = d6 >>> 13;
                d6 &= 0x1fff;
                d6 += h5 * r1;
                d6 += h6 * r0;
                d6 += h7 * (5 * r9);
                d6 += h8 * (5 * r8);
                d6 += h9 * (5 * r7);
                c += d6 >>> 13;
                d6 &= 0x1fff;
                d7 = c;
                d7 += h0 * r7;
                d7 += h1 * r6;
                d7 += h2 * r5;
                d7 += h3 * r4;
                d7 += h4 * r3;
                c = d7 >>> 13;
                d7 &= 0x1fff;
                d7 += h5 * r2;
                d7 += h6 * r1;
                d7 += h7 * r0;
                d7 += h8 * (5 * r9);
                d7 += h9 * (5 * r8);
                c += d7 >>> 13;
                d7 &= 0x1fff;
                d8 = c;
                d8 += h0 * r8;
                d8 += h1 * r7;
                d8 += h2 * r6;
                d8 += h3 * r5;
                d8 += h4 * r4;
                c = d8 >>> 13;
                d8 &= 0x1fff;
                d8 += h5 * r3;
                d8 += h6 * r2;
                d8 += h7 * r1;
                d8 += h8 * r0;
                d8 += h9 * (5 * r9);
                c += d8 >>> 13;
                d8 &= 0x1fff;
                d9 = c;
                d9 += h0 * r9;
                d9 += h1 * r8;
                d9 += h2 * r7;
                d9 += h3 * r6;
                d9 += h4 * r5;
                c = d9 >>> 13;
                d9 &= 0x1fff;
                d9 += h5 * r4;
                d9 += h6 * r3;
                d9 += h7 * r2;
                d9 += h8 * r1;
                d9 += h9 * r0;
                c += d9 >>> 13;
                d9 &= 0x1fff;
                c = (c << 2) + c | 0;
                c = c + d0 | 0;
                d0 = c & 0x1fff;
                c = c >>> 13;
                d1 += c;
                h0 = d0;
                h1 = d1;
                h2 = d2;
                h3 = d3;
                h4 = d4;
                h5 = d5;
                h6 = d6;
                h7 = d7;
                h8 = d8;
                h9 = d9;
                mpos += 16;
                bytes -= 16;
              }

              this.h[0] = h0;
              this.h[1] = h1;
              this.h[2] = h2;
              this.h[3] = h3;
              this.h[4] = h4;
              this.h[5] = h5;
              this.h[6] = h6;
              this.h[7] = h7;
              this.h[8] = h8;
              this.h[9] = h9;
            };

            poly1305.prototype.finish = function (mac, macpos) {
              var g = new Uint16Array(10);
              var c, mask, f, i;

              if (this.leftover) {
                i = this.leftover;
                this.buffer[i++] = 1;

                for (; i < 16; i++) {
                  this.buffer[i] = 0;
                }

                this.fin = 1;
                this.blocks(this.buffer, 0, 16);
              }

              c = this.h[1] >>> 13;
              this.h[1] &= 0x1fff;

              for (i = 2; i < 10; i++) {
                this.h[i] += c;
                c = this.h[i] >>> 13;
                this.h[i] &= 0x1fff;
              }

              this.h[0] += c * 5;
              c = this.h[0] >>> 13;
              this.h[0] &= 0x1fff;
              this.h[1] += c;
              c = this.h[1] >>> 13;
              this.h[1] &= 0x1fff;
              this.h[2] += c;
              g[0] = this.h[0] + 5;
              c = g[0] >>> 13;
              g[0] &= 0x1fff;

              for (i = 1; i < 10; i++) {
                g[i] = this.h[i] + c;
                c = g[i] >>> 13;
                g[i] &= 0x1fff;
              }

              g[9] -= 1 << 13;
              mask = (c ^ 1) - 1;

              for (i = 0; i < 10; i++) {
                g[i] &= mask;
              }

              mask = ~mask;

              for (i = 0; i < 10; i++) {
                this.h[i] = this.h[i] & mask | g[i];
              }

              this.h[0] = (this.h[0] | this.h[1] << 13) & 0xffff;
              this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 0xffff;
              this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 0xffff;
              this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 0xffff;
              this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 0xffff;
              this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 0xffff;
              this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 0xffff;
              this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 0xffff;
              f = this.h[0] + this.pad[0];
              this.h[0] = f & 0xffff;

              for (i = 1; i < 8; i++) {
                f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
                this.h[i] = f & 0xffff;
              }

              mac[macpos + 0] = this.h[0] >>> 0 & 0xff;
              mac[macpos + 1] = this.h[0] >>> 8 & 0xff;
              mac[macpos + 2] = this.h[1] >>> 0 & 0xff;
              mac[macpos + 3] = this.h[1] >>> 8 & 0xff;
              mac[macpos + 4] = this.h[2] >>> 0 & 0xff;
              mac[macpos + 5] = this.h[2] >>> 8 & 0xff;
              mac[macpos + 6] = this.h[3] >>> 0 & 0xff;
              mac[macpos + 7] = this.h[3] >>> 8 & 0xff;
              mac[macpos + 8] = this.h[4] >>> 0 & 0xff;
              mac[macpos + 9] = this.h[4] >>> 8 & 0xff;
              mac[macpos + 10] = this.h[5] >>> 0 & 0xff;
              mac[macpos + 11] = this.h[5] >>> 8 & 0xff;
              mac[macpos + 12] = this.h[6] >>> 0 & 0xff;
              mac[macpos + 13] = this.h[6] >>> 8 & 0xff;
              mac[macpos + 14] = this.h[7] >>> 0 & 0xff;
              mac[macpos + 15] = this.h[7] >>> 8 & 0xff;
            };

            poly1305.prototype.update = function (m, mpos, bytes) {
              var i, want;

              if (this.leftover) {
                want = 16 - this.leftover;
                if (want > bytes) want = bytes;

                for (i = 0; i < want; i++) {
                  this.buffer[this.leftover + i] = m[mpos + i];
                }

                bytes -= want;
                mpos += want;
                this.leftover += want;
                if (this.leftover < 16) return;
                this.blocks(this.buffer, 0, 16);
                this.leftover = 0;
              }

              if (bytes >= 16) {
                want = bytes - bytes % 16;
                this.blocks(m, mpos, want);
                mpos += want;
                bytes -= want;
              }

              if (bytes) {
                for (i = 0; i < bytes; i++) {
                  this.buffer[this.leftover + i] = m[mpos + i];
                }

                this.leftover += bytes;
              }
            };

            function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
              var s = new poly1305(k);
              s.update(m, mpos, n);
              s.finish(out, outpos);
              return 0;
            }

            function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
              var x = new Uint8Array(16);
              crypto_onetimeauth(x, 0, m, mpos, n, k);
              return crypto_verify_16(h, hpos, x, 0);
            }

            function crypto_secretbox(c, m, d, n, k) {
              var i;
              if (d < 32) return -1;
              crypto_stream_xor(c, 0, m, 0, d, n, k);
              crypto_onetimeauth(c, 16, c, 32, d - 32, c);

              for (i = 0; i < 16; i++) {
                c[i] = 0;
              }

              return 0;
            }

            function crypto_secretbox_open(m, c, d, n, k) {
              var i;
              var x = new Uint8Array(32);
              if (d < 32) return -1;
              crypto_stream(x, 0, 32, n, k);
              if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
              crypto_stream_xor(m, 0, c, 0, d, n, k);

              for (i = 0; i < 32; i++) {
                m[i] = 0;
              }

              return 0;
            }

            function set25519(r, a) {
              var i;

              for (i = 0; i < 16; i++) {
                r[i] = a[i] | 0;
              }
            }

            function car25519(o) {
              var i,
                  v,
                  c = 1;

              for (i = 0; i < 16; i++) {
                v = o[i] + c + 65535;
                c = Math.floor(v / 65536);
                o[i] = v - c * 65536;
              }

              o[0] += c - 1 + 37 * (c - 1);
            }

            function sel25519(p, q, b) {
              var t,
                  c = ~(b - 1);

              for (var i = 0; i < 16; i++) {
                t = c & (p[i] ^ q[i]);
                p[i] ^= t;
                q[i] ^= t;
              }
            }

            function pack25519(o, n) {
              var i, j, b;
              var m = gf(),
                  t = gf();

              for (i = 0; i < 16; i++) {
                t[i] = n[i];
              }

              car25519(t);
              car25519(t);
              car25519(t);

              for (j = 0; j < 2; j++) {
                m[0] = t[0] - 0xffed;

                for (i = 1; i < 15; i++) {
                  m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);
                  m[i - 1] &= 0xffff;
                }

                m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);
                b = m[15] >> 16 & 1;
                m[14] &= 0xffff;
                sel25519(t, m, 1 - b);
              }

              for (i = 0; i < 16; i++) {
                o[2 * i] = t[i] & 0xff;
                o[2 * i + 1] = t[i] >> 8;
              }
            }

            function neq25519(a, b) {
              var c = new Uint8Array(32),
                  d = new Uint8Array(32);
              pack25519(c, a);
              pack25519(d, b);
              return crypto_verify_32(c, 0, d, 0);
            }

            function par25519(a) {
              var d = new Uint8Array(32);
              pack25519(d, a);
              return d[0] & 1;
            }

            function unpack25519(o, n) {
              var i;

              for (i = 0; i < 16; i++) {
                o[i] = n[2 * i] + (n[2 * i + 1] << 8);
              }

              o[15] &= 0x7fff;
            }

            function A(o, a, b) {
              for (var i = 0; i < 16; i++) {
                o[i] = a[i] + b[i];
              }
            }

            function Z(o, a, b) {
              for (var i = 0; i < 16; i++) {
                o[i] = a[i] - b[i];
              }
            }

            function M(o, a, b) {
              var v,
                  c,
                  t0 = 0,
                  t1 = 0,
                  t2 = 0,
                  t3 = 0,
                  t4 = 0,
                  t5 = 0,
                  t6 = 0,
                  t7 = 0,
                  t8 = 0,
                  t9 = 0,
                  t10 = 0,
                  t11 = 0,
                  t12 = 0,
                  t13 = 0,
                  t14 = 0,
                  t15 = 0,
                  t16 = 0,
                  t17 = 0,
                  t18 = 0,
                  t19 = 0,
                  t20 = 0,
                  t21 = 0,
                  t22 = 0,
                  t23 = 0,
                  t24 = 0,
                  t25 = 0,
                  t26 = 0,
                  t27 = 0,
                  t28 = 0,
                  t29 = 0,
                  t30 = 0,
                  b0 = b[0],
                  b1 = b[1],
                  b2 = b[2],
                  b3 = b[3],
                  b4 = b[4],
                  b5 = b[5],
                  b6 = b[6],
                  b7 = b[7],
                  b8 = b[8],
                  b9 = b[9],
                  b10 = b[10],
                  b11 = b[11],
                  b12 = b[12],
                  b13 = b[13],
                  b14 = b[14],
                  b15 = b[15];
              v = a[0];
              t0 += v * b0;
              t1 += v * b1;
              t2 += v * b2;
              t3 += v * b3;
              t4 += v * b4;
              t5 += v * b5;
              t6 += v * b6;
              t7 += v * b7;
              t8 += v * b8;
              t9 += v * b9;
              t10 += v * b10;
              t11 += v * b11;
              t12 += v * b12;
              t13 += v * b13;
              t14 += v * b14;
              t15 += v * b15;
              v = a[1];
              t1 += v * b0;
              t2 += v * b1;
              t3 += v * b2;
              t4 += v * b3;
              t5 += v * b4;
              t6 += v * b5;
              t7 += v * b6;
              t8 += v * b7;
              t9 += v * b8;
              t10 += v * b9;
              t11 += v * b10;
              t12 += v * b11;
              t13 += v * b12;
              t14 += v * b13;
              t15 += v * b14;
              t16 += v * b15;
              v = a[2];
              t2 += v * b0;
              t3 += v * b1;
              t4 += v * b2;
              t5 += v * b3;
              t6 += v * b4;
              t7 += v * b5;
              t8 += v * b6;
              t9 += v * b7;
              t10 += v * b8;
              t11 += v * b9;
              t12 += v * b10;
              t13 += v * b11;
              t14 += v * b12;
              t15 += v * b13;
              t16 += v * b14;
              t17 += v * b15;
              v = a[3];
              t3 += v * b0;
              t4 += v * b1;
              t5 += v * b2;
              t6 += v * b3;
              t7 += v * b4;
              t8 += v * b5;
              t9 += v * b6;
              t10 += v * b7;
              t11 += v * b8;
              t12 += v * b9;
              t13 += v * b10;
              t14 += v * b11;
              t15 += v * b12;
              t16 += v * b13;
              t17 += v * b14;
              t18 += v * b15;
              v = a[4];
              t4 += v * b0;
              t5 += v * b1;
              t6 += v * b2;
              t7 += v * b3;
              t8 += v * b4;
              t9 += v * b5;
              t10 += v * b6;
              t11 += v * b7;
              t12 += v * b8;
              t13 += v * b9;
              t14 += v * b10;
              t15 += v * b11;
              t16 += v * b12;
              t17 += v * b13;
              t18 += v * b14;
              t19 += v * b15;
              v = a[5];
              t5 += v * b0;
              t6 += v * b1;
              t7 += v * b2;
              t8 += v * b3;
              t9 += v * b4;
              t10 += v * b5;
              t11 += v * b6;
              t12 += v * b7;
              t13 += v * b8;
              t14 += v * b9;
              t15 += v * b10;
              t16 += v * b11;
              t17 += v * b12;
              t18 += v * b13;
              t19 += v * b14;
              t20 += v * b15;
              v = a[6];
              t6 += v * b0;
              t7 += v * b1;
              t8 += v * b2;
              t9 += v * b3;
              t10 += v * b4;
              t11 += v * b5;
              t12 += v * b6;
              t13 += v * b7;
              t14 += v * b8;
              t15 += v * b9;
              t16 += v * b10;
              t17 += v * b11;
              t18 += v * b12;
              t19 += v * b13;
              t20 += v * b14;
              t21 += v * b15;
              v = a[7];
              t7 += v * b0;
              t8 += v * b1;
              t9 += v * b2;
              t10 += v * b3;
              t11 += v * b4;
              t12 += v * b5;
              t13 += v * b6;
              t14 += v * b7;
              t15 += v * b8;
              t16 += v * b9;
              t17 += v * b10;
              t18 += v * b11;
              t19 += v * b12;
              t20 += v * b13;
              t21 += v * b14;
              t22 += v * b15;
              v = a[8];
              t8 += v * b0;
              t9 += v * b1;
              t10 += v * b2;
              t11 += v * b3;
              t12 += v * b4;
              t13 += v * b5;
              t14 += v * b6;
              t15 += v * b7;
              t16 += v * b8;
              t17 += v * b9;
              t18 += v * b10;
              t19 += v * b11;
              t20 += v * b12;
              t21 += v * b13;
              t22 += v * b14;
              t23 += v * b15;
              v = a[9];
              t9 += v * b0;
              t10 += v * b1;
              t11 += v * b2;
              t12 += v * b3;
              t13 += v * b4;
              t14 += v * b5;
              t15 += v * b6;
              t16 += v * b7;
              t17 += v * b8;
              t18 += v * b9;
              t19 += v * b10;
              t20 += v * b11;
              t21 += v * b12;
              t22 += v * b13;
              t23 += v * b14;
              t24 += v * b15;
              v = a[10];
              t10 += v * b0;
              t11 += v * b1;
              t12 += v * b2;
              t13 += v * b3;
              t14 += v * b4;
              t15 += v * b5;
              t16 += v * b6;
              t17 += v * b7;
              t18 += v * b8;
              t19 += v * b9;
              t20 += v * b10;
              t21 += v * b11;
              t22 += v * b12;
              t23 += v * b13;
              t24 += v * b14;
              t25 += v * b15;
              v = a[11];
              t11 += v * b0;
              t12 += v * b1;
              t13 += v * b2;
              t14 += v * b3;
              t15 += v * b4;
              t16 += v * b5;
              t17 += v * b6;
              t18 += v * b7;
              t19 += v * b8;
              t20 += v * b9;
              t21 += v * b10;
              t22 += v * b11;
              t23 += v * b12;
              t24 += v * b13;
              t25 += v * b14;
              t26 += v * b15;
              v = a[12];
              t12 += v * b0;
              t13 += v * b1;
              t14 += v * b2;
              t15 += v * b3;
              t16 += v * b4;
              t17 += v * b5;
              t18 += v * b6;
              t19 += v * b7;
              t20 += v * b8;
              t21 += v * b9;
              t22 += v * b10;
              t23 += v * b11;
              t24 += v * b12;
              t25 += v * b13;
              t26 += v * b14;
              t27 += v * b15;
              v = a[13];
              t13 += v * b0;
              t14 += v * b1;
              t15 += v * b2;
              t16 += v * b3;
              t17 += v * b4;
              t18 += v * b5;
              t19 += v * b6;
              t20 += v * b7;
              t21 += v * b8;
              t22 += v * b9;
              t23 += v * b10;
              t24 += v * b11;
              t25 += v * b12;
              t26 += v * b13;
              t27 += v * b14;
              t28 += v * b15;
              v = a[14];
              t14 += v * b0;
              t15 += v * b1;
              t16 += v * b2;
              t17 += v * b3;
              t18 += v * b4;
              t19 += v * b5;
              t20 += v * b6;
              t21 += v * b7;
              t22 += v * b8;
              t23 += v * b9;
              t24 += v * b10;
              t25 += v * b11;
              t26 += v * b12;
              t27 += v * b13;
              t28 += v * b14;
              t29 += v * b15;
              v = a[15];
              t15 += v * b0;
              t16 += v * b1;
              t17 += v * b2;
              t18 += v * b3;
              t19 += v * b4;
              t20 += v * b5;
              t21 += v * b6;
              t22 += v * b7;
              t23 += v * b8;
              t24 += v * b9;
              t25 += v * b10;
              t26 += v * b11;
              t27 += v * b12;
              t28 += v * b13;
              t29 += v * b14;
              t30 += v * b15;
              t0 += 38 * t16;
              t1 += 38 * t17;
              t2 += 38 * t18;
              t3 += 38 * t19;
              t4 += 38 * t20;
              t5 += 38 * t21;
              t6 += 38 * t22;
              t7 += 38 * t23;
              t8 += 38 * t24;
              t9 += 38 * t25;
              t10 += 38 * t26;
              t11 += 38 * t27;
              t12 += 38 * t28;
              t13 += 38 * t29;
              t14 += 38 * t30; // t15 left as is
              // first car

              c = 1;
              v = t0 + c + 65535;
              c = Math.floor(v / 65536);
              t0 = v - c * 65536;
              v = t1 + c + 65535;
              c = Math.floor(v / 65536);
              t1 = v - c * 65536;
              v = t2 + c + 65535;
              c = Math.floor(v / 65536);
              t2 = v - c * 65536;
              v = t3 + c + 65535;
              c = Math.floor(v / 65536);
              t3 = v - c * 65536;
              v = t4 + c + 65535;
              c = Math.floor(v / 65536);
              t4 = v - c * 65536;
              v = t5 + c + 65535;
              c = Math.floor(v / 65536);
              t5 = v - c * 65536;
              v = t6 + c + 65535;
              c = Math.floor(v / 65536);
              t6 = v - c * 65536;
              v = t7 + c + 65535;
              c = Math.floor(v / 65536);
              t7 = v - c * 65536;
              v = t8 + c + 65535;
              c = Math.floor(v / 65536);
              t8 = v - c * 65536;
              v = t9 + c + 65535;
              c = Math.floor(v / 65536);
              t9 = v - c * 65536;
              v = t10 + c + 65535;
              c = Math.floor(v / 65536);
              t10 = v - c * 65536;
              v = t11 + c + 65535;
              c = Math.floor(v / 65536);
              t11 = v - c * 65536;
              v = t12 + c + 65535;
              c = Math.floor(v / 65536);
              t12 = v - c * 65536;
              v = t13 + c + 65535;
              c = Math.floor(v / 65536);
              t13 = v - c * 65536;
              v = t14 + c + 65535;
              c = Math.floor(v / 65536);
              t14 = v - c * 65536;
              v = t15 + c + 65535;
              c = Math.floor(v / 65536);
              t15 = v - c * 65536;
              t0 += c - 1 + 37 * (c - 1); // second car

              c = 1;
              v = t0 + c + 65535;
              c = Math.floor(v / 65536);
              t0 = v - c * 65536;
              v = t1 + c + 65535;
              c = Math.floor(v / 65536);
              t1 = v - c * 65536;
              v = t2 + c + 65535;
              c = Math.floor(v / 65536);
              t2 = v - c * 65536;
              v = t3 + c + 65535;
              c = Math.floor(v / 65536);
              t3 = v - c * 65536;
              v = t4 + c + 65535;
              c = Math.floor(v / 65536);
              t4 = v - c * 65536;
              v = t5 + c + 65535;
              c = Math.floor(v / 65536);
              t5 = v - c * 65536;
              v = t6 + c + 65535;
              c = Math.floor(v / 65536);
              t6 = v - c * 65536;
              v = t7 + c + 65535;
              c = Math.floor(v / 65536);
              t7 = v - c * 65536;
              v = t8 + c + 65535;
              c = Math.floor(v / 65536);
              t8 = v - c * 65536;
              v = t9 + c + 65535;
              c = Math.floor(v / 65536);
              t9 = v - c * 65536;
              v = t10 + c + 65535;
              c = Math.floor(v / 65536);
              t10 = v - c * 65536;
              v = t11 + c + 65535;
              c = Math.floor(v / 65536);
              t11 = v - c * 65536;
              v = t12 + c + 65535;
              c = Math.floor(v / 65536);
              t12 = v - c * 65536;
              v = t13 + c + 65535;
              c = Math.floor(v / 65536);
              t13 = v - c * 65536;
              v = t14 + c + 65535;
              c = Math.floor(v / 65536);
              t14 = v - c * 65536;
              v = t15 + c + 65535;
              c = Math.floor(v / 65536);
              t15 = v - c * 65536;
              t0 += c - 1 + 37 * (c - 1);
              o[0] = t0;
              o[1] = t1;
              o[2] = t2;
              o[3] = t3;
              o[4] = t4;
              o[5] = t5;
              o[6] = t6;
              o[7] = t7;
              o[8] = t8;
              o[9] = t9;
              o[10] = t10;
              o[11] = t11;
              o[12] = t12;
              o[13] = t13;
              o[14] = t14;
              o[15] = t15;
            }

            function S(o, a) {
              M(o, a, a);
            }

            function inv25519(o, i) {
              var c = gf();
              var a;

              for (a = 0; a < 16; a++) {
                c[a] = i[a];
              }

              for (a = 253; a >= 0; a--) {
                S(c, c);
                if (a !== 2 && a !== 4) M(c, c, i);
              }

              for (a = 0; a < 16; a++) {
                o[a] = c[a];
              }
            }

            function pow2523(o, i) {
              var c = gf();
              var a;

              for (a = 0; a < 16; a++) {
                c[a] = i[a];
              }

              for (a = 250; a >= 0; a--) {
                S(c, c);
                if (a !== 1) M(c, c, i);
              }

              for (a = 0; a < 16; a++) {
                o[a] = c[a];
              }
            }

            function crypto_scalarmult(q, n, p) {
              var z = new Uint8Array(32);
              var x = new Float64Array(80),
                  r,
                  i;
              var a = gf(),
                  b = gf(),
                  c = gf(),
                  d = gf(),
                  e = gf(),
                  f = gf();

              for (i = 0; i < 31; i++) {
                z[i] = n[i];
              }

              z[31] = n[31] & 127 | 64;
              z[0] &= 248;
              unpack25519(x, p);

              for (i = 0; i < 16; i++) {
                b[i] = x[i];
                d[i] = a[i] = c[i] = 0;
              }

              a[0] = d[0] = 1;

              for (i = 254; i >= 0; --i) {
                r = z[i >>> 3] >>> (i & 7) & 1;
                sel25519(a, b, r);
                sel25519(c, d, r);
                A(e, a, c);
                Z(a, a, c);
                A(c, b, d);
                Z(b, b, d);
                S(d, e);
                S(f, a);
                M(a, c, a);
                M(c, b, e);
                A(e, a, c);
                Z(a, a, c);
                S(b, a);
                Z(c, d, f);
                M(a, c, _121665);
                A(a, a, d);
                M(c, c, a);
                M(a, d, f);
                M(d, b, x);
                S(b, e);
                sel25519(a, b, r);
                sel25519(c, d, r);
              }

              for (i = 0; i < 16; i++) {
                x[i + 16] = a[i];
                x[i + 32] = c[i];
                x[i + 48] = b[i];
                x[i + 64] = d[i];
              }

              var x32 = x.subarray(32);
              var x16 = x.subarray(16);
              inv25519(x32, x32);
              M(x16, x16, x32);
              pack25519(q, x16);
              return 0;
            }

            function crypto_scalarmult_base(q, n) {
              return crypto_scalarmult(q, n, _9);
            }

            function crypto_box_keypair(y, x) {
              randombytes(x, 32);
              return crypto_scalarmult_base(y, x);
            }

            function crypto_box_beforenm(k, y, x) {
              var s = new Uint8Array(32);
              crypto_scalarmult(s, x, y);
              return crypto_core_hsalsa20(k, _0, s, sigma);
            }

            var crypto_box_afternm = crypto_secretbox;
            var crypto_box_open_afternm = crypto_secretbox_open;

            function crypto_box(c, m, d, n, y, x) {
              var k = new Uint8Array(32);
              crypto_box_beforenm(k, y, x);
              return crypto_box_afternm(c, m, d, n, k);
            }

            function crypto_box_open(m, c, d, n, y, x) {
              var k = new Uint8Array(32);
              crypto_box_beforenm(k, y, x);
              return crypto_box_open_afternm(m, c, d, n, k);
            }

            var K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];

            function crypto_hashblocks_hl(hh, hl, m, n) {
              var wh = new Int32Array(16),
                  wl = new Int32Array(16),
                  bh0,
                  bh1,
                  bh2,
                  bh3,
                  bh4,
                  bh5,
                  bh6,
                  bh7,
                  bl0,
                  bl1,
                  bl2,
                  bl3,
                  bl4,
                  bl5,
                  bl6,
                  bl7,
                  th,
                  tl,
                  i,
                  j,
                  h,
                  l,
                  a,
                  b,
                  c,
                  d;
              var ah0 = hh[0],
                  ah1 = hh[1],
                  ah2 = hh[2],
                  ah3 = hh[3],
                  ah4 = hh[4],
                  ah5 = hh[5],
                  ah6 = hh[6],
                  ah7 = hh[7],
                  al0 = hl[0],
                  al1 = hl[1],
                  al2 = hl[2],
                  al3 = hl[3],
                  al4 = hl[4],
                  al5 = hl[5],
                  al6 = hl[6],
                  al7 = hl[7];
              var pos = 0;

              while (n >= 128) {
                for (i = 0; i < 16; i++) {
                  j = 8 * i + pos;
                  wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
                  wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
                }

                for (i = 0; i < 80; i++) {
                  bh0 = ah0;
                  bh1 = ah1;
                  bh2 = ah2;
                  bh3 = ah3;
                  bh4 = ah4;
                  bh5 = ah5;
                  bh6 = ah6;
                  bh7 = ah7;
                  bl0 = al0;
                  bl1 = al1;
                  bl2 = al2;
                  bl3 = al3;
                  bl4 = al4;
                  bl5 = al5;
                  bl6 = al6;
                  bl7 = al7; // add

                  h = ah7;
                  l = al7;
                  a = l & 0xffff;
                  b = l >>> 16;
                  c = h & 0xffff;
                  d = h >>> 16; // Sigma1

                  h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
                  l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
                  a += l & 0xffff;
                  b += l >>> 16;
                  c += h & 0xffff;
                  d += h >>> 16; // Ch

                  h = ah4 & ah5 ^ ~ah4 & ah6;
                  l = al4 & al5 ^ ~al4 & al6;
                  a += l & 0xffff;
                  b += l >>> 16;
                  c += h & 0xffff;
                  d += h >>> 16; // K

                  h = K[i * 2];
                  l = K[i * 2 + 1];
                  a += l & 0xffff;
                  b += l >>> 16;
                  c += h & 0xffff;
                  d += h >>> 16; // w

                  h = wh[i % 16];
                  l = wl[i % 16];
                  a += l & 0xffff;
                  b += l >>> 16;
                  c += h & 0xffff;
                  d += h >>> 16;
                  b += a >>> 16;
                  c += b >>> 16;
                  d += c >>> 16;
                  th = c & 0xffff | d << 16;
                  tl = a & 0xffff | b << 16; // add

                  h = th;
                  l = tl;
                  a = l & 0xffff;
                  b = l >>> 16;
                  c = h & 0xffff;
                  d = h >>> 16; // Sigma0

                  h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
                  l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
                  a += l & 0xffff;
                  b += l >>> 16;
                  c += h & 0xffff;
                  d += h >>> 16; // Maj

                  h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
                  l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
                  a += l & 0xffff;
                  b += l >>> 16;
                  c += h & 0xffff;
                  d += h >>> 16;
                  b += a >>> 16;
                  c += b >>> 16;
                  d += c >>> 16;
                  bh7 = c & 0xffff | d << 16;
                  bl7 = a & 0xffff | b << 16; // add

                  h = bh3;
                  l = bl3;
                  a = l & 0xffff;
                  b = l >>> 16;
                  c = h & 0xffff;
                  d = h >>> 16;
                  h = th;
                  l = tl;
                  a += l & 0xffff;
                  b += l >>> 16;
                  c += h & 0xffff;
                  d += h >>> 16;
                  b += a >>> 16;
                  c += b >>> 16;
                  d += c >>> 16;
                  bh3 = c & 0xffff | d << 16;
                  bl3 = a & 0xffff | b << 16;
                  ah1 = bh0;
                  ah2 = bh1;
                  ah3 = bh2;
                  ah4 = bh3;
                  ah5 = bh4;
                  ah6 = bh5;
                  ah7 = bh6;
                  ah0 = bh7;
                  al1 = bl0;
                  al2 = bl1;
                  al3 = bl2;
                  al4 = bl3;
                  al5 = bl4;
                  al6 = bl5;
                  al7 = bl6;
                  al0 = bl7;

                  if (i % 16 === 15) {
                    for (j = 0; j < 16; j++) {
                      // add
                      h = wh[j];
                      l = wl[j];
                      a = l & 0xffff;
                      b = l >>> 16;
                      c = h & 0xffff;
                      d = h >>> 16;
                      h = wh[(j + 9) % 16];
                      l = wl[(j + 9) % 16];
                      a += l & 0xffff;
                      b += l >>> 16;
                      c += h & 0xffff;
                      d += h >>> 16; // sigma0

                      th = wh[(j + 1) % 16];
                      tl = wl[(j + 1) % 16];
                      h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                      l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                      a += l & 0xffff;
                      b += l >>> 16;
                      c += h & 0xffff;
                      d += h >>> 16; // sigma1

                      th = wh[(j + 14) % 16];
                      tl = wl[(j + 14) % 16];
                      h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                      l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                      a += l & 0xffff;
                      b += l >>> 16;
                      c += h & 0xffff;
                      d += h >>> 16;
                      b += a >>> 16;
                      c += b >>> 16;
                      d += c >>> 16;
                      wh[j] = c & 0xffff | d << 16;
                      wl[j] = a & 0xffff | b << 16;
                    }
                  }
                } // add


                h = ah0;
                l = al0;
                a = l & 0xffff;
                b = l >>> 16;
                c = h & 0xffff;
                d = h >>> 16;
                h = hh[0];
                l = hl[0];
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                hh[0] = ah0 = c & 0xffff | d << 16;
                hl[0] = al0 = a & 0xffff | b << 16;
                h = ah1;
                l = al1;
                a = l & 0xffff;
                b = l >>> 16;
                c = h & 0xffff;
                d = h >>> 16;
                h = hh[1];
                l = hl[1];
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                hh[1] = ah1 = c & 0xffff | d << 16;
                hl[1] = al1 = a & 0xffff | b << 16;
                h = ah2;
                l = al2;
                a = l & 0xffff;
                b = l >>> 16;
                c = h & 0xffff;
                d = h >>> 16;
                h = hh[2];
                l = hl[2];
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                hh[2] = ah2 = c & 0xffff | d << 16;
                hl[2] = al2 = a & 0xffff | b << 16;
                h = ah3;
                l = al3;
                a = l & 0xffff;
                b = l >>> 16;
                c = h & 0xffff;
                d = h >>> 16;
                h = hh[3];
                l = hl[3];
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                hh[3] = ah3 = c & 0xffff | d << 16;
                hl[3] = al3 = a & 0xffff | b << 16;
                h = ah4;
                l = al4;
                a = l & 0xffff;
                b = l >>> 16;
                c = h & 0xffff;
                d = h >>> 16;
                h = hh[4];
                l = hl[4];
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                hh[4] = ah4 = c & 0xffff | d << 16;
                hl[4] = al4 = a & 0xffff | b << 16;
                h = ah5;
                l = al5;
                a = l & 0xffff;
                b = l >>> 16;
                c = h & 0xffff;
                d = h >>> 16;
                h = hh[5];
                l = hl[5];
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                hh[5] = ah5 = c & 0xffff | d << 16;
                hl[5] = al5 = a & 0xffff | b << 16;
                h = ah6;
                l = al6;
                a = l & 0xffff;
                b = l >>> 16;
                c = h & 0xffff;
                d = h >>> 16;
                h = hh[6];
                l = hl[6];
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                hh[6] = ah6 = c & 0xffff | d << 16;
                hl[6] = al6 = a & 0xffff | b << 16;
                h = ah7;
                l = al7;
                a = l & 0xffff;
                b = l >>> 16;
                c = h & 0xffff;
                d = h >>> 16;
                h = hh[7];
                l = hl[7];
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                hh[7] = ah7 = c & 0xffff | d << 16;
                hl[7] = al7 = a & 0xffff | b << 16;
                pos += 128;
                n -= 128;
              }

              return n;
            }

            function crypto_hash(out, m, n) {
              var hh = new Int32Array(8),
                  hl = new Int32Array(8),
                  x = new Uint8Array(256),
                  i,
                  b = n;
              hh[0] = 0x6a09e667;
              hh[1] = 0xbb67ae85;
              hh[2] = 0x3c6ef372;
              hh[3] = 0xa54ff53a;
              hh[4] = 0x510e527f;
              hh[5] = 0x9b05688c;
              hh[6] = 0x1f83d9ab;
              hh[7] = 0x5be0cd19;
              hl[0] = 0xf3bcc908;
              hl[1] = 0x84caa73b;
              hl[2] = 0xfe94f82b;
              hl[3] = 0x5f1d36f1;
              hl[4] = 0xade682d1;
              hl[5] = 0x2b3e6c1f;
              hl[6] = 0xfb41bd6b;
              hl[7] = 0x137e2179;
              crypto_hashblocks_hl(hh, hl, m, n);
              n %= 128;

              for (i = 0; i < n; i++) {
                x[i] = m[b - n + i];
              }

              x[n] = 128;
              n = 256 - 128 * (n < 112 ? 1 : 0);
              x[n - 9] = 0;
              ts64(x, n - 8, b / 0x20000000 | 0, b << 3);
              crypto_hashblocks_hl(hh, hl, x, n);

              for (i = 0; i < 8; i++) {
                ts64(out, 8 * i, hh[i], hl[i]);
              }

              return 0;
            }

            function add(p, q) {
              var a = gf(),
                  b = gf(),
                  c = gf(),
                  d = gf(),
                  e = gf(),
                  f = gf(),
                  g = gf(),
                  h = gf(),
                  t = gf();
              Z(a, p[1], p[0]);
              Z(t, q[1], q[0]);
              M(a, a, t);
              A(b, p[0], p[1]);
              A(t, q[0], q[1]);
              M(b, b, t);
              M(c, p[3], q[3]);
              M(c, c, D2);
              M(d, p[2], q[2]);
              A(d, d, d);
              Z(e, b, a);
              Z(f, d, c);
              A(g, d, c);
              A(h, b, a);
              M(p[0], e, f);
              M(p[1], h, g);
              M(p[2], g, f);
              M(p[3], e, h);
            }

            function cswap(p, q, b) {
              var i;

              for (i = 0; i < 4; i++) {
                sel25519(p[i], q[i], b);
              }
            }

            function pack(r, p) {
              var tx = gf(),
                  ty = gf(),
                  zi = gf();
              inv25519(zi, p[2]);
              M(tx, p[0], zi);
              M(ty, p[1], zi);
              pack25519(r, ty);
              r[31] ^= par25519(tx) << 7;
            }

            function scalarmult(p, q, s) {
              var b, i;
              set25519(p[0], gf0);
              set25519(p[1], gf1);
              set25519(p[2], gf1);
              set25519(p[3], gf0);

              for (i = 255; i >= 0; --i) {
                b = s[i / 8 | 0] >> (i & 7) & 1;
                cswap(p, q, b);
                add(q, p);
                add(p, p);
                cswap(p, q, b);
              }
            }

            function scalarbase(p, s) {
              var q = [gf(), gf(), gf(), gf()];
              set25519(q[0], X);
              set25519(q[1], Y);
              set25519(q[2], gf1);
              M(q[3], X, Y);
              scalarmult(p, q, s);
            }

            function crypto_sign_keypair(pk, sk, seeded) {
              var d = new Uint8Array(64);
              var p = [gf(), gf(), gf(), gf()];
              var i;
              if (!seeded) randombytes(sk, 32);
              crypto_hash(d, sk, 32);
              d[0] &= 248;
              d[31] &= 127;
              d[31] |= 64;
              scalarbase(p, d);
              pack(pk, p);

              for (i = 0; i < 32; i++) {
                sk[i + 32] = pk[i];
              }

              return 0;
            }

            var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

            function modL(r, x) {
              var carry, i, j, k;

              for (i = 63; i >= 32; --i) {
                carry = 0;

                for (j = i - 32, k = i - 12; j < k; ++j) {
                  x[j] += carry - 16 * x[i] * L[j - (i - 32)];
                  carry = x[j] + 128 >> 8;
                  x[j] -= carry * 256;
                }

                x[j] += carry;
                x[i] = 0;
              }

              carry = 0;

              for (j = 0; j < 32; j++) {
                x[j] += carry - (x[31] >> 4) * L[j];
                carry = x[j] >> 8;
                x[j] &= 255;
              }

              for (j = 0; j < 32; j++) {
                x[j] -= carry * L[j];
              }

              for (i = 0; i < 32; i++) {
                x[i + 1] += x[i] >> 8;
                r[i] = x[i] & 255;
              }
            }

            function reduce(r) {
              var x = new Float64Array(64),
                  i;

              for (i = 0; i < 64; i++) {
                x[i] = r[i];
              }

              for (i = 0; i < 64; i++) {
                r[i] = 0;
              }

              modL(r, x);
            } // Note: difference from C - smlen returned, not passed as argument.


            function crypto_sign(sm, m, n, sk) {
              var d = new Uint8Array(64),
                  h = new Uint8Array(64),
                  r = new Uint8Array(64);
              var i,
                  j,
                  x = new Float64Array(64);
              var p = [gf(), gf(), gf(), gf()];
              crypto_hash(d, sk, 32);
              d[0] &= 248;
              d[31] &= 127;
              d[31] |= 64;
              var smlen = n + 64;

              for (i = 0; i < n; i++) {
                sm[64 + i] = m[i];
              }

              for (i = 0; i < 32; i++) {
                sm[32 + i] = d[32 + i];
              }

              crypto_hash(r, sm.subarray(32), n + 32);
              reduce(r);
              scalarbase(p, r);
              pack(sm, p);

              for (i = 32; i < 64; i++) {
                sm[i] = sk[i];
              }

              crypto_hash(h, sm, n + 64);
              reduce(h);

              for (i = 0; i < 64; i++) {
                x[i] = 0;
              }

              for (i = 0; i < 32; i++) {
                x[i] = r[i];
              }

              for (i = 0; i < 32; i++) {
                for (j = 0; j < 32; j++) {
                  x[i + j] += h[i] * d[j];
                }
              }

              modL(sm.subarray(32), x);
              return smlen;
            }

            function unpackneg(r, p) {
              var t = gf(),
                  chk = gf(),
                  num = gf(),
                  den = gf(),
                  den2 = gf(),
                  den4 = gf(),
                  den6 = gf();
              set25519(r[2], gf1);
              unpack25519(r[1], p);
              S(num, r[1]);
              M(den, num, D);
              Z(num, num, r[2]);
              A(den, r[2], den);
              S(den2, den);
              S(den4, den2);
              M(den6, den4, den2);
              M(t, den6, num);
              M(t, t, den);
              pow2523(t, t);
              M(t, t, num);
              M(t, t, den);
              M(t, t, den);
              M(r[0], t, den);
              S(chk, r[0]);
              M(chk, chk, den);
              if (neq25519(chk, num)) M(r[0], r[0], I);
              S(chk, r[0]);
              M(chk, chk, den);
              if (neq25519(chk, num)) return -1;
              if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
              M(r[3], r[0], r[1]);
              return 0;
            }

            function crypto_sign_open(m, sm, n, pk) {
              var i, mlen;
              var t = new Uint8Array(32),
                  h = new Uint8Array(64);
              var p = [gf(), gf(), gf(), gf()],
                  q = [gf(), gf(), gf(), gf()];
              mlen = -1;
              if (n < 64) return -1;
              if (unpackneg(q, pk)) return -1;

              for (i = 0; i < n; i++) {
                m[i] = sm[i];
              }

              for (i = 0; i < 32; i++) {
                m[i + 32] = pk[i];
              }

              crypto_hash(h, m, n);
              reduce(h);
              scalarmult(p, q, h);
              scalarbase(q, sm.subarray(32));
              add(p, q);
              pack(t, p);
              n -= 64;

              if (crypto_verify_32(sm, 0, t, 0)) {
                for (i = 0; i < n; i++) {
                  m[i] = 0;
                }

                return -1;
              }

              for (i = 0; i < n; i++) {
                m[i] = sm[i + 64];
              }

              mlen = n;
              return mlen;
            }

            var crypto_secretbox_KEYBYTES = 32,
                crypto_secretbox_NONCEBYTES = 24,
                crypto_secretbox_ZEROBYTES = 32,
                crypto_secretbox_BOXZEROBYTES = 16,
                crypto_scalarmult_BYTES = 32,
                crypto_scalarmult_SCALARBYTES = 32,
                crypto_box_PUBLICKEYBYTES = 32,
                crypto_box_SECRETKEYBYTES = 32,
                crypto_box_BEFORENMBYTES = 32,
                crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
                crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
                crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
                crypto_sign_BYTES = 64,
                crypto_sign_PUBLICKEYBYTES = 32,
                crypto_sign_SECRETKEYBYTES = 64,
                crypto_sign_SEEDBYTES = 32,
                crypto_hash_BYTES = 64;
            nacl.lowlevel = {
              crypto_core_hsalsa20: crypto_core_hsalsa20,
              crypto_stream_xor: crypto_stream_xor,
              crypto_stream: crypto_stream,
              crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
              crypto_stream_salsa20: crypto_stream_salsa20,
              crypto_onetimeauth: crypto_onetimeauth,
              crypto_onetimeauth_verify: crypto_onetimeauth_verify,
              crypto_verify_16: crypto_verify_16,
              crypto_verify_32: crypto_verify_32,
              crypto_secretbox: crypto_secretbox,
              crypto_secretbox_open: crypto_secretbox_open,
              crypto_scalarmult: crypto_scalarmult,
              crypto_scalarmult_base: crypto_scalarmult_base,
              crypto_box_beforenm: crypto_box_beforenm,
              crypto_box_afternm: crypto_box_afternm,
              crypto_box: crypto_box,
              crypto_box_open: crypto_box_open,
              crypto_box_keypair: crypto_box_keypair,
              crypto_hash: crypto_hash,
              crypto_sign: crypto_sign,
              crypto_sign_keypair: crypto_sign_keypair,
              crypto_sign_open: crypto_sign_open,
              crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
              crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
              crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
              crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
              crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
              crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
              crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
              crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
              crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
              crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
              crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
              crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
              crypto_sign_BYTES: crypto_sign_BYTES,
              crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
              crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
              crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
              crypto_hash_BYTES: crypto_hash_BYTES
            };
            /* High-level API */

            function checkLengths(k, n) {
              if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
              if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
            }

            function checkBoxLengths(pk, sk) {
              if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
              if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
            }

            function checkArrayTypes() {
              for (var i = 0; i < arguments.length; i++) {
                if (!(arguments[i] instanceof Uint8Array)) throw new TypeError('unexpected type, use Uint8Array');
              }
            }

            function cleanup(arr) {
              for (var i = 0; i < arr.length; i++) {
                arr[i] = 0;
              }
            }

            nacl.randomBytes = function (n) {
              var b = new Uint8Array(n);
              randombytes(b, n);
              return b;
            };

            nacl.secretbox = function (msg, nonce, key) {
              checkArrayTypes(msg, nonce, key);
              checkLengths(key, nonce);
              var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
              var c = new Uint8Array(m.length);

              for (var i = 0; i < msg.length; i++) {
                m[i + crypto_secretbox_ZEROBYTES] = msg[i];
              }

              crypto_secretbox(c, m, m.length, nonce, key);
              return c.subarray(crypto_secretbox_BOXZEROBYTES);
            };

            nacl.secretbox.open = function (box, nonce, key) {
              checkArrayTypes(box, nonce, key);
              checkLengths(key, nonce);
              var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
              var m = new Uint8Array(c.length);

              for (var i = 0; i < box.length; i++) {
                c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
              }

              if (c.length < 32) return null;
              if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
              return m.subarray(crypto_secretbox_ZEROBYTES);
            };

            nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
            nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
            nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

            nacl.scalarMult = function (n, p) {
              checkArrayTypes(n, p);
              if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
              if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
              var q = new Uint8Array(crypto_scalarmult_BYTES);
              crypto_scalarmult(q, n, p);
              return q;
            };

            nacl.scalarMult.base = function (n) {
              checkArrayTypes(n);
              if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
              var q = new Uint8Array(crypto_scalarmult_BYTES);
              crypto_scalarmult_base(q, n);
              return q;
            };

            nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
            nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

            nacl.box = function (msg, nonce, publicKey, secretKey) {
              var k = nacl.box.before(publicKey, secretKey);
              return nacl.secretbox(msg, nonce, k);
            };

            nacl.box.before = function (publicKey, secretKey) {
              checkArrayTypes(publicKey, secretKey);
              checkBoxLengths(publicKey, secretKey);
              var k = new Uint8Array(crypto_box_BEFORENMBYTES);
              crypto_box_beforenm(k, publicKey, secretKey);
              return k;
            };

            nacl.box.after = nacl.secretbox;

            nacl.box.open = function (msg, nonce, publicKey, secretKey) {
              var k = nacl.box.before(publicKey, secretKey);
              return nacl.secretbox.open(msg, nonce, k);
            };

            nacl.box.open.after = nacl.secretbox.open;

            nacl.box.keyPair = function () {
              var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
              var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
              crypto_box_keypair(pk, sk);
              return {
                publicKey: pk,
                secretKey: sk
              };
            };

            nacl.box.keyPair.fromSecretKey = function (secretKey) {
              checkArrayTypes(secretKey);
              if (secretKey.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
              var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
              crypto_scalarmult_base(pk, secretKey);
              return {
                publicKey: pk,
                secretKey: new Uint8Array(secretKey)
              };
            };

            nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
            nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
            nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
            nacl.box.nonceLength = crypto_box_NONCEBYTES;
            nacl.box.overheadLength = nacl.secretbox.overheadLength;

            nacl.sign = function (msg, secretKey) {
              checkArrayTypes(msg, secretKey);
              if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error('bad secret key size');
              var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
              crypto_sign(signedMsg, msg, msg.length, secretKey);
              return signedMsg;
            };

            nacl.sign.open = function (signedMsg, publicKey) {
              checkArrayTypes(signedMsg, publicKey);
              if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error('bad public key size');
              var tmp = new Uint8Array(signedMsg.length);
              var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
              if (mlen < 0) return null;
              var m = new Uint8Array(mlen);

              for (var i = 0; i < m.length; i++) {
                m[i] = tmp[i];
              }

              return m;
            };

            nacl.sign.detached = function (msg, secretKey) {
              var signedMsg = nacl.sign(msg, secretKey);
              var sig = new Uint8Array(crypto_sign_BYTES);

              for (var i = 0; i < sig.length; i++) {
                sig[i] = signedMsg[i];
              }

              return sig;
            };

            nacl.sign.detached.verify = function (msg, sig, publicKey) {
              checkArrayTypes(msg, sig, publicKey);
              if (sig.length !== crypto_sign_BYTES) throw new Error('bad signature size');
              if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error('bad public key size');
              var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
              var m = new Uint8Array(crypto_sign_BYTES + msg.length);
              var i;

              for (i = 0; i < crypto_sign_BYTES; i++) {
                sm[i] = sig[i];
              }

              for (i = 0; i < msg.length; i++) {
                sm[i + crypto_sign_BYTES] = msg[i];
              }

              return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
            };

            nacl.sign.keyPair = function () {
              var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
              var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
              crypto_sign_keypair(pk, sk);
              return {
                publicKey: pk,
                secretKey: sk
              };
            };

            nacl.sign.keyPair.fromSecretKey = function (secretKey) {
              checkArrayTypes(secretKey);
              if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error('bad secret key size');
              var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);

              for (var i = 0; i < pk.length; i++) {
                pk[i] = secretKey[32 + i];
              }

              return {
                publicKey: pk,
                secretKey: new Uint8Array(secretKey)
              };
            };

            nacl.sign.keyPair.fromSeed = function (seed) {
              checkArrayTypes(seed);
              if (seed.length !== crypto_sign_SEEDBYTES) throw new Error('bad seed size');
              var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
              var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);

              for (var i = 0; i < 32; i++) {
                sk[i] = seed[i];
              }

              crypto_sign_keypair(pk, sk, true);
              return {
                publicKey: pk,
                secretKey: sk
              };
            };

            nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
            nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
            nacl.sign.seedLength = crypto_sign_SEEDBYTES;
            nacl.sign.signatureLength = crypto_sign_BYTES;

            nacl.hash = function (msg) {
              checkArrayTypes(msg);
              var h = new Uint8Array(crypto_hash_BYTES);
              crypto_hash(h, msg, msg.length);
              return h;
            };

            nacl.hash.hashLength = crypto_hash_BYTES;

            nacl.verify = function (x, y) {
              checkArrayTypes(x, y); // Zero length arguments are considered not equal.

              if (x.length === 0 || y.length === 0) return false;
              if (x.length !== y.length) return false;
              return vn(x, 0, y, 0, x.length) === 0 ? true : false;
            };

            nacl.setPRNG = function (fn) {
              randombytes = fn;
            };

            (function () {
              // Initialize PRNG if environment provides CSPRNG.
              // If not, methods calling randombytes will throw.
              var crypto = typeof self !== 'undefined' ? self.crypto || self.msCrypto : null;

              if (crypto && crypto.getRandomValues) {
                // Browsers.
                var QUOTA = 65536;
                nacl.setPRNG(function (x, n) {
                  var i,
                      v = new Uint8Array(n);

                  for (i = 0; i < n; i += QUOTA) {
                    crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
                  }

                  for (i = 0; i < n; i++) {
                    x[i] = v[i];
                  }

                  cleanup(v);
                });
              } else {
                // Node.js.
                crypto = __webpack_require__(56);

                if (crypto && crypto.randomBytes) {
                  nacl.setPRNG(function (x, n) {
                    var i,
                        v = crypto.randomBytes(n);

                    for (i = 0; i < n; i++) {
                      x[i] = v[i];
                    }

                    cleanup(v);
                  });
                }
              }
            })();
          })(typeof module !== 'undefined' && module.exports ? module.exports : self.nacl = self.nacl || {});
          /***/

        },
        /* 56 */

        /***/
        function (module, exports) {
          /* (ignored) */

          /***/
        },
        /* 57 */

        /***/
        function (module, exports, __webpack_require__) {
          /* WEBPACK VAR INJECTION */
          (function (Buffer) {
            // Written in 2014-2016 by Dmitry Chestnykh and Devi Mandiri.
            // Public domain.
            (function (root, f) {
              if (typeof module !== 'undefined' && module.exports) module.exports = f();else if (root.nacl) root.nacl.util = f();else {
                root.nacl = {};
                root.nacl.util = f();
              }
            })(this, function () {
              var util = {};

              function validateBase64(s) {
                if (!/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(s)) {
                  throw new TypeError('invalid encoding');
                }
              }

              util.decodeUTF8 = function (s) {
                if (typeof s !== 'string') throw new TypeError('expected string');
                var i,
                    d = unescape(encodeURIComponent(s)),
                    b = new Uint8Array(d.length);

                for (i = 0; i < d.length; i++) {
                  b[i] = d.charCodeAt(i);
                }

                return b;
              };

              util.encodeUTF8 = function (arr) {
                var i,
                    s = [];

                for (i = 0; i < arr.length; i++) {
                  s.push(String.fromCharCode(arr[i]));
                }

                return decodeURIComponent(escape(s.join('')));
              };

              if (typeof atob === 'undefined') {
                // Node.js
                if (typeof Buffer.from !== 'undefined') {
                  // Node v6 and later
                  util.encodeBase64 = function (arr) {
                    // v6 and later
                    return Buffer.from(arr).toString('base64');
                  };

                  util.decodeBase64 = function (s) {
                    validateBase64(s);
                    return new Uint8Array(Array.prototype.slice.call(Buffer.from(s, 'base64'), 0));
                  };
                } else {
                  // Node earlier than v6
                  util.encodeBase64 = function (arr) {
                    // v6 and later
                    return new Buffer(arr).toString('base64');
                  };

                  util.decodeBase64 = function (s) {
                    validateBase64(s);
                    return new Uint8Array(Array.prototype.slice.call(new Buffer(s, 'base64'), 0));
                  };
                }
              } else {
                // Browsers
                util.encodeBase64 = function (arr) {
                  var i,
                      s = [],
                      len = arr.length;

                  for (i = 0; i < len; i++) {
                    s.push(String.fromCharCode(arr[i]));
                  }

                  return btoa(s.join(''));
                };

                util.decodeBase64 = function (s) {
                  validateBase64(s);
                  var i,
                      d = atob(s),
                      b = new Uint8Array(d.length);

                  for (i = 0; i < d.length; i++) {
                    b[i] = d.charCodeAt(i);
                  }

                  return b;
                };
              }

              return util;
            });
            /* WEBPACK VAR INJECTION */

          }).call(exports, __webpack_require__(58).Buffer);
          /***/
        },
        /* 58 */

        /***/
        function (module, exports, __webpack_require__) {
          var base64 = __webpack_require__(59);

          var ieee754 = __webpack_require__(60);

          var isArray = __webpack_require__(61);

          exports.Buffer = Buffer;
          exports.SlowBuffer = SlowBuffer;
          exports.INSPECT_MAX_BYTES = 50;
          /**
           * If `Buffer.TYPED_ARRAY_SUPPORT`:
           *   === true    Use Uint8Array implementation (fastest)
           *   === false   Use Object implementation (most compatible, even IE6)
           *
           * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
           * Opera 11.6+, iOS 4.2+.
           *
           * Due to various browser bugs, sometimes the Object implementation will be used even
           * when the browser supports typed arrays.
           *
           * Note:
           *
           *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
           *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
           *
           *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
           *
           *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
           *     incorrect length in some situations.
          	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
           * get the Object implementation, which is slower but behaves correctly.
           */

          Buffer.TYPED_ARRAY_SUPPORT = window.TYPED_ARRAY_SUPPORT !== undefined ? window.TYPED_ARRAY_SUPPORT : typedArraySupport();
          /*
           * Export kMaxLength after typed array support is determined.
           */

          exports.kMaxLength = kMaxLength();

          function typedArraySupport() {
            try {
              var arr = new Uint8Array(1);
              arr.__proto__ = {
                __proto__: Uint8Array.prototype,
                foo: function foo() {
                  return 42;
                }
              };
              return arr.foo() === 42 && // typed array instances can be augmented
              typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
              arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
            } catch (e) {
              return false;
            }
          }

          function kMaxLength() {
            return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
          }

          function createBuffer(that, length) {
            if (kMaxLength() < length) {
              throw new RangeError('Invalid typed array length');
            }

            if (Buffer.TYPED_ARRAY_SUPPORT) {
              // Return an augmented `Uint8Array` instance, for best performance
              that = new Uint8Array(length);
              that.__proto__ = Buffer.prototype;
            } else {
              // Fallback: Return an object instance of the Buffer class
              if (that === null) {
                that = new Buffer(length);
              }

              that.length = length;
            }

            return that;
          }
          /**
           * The Buffer constructor returns instances of `Uint8Array` that have their
           * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
           * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
           * and the `Uint8Array` methods. Square bracket notation works as expected -- it
           * returns a single octet.
           *
           * The `Uint8Array` prototype remains unmodified.
           */


          function Buffer(arg, encodingOrOffset, length) {
            if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
              return new Buffer(arg, encodingOrOffset, length);
            } // Common case.


            if (typeof arg === 'number') {
              if (typeof encodingOrOffset === 'string') {
                throw new Error('If encoding is specified then the first argument must be a string');
              }

              return allocUnsafe(this, arg);
            }

            return from(this, arg, encodingOrOffset, length);
          }

          Buffer.poolSize = 8192; // not used by this implementation
          // TODO: Legacy, not needed anymore. Remove in next major version.

          Buffer._augment = function (arr) {
            arr.__proto__ = Buffer.prototype;
            return arr;
          };

          function from(that, value, encodingOrOffset, length) {
            if (typeof value === 'number') {
              throw new TypeError('"value" argument must not be a number');
            }

            if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
              return fromArrayBuffer(that, value, encodingOrOffset, length);
            }

            if (typeof value === 'string') {
              return fromString(that, value, encodingOrOffset);
            }

            return fromObject(that, value);
          }
          /**
           * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
           * if value is a number.
           * Buffer.from(str[, encoding])
           * Buffer.from(array)
           * Buffer.from(buffer)
           * Buffer.from(arrayBuffer[, byteOffset[, length]])
           **/


          Buffer.from = function (value, encodingOrOffset, length) {
            return from(null, value, encodingOrOffset, length);
          };

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            Buffer.prototype.__proto__ = Uint8Array.prototype;
            Buffer.__proto__ = Uint8Array;

            if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
              // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
              Object.defineProperty(Buffer, Symbol.species, {
                value: null,
                configurable: true
              });
            }
          }

          function assertSize(size) {
            if (typeof size !== 'number') {
              throw new TypeError('"size" argument must be a number');
            } else if (size < 0) {
              throw new RangeError('"size" argument must not be negative');
            }
          }

          function alloc(that, size, fill, encoding) {
            assertSize(size);

            if (size <= 0) {
              return createBuffer(that, size);
            }

            if (fill !== undefined) {
              // Only pay attention to encoding if it's a string. This
              // prevents accidentally sending in a number that would
              // be interpretted as a start offset.
              return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
            }

            return createBuffer(that, size);
          }
          /**
           * Creates a new filled Buffer instance.
           * alloc(size[, fill[, encoding]])
           **/


          Buffer.alloc = function (size, fill, encoding) {
            return alloc(null, size, fill, encoding);
          };

          function allocUnsafe(that, size) {
            assertSize(size);
            that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

            if (!Buffer.TYPED_ARRAY_SUPPORT) {
              for (var i = 0; i < size; ++i) {
                that[i] = 0;
              }
            }

            return that;
          }
          /**
           * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
           * */


          Buffer.allocUnsafe = function (size) {
            return allocUnsafe(null, size);
          };
          /**
           * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
           */


          Buffer.allocUnsafeSlow = function (size) {
            return allocUnsafe(null, size);
          };

          function fromString(that, string, encoding) {
            if (typeof encoding !== 'string' || encoding === '') {
              encoding = 'utf8';
            }

            if (!Buffer.isEncoding(encoding)) {
              throw new TypeError('"encoding" must be a valid string encoding');
            }

            var length = byteLength(string, encoding) | 0;
            that = createBuffer(that, length);
            var actual = that.write(string, encoding);

            if (actual !== length) {
              // Writing a hex string, for example, that contains invalid characters will
              // cause everything after the first invalid character to be ignored. (e.g.
              // 'abxxcd' will be treated as 'ab')
              that = that.slice(0, actual);
            }

            return that;
          }

          function fromArrayLike(that, array) {
            var length = array.length < 0 ? 0 : checked(array.length) | 0;
            that = createBuffer(that, length);

            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }

            return that;
          }

          function fromArrayBuffer(that, array, byteOffset, length) {
            array.byteLength; // this throws if `array` is not a valid ArrayBuffer

            if (byteOffset < 0 || array.byteLength < byteOffset) {
              throw new RangeError('\'offset\' is out of bounds');
            }

            if (array.byteLength < byteOffset + (length || 0)) {
              throw new RangeError('\'length\' is out of bounds');
            }

            if (byteOffset === undefined && length === undefined) {
              array = new Uint8Array(array);
            } else if (length === undefined) {
              array = new Uint8Array(array, byteOffset);
            } else {
              array = new Uint8Array(array, byteOffset, length);
            }

            if (Buffer.TYPED_ARRAY_SUPPORT) {
              // Return an augmented `Uint8Array` instance, for best performance
              that = array;
              that.__proto__ = Buffer.prototype;
            } else {
              // Fallback: Return an object instance of the Buffer class
              that = fromArrayLike(that, array);
            }

            return that;
          }

          function fromObject(that, obj) {
            if (Buffer.isBuffer(obj)) {
              var len = checked(obj.length) | 0;
              that = createBuffer(that, len);

              if (that.length === 0) {
                return that;
              }

              obj.copy(that, 0, 0, len);
              return that;
            }

            if (obj) {
              if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
                if (typeof obj.length !== 'number' || isnan(obj.length)) {
                  return createBuffer(that, 0);
                }

                return fromArrayLike(that, obj);
              }

              if (obj.type === 'Buffer' && isArray(obj.data)) {
                return fromArrayLike(that, obj.data);
              }
            }

            throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
          }

          function checked(length) {
            // Note: cannot use `length < kMaxLength()` here because that fails when
            // length is NaN (which is otherwise coerced to zero.)
            if (length >= kMaxLength()) {
              throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
            }

            return length | 0;
          }

          function SlowBuffer(length) {
            if (+length != length) {
              // eslint-disable-line eqeqeq
              length = 0;
            }

            return Buffer.alloc(+length);
          }

          Buffer.isBuffer = function isBuffer(b) {
            return !!(b != null && b._isBuffer);
          };

          Buffer.compare = function compare(a, b) {
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
              throw new TypeError('Arguments must be Buffers');
            }

            if (a === b) return 0;
            var x = a.length;
            var y = b.length;

            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i];
                y = b[i];
                break;
              }
            }

            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
          };

          Buffer.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case 'hex':
              case 'utf8':
              case 'utf-8':
              case 'ascii':
              case 'latin1':
              case 'binary':
              case 'base64':
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return true;

              default:
                return false;
            }
          };

          Buffer.concat = function concat(list, length) {
            if (!isArray(list)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }

            if (list.length === 0) {
              return Buffer.alloc(0);
            }

            var i;

            if (length === undefined) {
              length = 0;

              for (i = 0; i < list.length; ++i) {
                length += list[i].length;
              }
            }

            var buffer = Buffer.allocUnsafe(length);
            var pos = 0;

            for (i = 0; i < list.length; ++i) {
              var buf = list[i];

              if (!Buffer.isBuffer(buf)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }

              buf.copy(buffer, pos);
              pos += buf.length;
            }

            return buffer;
          };

          function byteLength(string, encoding) {
            if (Buffer.isBuffer(string)) {
              return string.length;
            }

            if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
              return string.byteLength;
            }

            if (typeof string !== 'string') {
              string = '' + string;
            }

            var len = string.length;
            if (len === 0) return 0; // Use a for loop to avoid recursion

            var loweredCase = false;

            for (;;) {
              switch (encoding) {
                case 'ascii':
                case 'latin1':
                case 'binary':
                  return len;

                case 'utf8':
                case 'utf-8':
                case undefined:
                  return utf8ToBytes(string).length;

                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return len * 2;

                case 'hex':
                  return len >>> 1;

                case 'base64':
                  return base64ToBytes(string).length;

                default:
                  if (loweredCase) return utf8ToBytes(string).length; // assume utf8

                  encoding = ('' + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          }

          Buffer.byteLength = byteLength;

          function slowToString(encoding, start, end) {
            var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
            // property of a typed array.
            // This behaves neither like String nor Uint8Array in that we set start/end
            // to their upper/lower bounds if the value passed is out of range.
            // undefined is handled specially as per ECMA-262 6th Edition,
            // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

            if (start === undefined || start < 0) {
              start = 0;
            } // Return early if start > this.length. Done here to prevent potential uint32
            // coercion fail below.


            if (start > this.length) {
              return '';
            }

            if (end === undefined || end > this.length) {
              end = this.length;
            }

            if (end <= 0) {
              return '';
            } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


            end >>>= 0;
            start >>>= 0;

            if (end <= start) {
              return '';
            }

            if (!encoding) encoding = 'utf8';

            while (true) {
              switch (encoding) {
                case 'hex':
                  return hexSlice(this, start, end);

                case 'utf8':
                case 'utf-8':
                  return utf8Slice(this, start, end);

                case 'ascii':
                  return asciiSlice(this, start, end);

                case 'latin1':
                case 'binary':
                  return latin1Slice(this, start, end);

                case 'base64':
                  return base64Slice(this, start, end);

                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return utf16leSlice(this, start, end);

                default:
                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                  encoding = (encoding + '').toLowerCase();
                  loweredCase = true;
              }
            }
          } // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
          // Buffer instances.


          Buffer.prototype._isBuffer = true;

          function swap(b, n, m) {
            var i = b[n];
            b[n] = b[m];
            b[m] = i;
          }

          Buffer.prototype.swap16 = function swap16() {
            var len = this.length;

            if (len % 2 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 16-bits');
            }

            for (var i = 0; i < len; i += 2) {
              swap(this, i, i + 1);
            }

            return this;
          };

          Buffer.prototype.swap32 = function swap32() {
            var len = this.length;

            if (len % 4 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 32-bits');
            }

            for (var i = 0; i < len; i += 4) {
              swap(this, i, i + 3);
              swap(this, i + 1, i + 2);
            }

            return this;
          };

          Buffer.prototype.swap64 = function swap64() {
            var len = this.length;

            if (len % 8 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 64-bits');
            }

            for (var i = 0; i < len; i += 8) {
              swap(this, i, i + 7);
              swap(this, i + 1, i + 6);
              swap(this, i + 2, i + 5);
              swap(this, i + 3, i + 4);
            }

            return this;
          };

          Buffer.prototype.toString = function toString() {
            var length = this.length | 0;
            if (length === 0) return '';
            if (arguments.length === 0) return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
          };

          Buffer.prototype.equals = function equals(b) {
            if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
            if (this === b) return true;
            return Buffer.compare(this, b) === 0;
          };

          Buffer.prototype.inspect = function inspect() {
            var str = '';
            var max = exports.INSPECT_MAX_BYTES;

            if (this.length > 0) {
              str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
              if (this.length > max) str += ' ... ';
            }

            return '<Buffer ' + str + '>';
          };

          Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
            if (!Buffer.isBuffer(target)) {
              throw new TypeError('Argument must be a Buffer');
            }

            if (start === undefined) {
              start = 0;
            }

            if (end === undefined) {
              end = target ? target.length : 0;
            }

            if (thisStart === undefined) {
              thisStart = 0;
            }

            if (thisEnd === undefined) {
              thisEnd = this.length;
            }

            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
              throw new RangeError('out of range index');
            }

            if (thisStart >= thisEnd && start >= end) {
              return 0;
            }

            if (thisStart >= thisEnd) {
              return -1;
            }

            if (start >= end) {
              return 1;
            }

            start >>>= 0;
            end >>>= 0;
            thisStart >>>= 0;
            thisEnd >>>= 0;
            if (this === target) return 0;
            var x = thisEnd - thisStart;
            var y = end - start;
            var len = Math.min(x, y);
            var thisCopy = this.slice(thisStart, thisEnd);
            var targetCopy = target.slice(start, end);

            for (var i = 0; i < len; ++i) {
              if (thisCopy[i] !== targetCopy[i]) {
                x = thisCopy[i];
                y = targetCopy[i];
                break;
              }
            }

            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
          }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
          // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
          //
          // Arguments:
          // - buffer - a Buffer to search
          // - val - a string, Buffer, or number
          // - byteOffset - an index into `buffer`; will be clamped to an int32
          // - encoding - an optional encoding, relevant is val is a string
          // - dir - true for indexOf, false for lastIndexOf


          function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
            // Empty buffer means no match
            if (buffer.length === 0) return -1; // Normalize byteOffset

            if (typeof byteOffset === 'string') {
              encoding = byteOffset;
              byteOffset = 0;
            } else if (byteOffset > 0x7fffffff) {
              byteOffset = 0x7fffffff;
            } else if (byteOffset < -0x80000000) {
              byteOffset = -0x80000000;
            }

            byteOffset = +byteOffset; // Coerce to Number.

            if (isNaN(byteOffset)) {
              // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
              byteOffset = dir ? 0 : buffer.length - 1;
            } // Normalize byteOffset: negative offsets start from the end of the buffer


            if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

            if (byteOffset >= buffer.length) {
              if (dir) return -1;else byteOffset = buffer.length - 1;
            } else if (byteOffset < 0) {
              if (dir) byteOffset = 0;else return -1;
            } // Normalize val


            if (typeof val === 'string') {
              val = Buffer.from(val, encoding);
            } // Finally, search either indexOf (if dir is true) or lastIndexOf


            if (Buffer.isBuffer(val)) {
              // Special case: looking for empty string/buffer always fails
              if (val.length === 0) {
                return -1;
              }

              return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
            } else if (typeof val === 'number') {
              val = val & 0xFF; // Search for a byte value [0-255]

              if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
                if (dir) {
                  return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                } else {
                  return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                }
              }

              return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
            }

            throw new TypeError('val must be string, number or Buffer');
          }

          function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
            var indexSize = 1;
            var arrLength = arr.length;
            var valLength = val.length;

            if (encoding !== undefined) {
              encoding = String(encoding).toLowerCase();

              if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
                if (arr.length < 2 || val.length < 2) {
                  return -1;
                }

                indexSize = 2;
                arrLength /= 2;
                valLength /= 2;
                byteOffset /= 2;
              }
            }

            function read(buf, i) {
              if (indexSize === 1) {
                return buf[i];
              } else {
                return buf.readUInt16BE(i * indexSize);
              }
            }

            var i;

            if (dir) {
              var foundIndex = -1;

              for (i = byteOffset; i < arrLength; i++) {
                if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                  if (foundIndex === -1) foundIndex = i;
                  if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                } else {
                  if (foundIndex !== -1) i -= i - foundIndex;
                  foundIndex = -1;
                }
              }
            } else {
              if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

              for (i = byteOffset; i >= 0; i--) {
                var found = true;

                for (var j = 0; j < valLength; j++) {
                  if (read(arr, i + j) !== read(val, j)) {
                    found = false;
                    break;
                  }
                }

                if (found) return i;
              }
            }

            return -1;
          }

          Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1;
          };

          Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
          };

          Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
          };

          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;

            if (!length) {
              length = remaining;
            } else {
              length = Number(length);

              if (length > remaining) {
                length = remaining;
              }
            } // must be an even number of digits


            var strLen = string.length;
            if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

            if (length > strLen / 2) {
              length = strLen / 2;
            }

            for (var i = 0; i < length; ++i) {
              var parsed = parseInt(string.substr(i * 2, 2), 16);
              if (isNaN(parsed)) return i;
              buf[offset + i] = parsed;
            }

            return i;
          }

          function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
          }

          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
          }

          function latin1Write(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
          }

          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
          }

          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
          }

          Buffer.prototype.write = function write(string, offset, length, encoding) {
            // Buffer#write(string)
            if (offset === undefined) {
              encoding = 'utf8';
              length = this.length;
              offset = 0; // Buffer#write(string, encoding)
            } else if (length === undefined && typeof offset === 'string') {
              encoding = offset;
              length = this.length;
              offset = 0; // Buffer#write(string, offset[, length][, encoding])
            } else if (isFinite(offset)) {
              offset = offset | 0;

              if (isFinite(length)) {
                length = length | 0;
                if (encoding === undefined) encoding = 'utf8';
              } else {
                encoding = length;
                length = undefined;
              } // legacy write(string, encoding, offset, length) - remove in v0.13

            } else {
              throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
            }

            var remaining = this.length - offset;
            if (length === undefined || length > remaining) length = remaining;

            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
              throw new RangeError('Attempt to write outside buffer bounds');
            }

            if (!encoding) encoding = 'utf8';
            var loweredCase = false;

            for (;;) {
              switch (encoding) {
                case 'hex':
                  return hexWrite(this, string, offset, length);

                case 'utf8':
                case 'utf-8':
                  return utf8Write(this, string, offset, length);

                case 'ascii':
                  return asciiWrite(this, string, offset, length);

                case 'latin1':
                case 'binary':
                  return latin1Write(this, string, offset, length);

                case 'base64':
                  // Warning: maxLength not taken into account in base64Write
                  return base64Write(this, string, offset, length);

                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return ucs2Write(this, string, offset, length);

                default:
                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                  encoding = ('' + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          };

          Buffer.prototype.toJSON = function toJSON() {
            return {
              type: 'Buffer',
              data: Array.prototype.slice.call(this._arr || this, 0)
            };
          };

          function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
              return base64.fromByteArray(buf);
            } else {
              return base64.fromByteArray(buf.slice(start, end));
            }
          }

          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];
            var i = start;

            while (i < end) {
              var firstByte = buf[i];
              var codePoint = null;
              var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

              if (i + bytesPerSequence <= end) {
                var secondByte, thirdByte, fourthByte, tempCodePoint;

                switch (bytesPerSequence) {
                  case 1:
                    if (firstByte < 0x80) {
                      codePoint = firstByte;
                    }

                    break;

                  case 2:
                    secondByte = buf[i + 1];

                    if ((secondByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

                      if (tempCodePoint > 0x7F) {
                        codePoint = tempCodePoint;
                      }
                    }

                    break;

                  case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];

                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

                      if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                        codePoint = tempCodePoint;
                      }
                    }

                    break;

                  case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];

                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

                      if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                        codePoint = tempCodePoint;
                      }
                    }

                }
              }

              if (codePoint === null) {
                // we did not generate a valid codePoint so insert a
                // replacement char (U+FFFD) and advance only 1 byte
                codePoint = 0xFFFD;
                bytesPerSequence = 1;
              } else if (codePoint > 0xFFFF) {
                // encode to utf16 (surrogate pair dance)
                codePoint -= 0x10000;
                res.push(codePoint >>> 10 & 0x3FF | 0xD800);
                codePoint = 0xDC00 | codePoint & 0x3FF;
              }

              res.push(codePoint);
              i += bytesPerSequence;
            }

            return decodeCodePointsArray(res);
          } // Based on http://stackoverflow.com/a/22747272/680742, the browser with
          // the lowest limit is Chrome, with 0x10000 args.
          // We go 1 magnitude less, for safety


          var MAX_ARGUMENTS_LENGTH = 0x1000;

          function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;

            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
            } // Decode in chunks to avoid "call stack size exceeded".


            var res = '';
            var i = 0;

            while (i < len) {
              res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
            }

            return res;
          }

          function asciiSlice(buf, start, end) {
            var ret = '';
            end = Math.min(buf.length, end);

            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i] & 0x7F);
            }

            return ret;
          }

          function latin1Slice(buf, start, end) {
            var ret = '';
            end = Math.min(buf.length, end);

            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i]);
            }

            return ret;
          }

          function hexSlice(buf, start, end) {
            var len = buf.length;
            if (!start || start < 0) start = 0;
            if (!end || end < 0 || end > len) end = len;
            var out = '';

            for (var i = start; i < end; ++i) {
              out += toHex(buf[i]);
            }

            return out;
          }

          function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = '';

            for (var i = 0; i < bytes.length; i += 2) {
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }

            return res;
          }

          Buffer.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === undefined ? len : ~~end;

            if (start < 0) {
              start += len;
              if (start < 0) start = 0;
            } else if (start > len) {
              start = len;
            }

            if (end < 0) {
              end += len;
              if (end < 0) end = 0;
            } else if (end > len) {
              end = len;
            }

            if (end < start) end = start;
            var newBuf;

            if (Buffer.TYPED_ARRAY_SUPPORT) {
              newBuf = this.subarray(start, end);
              newBuf.__proto__ = Buffer.prototype;
            } else {
              var sliceLen = end - start;
              newBuf = new Buffer(sliceLen, undefined);

              for (var i = 0; i < sliceLen; ++i) {
                newBuf[i] = this[i + start];
              }
            }

            return newBuf;
          };
          /*
           * Need to make sure that buffer isn't trying to write out of bounds.
           */


          function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
            if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
          }

          Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;

            while (++i < byteLength && (mul *= 0x100)) {
              val += this[offset + i] * mul;
            }

            return val;
          };

          Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;

            if (!noAssert) {
              checkOffset(offset, byteLength, this.length);
            }

            var val = this[offset + --byteLength];
            var mul = 1;

            while (byteLength > 0 && (mul *= 0x100)) {
              val += this[offset + --byteLength] * mul;
            }

            return val;
          };

          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 1, this.length);
            return this[offset];
          };

          Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
          };

          Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
          };

          Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
          };

          Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
          };

          Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;

            while (++i < byteLength && (mul *= 0x100)) {
              val += this[offset + i] * mul;
            }

            mul *= 0x80;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength);
            return val;
          };

          Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var i = byteLength;
            var mul = 1;
            var val = this[offset + --i];

            while (i > 0 && (mul *= 0x100)) {
              val += this[offset + --i] * mul;
            }

            mul *= 0x80;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength);
            return val;
          };

          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 1, this.length);
            if (!(this[offset] & 0x80)) return this[offset];
            return (0xff - this[offset] + 1) * -1;
          };

          Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return val & 0x8000 ? val | 0xFFFF0000 : val;
          };

          Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return val & 0x8000 ? val | 0xFFFF0000 : val;
          };

          Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
          };

          Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
          };

          Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
          };

          Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
          };

          Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
          };

          Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
          };

          function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length) throw new RangeError('Index out of range');
          }

          Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            byteLength = byteLength | 0;

            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength) - 1;
              checkInt(this, value, offset, byteLength, maxBytes, 0);
            }

            var mul = 1;
            var i = 0;
            this[offset] = value & 0xFF;

            while (++i < byteLength && (mul *= 0x100)) {
              this[offset + i] = value / mul & 0xFF;
            }

            return offset + byteLength;
          };

          Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            byteLength = byteLength | 0;

            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength) - 1;
              checkInt(this, value, offset, byteLength, maxBytes, 0);
            }

            var i = byteLength - 1;
            var mul = 1;
            this[offset + i] = value & 0xFF;

            while (--i >= 0 && (mul *= 0x100)) {
              this[offset + i] = value / mul & 0xFF;
            }

            return offset + byteLength;
          };

          Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
            this[offset] = value & 0xff;
            return offset + 1;
          };

          function objectWriteUInt16(buf, value, offset, littleEndian) {
            if (value < 0) value = 0xffff + value + 1;

            for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
              buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
            }
          }

          Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 0xff;
              this[offset + 1] = value >>> 8;
            } else {
              objectWriteUInt16(this, value, offset, true);
            }

            return offset + 2;
          };

          Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 8;
              this[offset + 1] = value & 0xff;
            } else {
              objectWriteUInt16(this, value, offset, false);
            }

            return offset + 2;
          };

          function objectWriteUInt32(buf, value, offset, littleEndian) {
            if (value < 0) value = 0xffffffff + value + 1;

            for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
              buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
            }
          }

          Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset + 3] = value >>> 24;
              this[offset + 2] = value >>> 16;
              this[offset + 1] = value >>> 8;
              this[offset] = value & 0xff;
            } else {
              objectWriteUInt32(this, value, offset, true);
            }

            return offset + 4;
          };

          Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 0xff;
            } else {
              objectWriteUInt32(this, value, offset, false);
            }

            return offset + 4;
          };

          Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;

            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1);
              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }

            var i = 0;
            var mul = 1;
            var sub = 0;
            this[offset] = value & 0xFF;

            while (++i < byteLength && (mul *= 0x100)) {
              if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                sub = 1;
              }

              this[offset + i] = (value / mul >> 0) - sub & 0xFF;
            }

            return offset + byteLength;
          };

          Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;

            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1);
              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }

            var i = byteLength - 1;
            var mul = 1;
            var sub = 0;
            this[offset + i] = value & 0xFF;

            while (--i >= 0 && (mul *= 0x100)) {
              if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                sub = 1;
              }

              this[offset + i] = (value / mul >> 0) - sub & 0xFF;
            }

            return offset + byteLength;
          };

          Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
            if (value < 0) value = 0xff + value + 1;
            this[offset] = value & 0xff;
            return offset + 1;
          };

          Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 0xff;
              this[offset + 1] = value >>> 8;
            } else {
              objectWriteUInt16(this, value, offset, true);
            }

            return offset + 2;
          };

          Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 8;
              this[offset + 1] = value & 0xff;
            } else {
              objectWriteUInt16(this, value, offset, false);
            }

            return offset + 2;
          };

          Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 0xff;
              this[offset + 1] = value >>> 8;
              this[offset + 2] = value >>> 16;
              this[offset + 3] = value >>> 24;
            } else {
              objectWriteUInt32(this, value, offset, true);
            }

            return offset + 4;
          };

          Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
            if (value < 0) value = 0xffffffff + value + 1;

            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 0xff;
            } else {
              objectWriteUInt32(this, value, offset, false);
            }

            return offset + 4;
          };

          function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length) throw new RangeError('Index out of range');
            if (offset < 0) throw new RangeError('Index out of range');
          }

          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
            }

            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
          }

          Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
          };

          Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
          };

          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
            }

            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
          }

          Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
          };

          Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
          }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


          Buffer.prototype.copy = function copy(target, targetStart, start, end) {
            if (!start) start = 0;
            if (!end && end !== 0) end = this.length;
            if (targetStart >= target.length) targetStart = target.length;
            if (!targetStart) targetStart = 0;
            if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

            if (end === start) return 0;
            if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

            if (targetStart < 0) {
              throw new RangeError('targetStart out of bounds');
            }

            if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
            if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

            if (end > this.length) end = this.length;

            if (target.length - targetStart < end - start) {
              end = target.length - targetStart + start;
            }

            var len = end - start;
            var i;

            if (this === target && start < targetStart && targetStart < end) {
              // descending copy from end
              for (i = len - 1; i >= 0; --i) {
                target[i + targetStart] = this[i + start];
              }
            } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
              // ascending copy from start
              for (i = 0; i < len; ++i) {
                target[i + targetStart] = this[i + start];
              }
            } else {
              Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
            }

            return len;
          }; // Usage:
          //    buffer.fill(number[, offset[, end]])
          //    buffer.fill(buffer[, offset[, end]])
          //    buffer.fill(string[, offset[, end]][, encoding])


          Buffer.prototype.fill = function fill(val, start, end, encoding) {
            // Handle string cases:
            if (typeof val === 'string') {
              if (typeof start === 'string') {
                encoding = start;
                start = 0;
                end = this.length;
              } else if (typeof end === 'string') {
                encoding = end;
                end = this.length;
              }

              if (val.length === 1) {
                var code = val.charCodeAt(0);

                if (code < 256) {
                  val = code;
                }
              }

              if (encoding !== undefined && typeof encoding !== 'string') {
                throw new TypeError('encoding must be a string');
              }

              if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                throw new TypeError('Unknown encoding: ' + encoding);
              }
            } else if (typeof val === 'number') {
              val = val & 255;
            } // Invalid ranges are not set to a default, so can range check early.


            if (start < 0 || this.length < start || this.length < end) {
              throw new RangeError('Out of range index');
            }

            if (end <= start) {
              return this;
            }

            start = start >>> 0;
            end = end === undefined ? this.length : end >>> 0;
            if (!val) val = 0;
            var i;

            if (typeof val === 'number') {
              for (i = start; i < end; ++i) {
                this[i] = val;
              }
            } else {
              var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
              var len = bytes.length;

              for (i = 0; i < end - start; ++i) {
                this[i + start] = bytes[i % len];
              }
            }

            return this;
          }; // HELPER FUNCTIONS
          // ================


          var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

          function base64clean(str) {
            // Node strips out invalid characters like \n and \t from the string, base64-js does not
            str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

            if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

            while (str.length % 4 !== 0) {
              str = str + '=';
            }

            return str;
          }

          function stringtrim(str) {
            if (str.trim) return str.trim();
            return str.replace(/^\s+|\s+$/g, '');
          }

          function toHex(n) {
            if (n < 16) return '0' + n.toString(16);
            return n.toString(16);
          }

          function utf8ToBytes(string, units) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];

            for (var i = 0; i < length; ++i) {
              codePoint = string.charCodeAt(i); // is surrogate component

              if (codePoint > 0xD7FF && codePoint < 0xE000) {
                // last char was a lead
                if (!leadSurrogate) {
                  // no lead yet
                  if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                  } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                  } // valid lead


                  leadSurrogate = codePoint;
                  continue;
                } // 2 leads in a row


                if (codePoint < 0xDC00) {
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                  leadSurrogate = codePoint;
                  continue;
                } // valid surrogate pair


                codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
              } else if (leadSurrogate) {
                // valid bmp char, but last char was a lead
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              }

              leadSurrogate = null; // encode utf8

              if (codePoint < 0x80) {
                if ((units -= 1) < 0) break;
                bytes.push(codePoint);
              } else if (codePoint < 0x800) {
                if ((units -= 2) < 0) break;
                bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
              } else if (codePoint < 0x10000) {
                if ((units -= 3) < 0) break;
                bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
              } else if (codePoint < 0x110000) {
                if ((units -= 4) < 0) break;
                bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
              } else {
                throw new Error('Invalid code point');
              }
            }

            return bytes;
          }

          function asciiToBytes(str) {
            var byteArray = [];

            for (var i = 0; i < str.length; ++i) {
              // Node's code seems to be doing this and not & 0x7F..
              byteArray.push(str.charCodeAt(i) & 0xFF);
            }

            return byteArray;
          }

          function utf16leToBytes(str, units) {
            var c, hi, lo;
            var byteArray = [];

            for (var i = 0; i < str.length; ++i) {
              if ((units -= 2) < 0) break;
              c = str.charCodeAt(i);
              hi = c >> 8;
              lo = c % 256;
              byteArray.push(lo);
              byteArray.push(hi);
            }

            return byteArray;
          }

          function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
          }

          function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; ++i) {
              if (i + offset >= dst.length || i >= src.length) break;
              dst[i + offset] = src[i];
            }

            return i;
          }

          function isnan(val) {
            return val !== val; // eslint-disable-line no-self-compare
          }
          /***/

        },
        /* 59 */

        /***/
        function (module, exports) {
          exports.byteLength = byteLength;
          exports.toByteArray = toByteArray;
          exports.fromByteArray = fromByteArray;
          var lookup = [];
          var revLookup = [];
          var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
          var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

          for (var i = 0, len = code.length; i < len; ++i) {
            lookup[i] = code[i];
            revLookup[code.charCodeAt(i)] = i;
          } // Support decoding URL-safe base64 strings, as Node.js does.
          // See: https://en.wikipedia.org/wiki/Base64#URL_applications


          revLookup['-'.charCodeAt(0)] = 62;
          revLookup['_'.charCodeAt(0)] = 63;

          function getLens(b64) {
            var len = b64.length;

            if (len % 4 > 0) {
              throw new Error('Invalid string. Length must be a multiple of 4');
            } // Trim off extra bytes after placeholder bytes are found
            // See: https://github.com/beatgammit/base64-js/issues/42


            var validLen = b64.indexOf('=');
            if (validLen === -1) validLen = len;
            var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
            return [validLen, placeHoldersLen];
          } // base64 is 4/3 + up to two characters of the original data


          function byteLength(b64) {
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
          }

          function _byteLength(b64, validLen, placeHoldersLen) {
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
          }

          function toByteArray(b64) {
            var tmp;
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
            var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

            var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

            for (var i = 0; i < len; i += 4) {
              tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
              arr[curByte++] = tmp >> 16 & 0xFF;
              arr[curByte++] = tmp >> 8 & 0xFF;
              arr[curByte++] = tmp & 0xFF;
            }

            if (placeHoldersLen === 2) {
              tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
              arr[curByte++] = tmp & 0xFF;
            }

            if (placeHoldersLen === 1) {
              tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
              arr[curByte++] = tmp >> 8 & 0xFF;
              arr[curByte++] = tmp & 0xFF;
            }

            return arr;
          }

          function tripletToBase64(num) {
            return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
          }

          function encodeChunk(uint8, start, end) {
            var tmp;
            var output = [];

            for (var i = start; i < end; i += 3) {
              tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
              output.push(tripletToBase64(tmp));
            }

            return output.join('');
          }

          function fromByteArray(uint8) {
            var tmp;
            var len = uint8.length;
            var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

            var parts = [];
            var maxChunkLength = 16383; // must be multiple of 3
            // go through the array every three bytes, we'll deal with trailing stuff later

            for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
              parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
            } // pad the end with zeros, but make sure to not forget the extra bytes


            if (extraBytes === 1) {
              tmp = uint8[len - 1];
              parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
            } else if (extraBytes === 2) {
              tmp = (uint8[len - 2] << 8) + uint8[len - 1];
              parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
            }

            return parts.join('');
          }
          /***/

        },
        /* 60 */

        /***/
        function (module, exports) {
          exports.read = function (buffer, offset, isLE, mLen, nBytes) {
            var e, m;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var nBits = -7;
            var i = isLE ? nBytes - 1 : 0;
            var d = isLE ? -1 : 1;
            var s = buffer[offset + i];
            i += d;
            e = s & (1 << -nBits) - 1;
            s >>= -nBits;
            nBits += eLen;

            for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

            m = e & (1 << -nBits) - 1;
            e >>= -nBits;
            nBits += mLen;

            for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

            if (e === 0) {
              e = 1 - eBias;
            } else if (e === eMax) {
              return m ? NaN : (s ? -1 : 1) * Infinity;
            } else {
              m = m + Math.pow(2, mLen);
              e = e - eBias;
            }

            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
          };

          exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
            var i = isLE ? 0 : nBytes - 1;
            var d = isLE ? 1 : -1;
            var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
            value = Math.abs(value);

            if (isNaN(value) || value === Infinity) {
              m = isNaN(value) ? 1 : 0;
              e = eMax;
            } else {
              e = Math.floor(Math.log(value) / Math.LN2);

              if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
              }

              if (e + eBias >= 1) {
                value += rt / c;
              } else {
                value += rt * Math.pow(2, 1 - eBias);
              }

              if (value * c >= 2) {
                e++;
                c /= 2;
              }

              if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
              } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
              } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
              }
            }

            for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

            e = e << mLen | m;
            eLen += mLen;

            for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

            buffer[offset + i - d] |= s * 128;
          };
          /***/

        },
        /* 61 */

        /***/
        function (module, exports) {
          var toString = {}.toString;

          module.exports = Array.isArray || function (arr) {
            return toString.call(arr) == '[object Array]';
          };
          /***/

        },
        /* 62 */

        /***/
        function (module, exports, __webpack_require__) {
          var __extends = this && this.__extends || function (d, b) {
            for (var p in b) {
              if (b.hasOwnProperty(p)) d[p] = b[p];
            }

            function __() {
              this.constructor = d;
            }

            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };

          var dispatcher_1 = __webpack_require__(24);

          var timers_1 = __webpack_require__(12);

          var logger_1 = __webpack_require__(8);

          var Collections = __webpack_require__(9);

          var runtime_1 = __webpack_require__(2);

          var ConnectionManager = function (_super) {
            __extends(ConnectionManager, _super);

            function ConnectionManager(key, options) {
              var _this = this;

              _super.call(this);

              this.key = key;
              this.options = options || {};
              this.state = "initialized";
              this.connection = null;
              this.usingTLS = !!options.useTLS;
              this.timeline = this.options.timeline;
              this.errorCallbacks = this.buildErrorCallbacks();
              this.connectionCallbacks = this.buildConnectionCallbacks(this.errorCallbacks);
              this.handshakeCallbacks = this.buildHandshakeCallbacks(this.errorCallbacks);
              var Network = runtime_1["default"].getNetwork();
              Network.bind("online", function () {
                _this.timeline.info({
                  netinfo: "online"
                });

                if (_this.state === "connecting" || _this.state === "unavailable") {
                  _this.retryIn(0);
                }
              });
              Network.bind("offline", function () {
                _this.timeline.info({
                  netinfo: "offline"
                });

                if (_this.connection) {
                  _this.sendActivityCheck();
                }
              });
              this.updateStrategy();
            }

            ConnectionManager.prototype.connect = function () {
              if (this.connection || this.runner) {
                return;
              }

              if (!this.strategy.isSupported()) {
                this.updateState("failed");
                return;
              }

              this.updateState("connecting");
              this.startConnecting();
              this.setUnavailableTimer();
            };

            ConnectionManager.prototype.send = function (data) {
              if (this.connection) {
                return this.connection.send(data);
              } else {
                return false;
              }
            };

            ConnectionManager.prototype.send_event = function (name, data, channel) {
              if (this.connection) {
                return this.connection.send_event(name, data, channel);
              } else {
                return false;
              }
            };

            ConnectionManager.prototype.disconnect = function () {
              this.disconnectInternally();
              this.updateState("disconnected");
            };

            ConnectionManager.prototype.isUsingTLS = function () {
              return this.usingTLS;
            };

            ConnectionManager.prototype.startConnecting = function () {
              var _this = this;

              var callback = function callback(error, handshake) {
                if (error) {
                  _this.runner = _this.strategy.connect(0, callback);
                } else {
                  if (handshake.action === "error") {
                    _this.emit("error", {
                      type: "HandshakeError",
                      error: handshake.error
                    });

                    _this.timeline.error({
                      handshakeError: handshake.error
                    });
                  } else {
                    _this.abortConnecting();

                    _this.handshakeCallbacks[handshake.action](handshake);
                  }
                }
              };

              this.runner = this.strategy.connect(0, callback);
            };

            ConnectionManager.prototype.abortConnecting = function () {
              if (this.runner) {
                this.runner.abort();
                this.runner = null;
              }
            };

            ConnectionManager.prototype.disconnectInternally = function () {
              this.abortConnecting();
              this.clearRetryTimer();
              this.clearUnavailableTimer();

              if (this.connection) {
                var connection = this.abandonConnection();
                connection.close();
              }
            };

            ConnectionManager.prototype.updateStrategy = function () {
              this.strategy = this.options.getStrategy({
                key: this.key,
                timeline: this.timeline,
                useTLS: this.usingTLS
              });
            };

            ConnectionManager.prototype.retryIn = function (delay) {
              var _this = this;

              this.timeline.info({
                action: "retry",
                delay: delay
              });

              if (delay > 0) {
                this.emit("connecting_in", Math.round(delay / 1000));
              }

              this.retryTimer = new timers_1.OneOffTimer(delay || 0, function () {
                _this.disconnectInternally();

                _this.connect();
              });
            };

            ConnectionManager.prototype.clearRetryTimer = function () {
              if (this.retryTimer) {
                this.retryTimer.ensureAborted();
                this.retryTimer = null;
              }
            };

            ConnectionManager.prototype.setUnavailableTimer = function () {
              var _this = this;

              this.unavailableTimer = new timers_1.OneOffTimer(this.options.unavailableTimeout, function () {
                _this.updateState("unavailable");
              });
            };

            ConnectionManager.prototype.clearUnavailableTimer = function () {
              if (this.unavailableTimer) {
                this.unavailableTimer.ensureAborted();
              }
            };

            ConnectionManager.prototype.sendActivityCheck = function () {
              var _this = this;

              this.stopActivityCheck();
              this.connection.ping();
              this.activityTimer = new timers_1.OneOffTimer(this.options.pongTimeout, function () {
                _this.timeline.error({
                  pong_timed_out: _this.options.pongTimeout
                });

                _this.retryIn(0);
              });
            };

            ConnectionManager.prototype.resetActivityCheck = function () {
              var _this = this;

              this.stopActivityCheck();

              if (this.connection && !this.connection.handlesActivityChecks()) {
                this.activityTimer = new timers_1.OneOffTimer(this.activityTimeout, function () {
                  _this.sendActivityCheck();
                });
              }
            };

            ConnectionManager.prototype.stopActivityCheck = function () {
              if (this.activityTimer) {
                this.activityTimer.ensureAborted();
              }
            };

            ConnectionManager.prototype.buildConnectionCallbacks = function (errorCallbacks) {
              var _this = this;

              return Collections.extend({}, errorCallbacks, {
                message: function message(_message) {
                  _this.resetActivityCheck();

                  _this.emit('message', _message);
                },
                ping: function ping() {
                  _this.send_event('pusher:pong', {});
                },
                activity: function activity() {
                  _this.resetActivityCheck();
                },
                error: function error(_error2) {
                  _this.emit("error", {
                    type: "WebSocketError",
                    error: _error2
                  });
                },
                closed: function closed() {
                  _this.abandonConnection();

                  if (_this.shouldRetry()) {
                    _this.retryIn(1000);
                  }
                }
              });
            };

            ConnectionManager.prototype.buildHandshakeCallbacks = function (errorCallbacks) {
              var _this = this;

              return Collections.extend({}, errorCallbacks, {
                connected: function connected(handshake) {
                  _this.activityTimeout = Math.min(_this.options.activityTimeout, handshake.activityTimeout, handshake.connection.activityTimeout || Infinity);

                  _this.clearUnavailableTimer();

                  _this.setConnection(handshake.connection);

                  _this.socket_id = _this.connection.id;

                  _this.updateState("connected", {
                    socket_id: _this.socket_id
                  });
                }
              });
            };

            ConnectionManager.prototype.buildErrorCallbacks = function () {
              var _this = this;

              var withErrorEmitted = function withErrorEmitted(callback) {
                return function (result) {
                  if (result.error) {
                    _this.emit("error", {
                      type: "WebSocketError",
                      error: result.error
                    });
                  }

                  callback(result);
                };
              };

              return {
                tls_only: withErrorEmitted(function () {
                  _this.usingTLS = true;

                  _this.updateStrategy();

                  _this.retryIn(0);
                }),
                refused: withErrorEmitted(function () {
                  _this.disconnect();
                }),
                backoff: withErrorEmitted(function () {
                  _this.retryIn(1000);
                }),
                retry: withErrorEmitted(function () {
                  _this.retryIn(0);
                })
              };
            };

            ConnectionManager.prototype.setConnection = function (connection) {
              this.connection = connection;

              for (var event in this.connectionCallbacks) {
                this.connection.bind(event, this.connectionCallbacks[event]);
              }

              this.resetActivityCheck();
            };

            ConnectionManager.prototype.abandonConnection = function () {
              if (!this.connection) {
                return;
              }

              this.stopActivityCheck();

              for (var event in this.connectionCallbacks) {
                this.connection.unbind(event, this.connectionCallbacks[event]);
              }

              var connection = this.connection;
              this.connection = null;
              return connection;
            };

            ConnectionManager.prototype.updateState = function (newState, data) {
              var previousState = this.state;
              this.state = newState;

              if (previousState !== newState) {
                var newStateDescription = newState;

                if (newStateDescription === "connected") {
                  newStateDescription += " with new socket ID " + data.socket_id;
                }

                logger_1["default"].debug('State changed', previousState + ' -> ' + newStateDescription);
                this.timeline.info({
                  state: newState,
                  params: data
                });
                this.emit('state_change', {
                  previous: previousState,
                  current: newState
                });
                this.emit(newState, data);
              }
            };

            ConnectionManager.prototype.shouldRetry = function () {
              return this.state === "connecting" || this.state === "connected";
            };

            return ConnectionManager;
          }(dispatcher_1["default"]);

          exports.__esModule = true;
          exports["default"] = ConnectionManager;
          /***/
        },
        /* 63 */

        /***/
        function (module, exports, __webpack_require__) {
          var Collections = __webpack_require__(9);

          var factory_1 = __webpack_require__(43);

          var Errors = __webpack_require__(31);

          var Channels = function () {
            function Channels() {
              this.channels = {};
            }

            Channels.prototype.add = function (name, pusher) {
              if (!this.channels[name]) {
                this.channels[name] = createChannel(name, pusher);
              }

              return this.channels[name];
            };

            Channels.prototype.all = function () {
              return Collections.values(this.channels);
            };

            Channels.prototype.find = function (name) {
              return this.channels[name];
            };

            Channels.prototype.remove = function (name) {
              var channel = this.channels[name];
              delete this.channels[name];
              return channel;
            };

            Channels.prototype.disconnect = function () {
              Collections.objectApply(this.channels, function (channel) {
                channel.disconnect();
              });
            };

            return Channels;
          }();

          exports.__esModule = true;
          exports["default"] = Channels;

          function createChannel(name, pusher) {
            if (name.indexOf('private-encrypted-') === 0) {
              if (navigator.product == "ReactNative") {
                var errorMsg = "Encrypted channels are not yet supported when using React Native builds.";
                throw new Errors.UnsupportedFeature(errorMsg);
              }

              return factory_1["default"].createEncryptedChannel(name, pusher);
            } else if (name.indexOf('private-') === 0) {
              return factory_1["default"].createPrivateChannel(name, pusher);
            } else if (name.indexOf('presence-') === 0) {
              return factory_1["default"].createPresenceChannel(name, pusher);
            } else {
              return factory_1["default"].createChannel(name, pusher);
            }
          }
          /***/

        },
        /* 64 */

        /***/
        function (module, exports, __webpack_require__) {
          var factory_1 = __webpack_require__(43);

          var util_1 = __webpack_require__(11);

          var Errors = __webpack_require__(31);

          var Collections = __webpack_require__(9);

          var TransportStrategy = function () {
            function TransportStrategy(name, priority, transport, options) {
              this.name = name;
              this.priority = priority;
              this.transport = transport;
              this.options = options || {};
            }

            TransportStrategy.prototype.isSupported = function () {
              return this.transport.isSupported({
                useTLS: this.options.useTLS
              });
            };

            TransportStrategy.prototype.connect = function (minPriority, callback) {
              var _this = this;

              if (!this.isSupported()) {
                return failAttempt(new Errors.UnsupportedStrategy(), callback);
              } else if (this.priority < minPriority) {
                return failAttempt(new Errors.TransportPriorityTooLow(), callback);
              }

              var connected = false;
              var transport = this.transport.createConnection(this.name, this.priority, this.options.key, this.options);
              var handshake = null;

              var onInitialized = function onInitialized() {
                transport.unbind("initialized", onInitialized);
                transport.connect();
              };

              var onOpen = function onOpen() {
                handshake = factory_1["default"].createHandshake(transport, function (result) {
                  connected = true;
                  unbindListeners();
                  callback(null, result);
                });
              };

              var onError = function onError(error) {
                unbindListeners();
                callback(error);
              };

              var onClosed = function onClosed() {
                unbindListeners();
                var serializedTransport;
                serializedTransport = Collections.safeJSONStringify(transport);
                callback(new Errors.TransportClosed(serializedTransport));
              };

              var unbindListeners = function unbindListeners() {
                transport.unbind("initialized", onInitialized);
                transport.unbind("open", onOpen);
                transport.unbind("error", onError);
                transport.unbind("closed", onClosed);
              };

              transport.bind("initialized", onInitialized);
              transport.bind("open", onOpen);
              transport.bind("error", onError);
              transport.bind("closed", onClosed);
              transport.initialize();
              return {
                abort: function abort() {
                  if (connected) {
                    return;
                  }

                  unbindListeners();

                  if (handshake) {
                    handshake.close();
                  } else {
                    transport.close();
                  }
                },
                forceMinPriority: function forceMinPriority(p) {
                  if (connected) {
                    return;
                  }

                  if (_this.priority < p) {
                    if (handshake) {
                      handshake.close();
                    } else {
                      transport.close();
                    }
                  }
                }
              };
            };

            return TransportStrategy;
          }();

          exports.__esModule = true;
          exports["default"] = TransportStrategy;

          function failAttempt(error, callback) {
            util_1["default"].defer(function () {
              callback(error);
            });
            return {
              abort: function abort() {},
              forceMinPriority: function forceMinPriority() {}
            };
          }
          /***/

        },
        /* 65 */

        /***/
        function (module, exports, __webpack_require__) {
          var Collections = __webpack_require__(9);

          var util_1 = __webpack_require__(11);

          var timers_1 = __webpack_require__(12);

          var SequentialStrategy = function () {
            function SequentialStrategy(strategies, options) {
              this.strategies = strategies;
              this.loop = Boolean(options.loop);
              this.failFast = Boolean(options.failFast);
              this.timeout = options.timeout;
              this.timeoutLimit = options.timeoutLimit;
            }

            SequentialStrategy.prototype.isSupported = function () {
              return Collections.any(this.strategies, util_1["default"].method("isSupported"));
            };

            SequentialStrategy.prototype.connect = function (minPriority, callback) {
              var _this = this;

              var strategies = this.strategies;
              var current = 0;
              var timeout = this.timeout;
              var runner = null;

              var tryNextStrategy = function tryNextStrategy(error, handshake) {
                if (handshake) {
                  callback(null, handshake);
                } else {
                  current = current + 1;

                  if (_this.loop) {
                    current = current % strategies.length;
                  }

                  if (current < strategies.length) {
                    if (timeout) {
                      timeout = timeout * 2;

                      if (_this.timeoutLimit) {
                        timeout = Math.min(timeout, _this.timeoutLimit);
                      }
                    }

                    runner = _this.tryStrategy(strategies[current], minPriority, {
                      timeout: timeout,
                      failFast: _this.failFast
                    }, tryNextStrategy);
                  } else {
                    callback(true);
                  }
                }
              };

              runner = this.tryStrategy(strategies[current], minPriority, {
                timeout: timeout,
                failFast: this.failFast
              }, tryNextStrategy);
              return {
                abort: function abort() {
                  runner.abort();
                },
                forceMinPriority: function forceMinPriority(p) {
                  minPriority = p;

                  if (runner) {
                    runner.forceMinPriority(p);
                  }
                }
              };
            };

            SequentialStrategy.prototype.tryStrategy = function (strategy, minPriority, options, callback) {
              var timer = null;
              var runner = null;

              if (options.timeout > 0) {
                timer = new timers_1.OneOffTimer(options.timeout, function () {
                  runner.abort();
                  callback(true);
                });
              }

              runner = strategy.connect(minPriority, function (error, handshake) {
                if (error && timer && timer.isRunning() && !options.failFast) {
                  return;
                }

                if (timer) {
                  timer.ensureAborted();
                }

                callback(error, handshake);
              });
              return {
                abort: function abort() {
                  if (timer) {
                    timer.ensureAborted();
                  }

                  runner.abort();
                },
                forceMinPriority: function forceMinPriority(p) {
                  runner.forceMinPriority(p);
                }
              };
            };

            return SequentialStrategy;
          }();

          exports.__esModule = true;
          exports["default"] = SequentialStrategy;
          /***/
        },
        /* 66 */

        /***/
        function (module, exports, __webpack_require__) {
          var Collections = __webpack_require__(9);

          var util_1 = __webpack_require__(11);

          var BestConnectedEverStrategy = function () {
            function BestConnectedEverStrategy(strategies) {
              this.strategies = strategies;
            }

            BestConnectedEverStrategy.prototype.isSupported = function () {
              return Collections.any(this.strategies, util_1["default"].method("isSupported"));
            };

            BestConnectedEverStrategy.prototype.connect = function (minPriority, callback) {
              return connect(this.strategies, minPriority, function (i, runners) {
                return function (error, handshake) {
                  runners[i].error = error;

                  if (error) {
                    if (allRunnersFailed(runners)) {
                      callback(true);
                    }

                    return;
                  }

                  Collections.apply(runners, function (runner) {
                    runner.forceMinPriority(handshake.transport.priority);
                  });
                  callback(null, handshake);
                };
              });
            };

            return BestConnectedEverStrategy;
          }();

          exports.__esModule = true;
          exports["default"] = BestConnectedEverStrategy;

          function connect(strategies, minPriority, callbackBuilder) {
            var runners = Collections.map(strategies, function (strategy, i, _, rs) {
              return strategy.connect(minPriority, callbackBuilder(i, rs));
            });
            return {
              abort: function abort() {
                Collections.apply(runners, abortRunner);
              },
              forceMinPriority: function forceMinPriority(p) {
                Collections.apply(runners, function (runner) {
                  runner.forceMinPriority(p);
                });
              }
            };
          }

          function allRunnersFailed(runners) {
            return Collections.all(runners, function (runner) {
              return Boolean(runner.error);
            });
          }

          function abortRunner(runner) {
            if (!runner.error && !runner.aborted) {
              runner.abort();
              runner.aborted = true;
            }
          }
          /***/

        },
        /* 67 */

        /***/
        function (module, exports, __webpack_require__) {
          var util_1 = __webpack_require__(11);

          var runtime_1 = __webpack_require__(2);

          var sequential_strategy_1 = __webpack_require__(65);

          var Collections = __webpack_require__(9);

          var CachedStrategy = function () {
            function CachedStrategy(strategy, transports, options) {
              this.strategy = strategy;
              this.transports = transports;
              this.ttl = options.ttl || 1800 * 1000;
              this.usingTLS = options.useTLS;
              this.timeline = options.timeline;
            }

            CachedStrategy.prototype.isSupported = function () {
              return this.strategy.isSupported();
            };

            CachedStrategy.prototype.connect = function (minPriority, callback) {
              var usingTLS = this.usingTLS;
              var info = fetchTransportCache(usingTLS);
              var strategies = [this.strategy];

              if (info && info.timestamp + this.ttl >= util_1["default"].now()) {
                var transport = this.transports[info.transport];

                if (transport) {
                  this.timeline.info({
                    cached: true,
                    transport: info.transport,
                    latency: info.latency
                  });
                  strategies.push(new sequential_strategy_1["default"]([transport], {
                    timeout: info.latency * 2 + 1000,
                    failFast: true
                  }));
                }
              }

              var startTimestamp = util_1["default"].now();
              var runner = strategies.pop().connect(minPriority, function cb(error, handshake) {
                if (error) {
                  flushTransportCache(usingTLS);

                  if (strategies.length > 0) {
                    startTimestamp = util_1["default"].now();
                    runner = strategies.pop().connect(minPriority, cb);
                  } else {
                    callback(error);
                  }
                } else {
                  storeTransportCache(usingTLS, handshake.transport.name, util_1["default"].now() - startTimestamp);
                  callback(null, handshake);
                }
              });
              return {
                abort: function abort() {
                  runner.abort();
                },
                forceMinPriority: function forceMinPriority(p) {
                  minPriority = p;

                  if (runner) {
                    runner.forceMinPriority(p);
                  }
                }
              };
            };

            return CachedStrategy;
          }();

          exports.__esModule = true;
          exports["default"] = CachedStrategy;

          function getTransportCacheKey(usingTLS) {
            return "pusherTransport" + (usingTLS ? "TLS" : "NonTLS");
          }

          function fetchTransportCache(usingTLS) {
            var storage = runtime_1["default"].getLocalStorage();

            if (storage) {
              try {
                var serializedCache = storage[getTransportCacheKey(usingTLS)];

                if (serializedCache) {
                  return JSON.parse(serializedCache);
                }
              } catch (e) {
                flushTransportCache(usingTLS);
              }
            }

            return null;
          }

          function storeTransportCache(usingTLS, transport, latency) {
            var storage = runtime_1["default"].getLocalStorage();

            if (storage) {
              try {
                storage[getTransportCacheKey(usingTLS)] = Collections.safeJSONStringify({
                  timestamp: util_1["default"].now(),
                  transport: transport,
                  latency: latency
                });
              } catch (e) {}
            }
          }

          function flushTransportCache(usingTLS) {
            var storage = runtime_1["default"].getLocalStorage();

            if (storage) {
              try {
                delete storage[getTransportCacheKey(usingTLS)];
              } catch (e) {}
            }
          }
          /***/

        },
        /* 68 */

        /***/
        function (module, exports, __webpack_require__) {
          var timers_1 = __webpack_require__(12);

          var DelayedStrategy = function () {
            function DelayedStrategy(strategy, _a) {
              var number = _a.delay;
              this.strategy = strategy;
              this.options = {
                delay: number
              };
            }

            DelayedStrategy.prototype.isSupported = function () {
              return this.strategy.isSupported();
            };

            DelayedStrategy.prototype.connect = function (minPriority, callback) {
              var strategy = this.strategy;
              var runner;
              var timer = new timers_1.OneOffTimer(this.options.delay, function () {
                runner = strategy.connect(minPriority, callback);
              });
              return {
                abort: function abort() {
                  timer.ensureAborted();

                  if (runner) {
                    runner.abort();
                  }
                },
                forceMinPriority: function forceMinPriority(p) {
                  minPriority = p;

                  if (runner) {
                    runner.forceMinPriority(p);
                  }
                }
              };
            };

            return DelayedStrategy;
          }();

          exports.__esModule = true;
          exports["default"] = DelayedStrategy;
          /***/
        },
        /* 69 */

        /***/
        function (module, exports) {
          var IfStrategy = function () {
            function IfStrategy(test, trueBranch, falseBranch) {
              this.test = test;
              this.trueBranch = trueBranch;
              this.falseBranch = falseBranch;
            }

            IfStrategy.prototype.isSupported = function () {
              var branch = this.test() ? this.trueBranch : this.falseBranch;
              return branch.isSupported();
            };

            IfStrategy.prototype.connect = function (minPriority, callback) {
              var branch = this.test() ? this.trueBranch : this.falseBranch;
              return branch.connect(minPriority, callback);
            };

            return IfStrategy;
          }();

          exports.__esModule = true;
          exports["default"] = IfStrategy;
          /***/
        },
        /* 70 */

        /***/
        function (module, exports) {
          var FirstConnectedStrategy = function () {
            function FirstConnectedStrategy(strategy) {
              this.strategy = strategy;
            }

            FirstConnectedStrategy.prototype.isSupported = function () {
              return this.strategy.isSupported();
            };

            FirstConnectedStrategy.prototype.connect = function (minPriority, callback) {
              var runner = this.strategy.connect(minPriority, function (error, handshake) {
                if (handshake) {
                  runner.abort();
                }

                callback(error, handshake);
              });
              return runner;
            };

            return FirstConnectedStrategy;
          }();

          exports.__esModule = true;
          exports["default"] = FirstConnectedStrategy;
          /***/
        },
        /* 71 */

        /***/
        function (module, exports, __webpack_require__) {
          var defaults_1 = __webpack_require__(5);

          exports.getGlobalConfig = function () {
            return {
              wsHost: defaults_1["default"].host,
              wsPort: defaults_1["default"].ws_port,
              wssPort: defaults_1["default"].wss_port,
              wsPath: defaults_1["default"].ws_path,
              httpHost: defaults_1["default"].sockjs_host,
              httpPort: defaults_1["default"].sockjs_http_port,
              httpsPort: defaults_1["default"].sockjs_https_port,
              httpPath: defaults_1["default"].sockjs_path,
              statsHost: defaults_1["default"].stats_host,
              authEndpoint: defaults_1["default"].channel_auth_endpoint,
              authTransport: defaults_1["default"].channel_auth_transport,
              activity_timeout: defaults_1["default"].activity_timeout,
              pong_timeout: defaults_1["default"].pong_timeout,
              unavailable_timeout: defaults_1["default"].unavailable_timeout
            };
          };

          exports.getClusterConfig = function (clusterName) {
            return {
              wsHost: "ws-" + clusterName + ".pusher.com",
              httpHost: "sockjs-" + clusterName + ".pusher.com"
            };
          };
          /***/

        }])
      );
    });
  });
  var Pusher = unwrapExports(pusher);
  /**
   * Global environment objects. This ensures that comparisons are true between
   * object pointers. For example: ENVIRONMENTS.TESTING === Util.Environments.Testing
   *
   * @since 1.0.3
   */

  /** @ignore */

  var ProductionEnvironment = {
    environment: 'production'
  };
  /** @ignore */

  var AdministrationEnvironment = {
    environment: 'production'
  };
  /** @ignore */

  var SandboxDevEnvironment = {
    environment: 'sandbox'
  };
  /** @ignore */

  var SandboxAdministrationEnvironment = {
    environment: 'sandbox'
  };
  /** @ignore */

  var SandboxTwitchEnvironment = {
    environment: 'sandbox'
  };
  /** @ignore */

  var ServerEnvironment = {
    environment: 'server'
  };
  /** @ignore */

  var TestingEnvironment = {
    environment: 'testing'
  };
  /** @ignore */

  var StagingDevEnvironment = {
    environment: 'staging'
  };
  /** @ignore */

  var StagingAdministrationEnvironment = {
    environment: 'staging'
  };
  /** @ignore */

  var StagingTwitchEnvironment = {
    environment: 'staging'
  };
  /**
   * Possible runtime environments for the SDK.
   * @since 1.0.0
   * @deprecated Use {@link Util.Environments} instead.
   */

  /** @ignore */

  var ENVIRONMENTS = {
    ADMIN: AdministrationEnvironment,
    PRODUCTION: ProductionEnvironment,
    SANDBOX_ADMIN: SandboxAdministrationEnvironment,
    SANDBOX_DEV: SandboxDevEnvironment,
    SANDBOX_TWITCH: SandboxTwitchEnvironment,
    SERVER: ServerEnvironment,
    TESTING: TestingEnvironment,
    STAGING_ADMIN: StagingAdministrationEnvironment,
    STAGING_DEV: StagingDevEnvironment,
    STAGING_TWITCH: StagingTwitchEnvironment
  };
  /**
   * A collection of static utility functions, available at {@link Muxy.Util}.
   *
   * @example
   * const a = 'a string';
   * Muxy.Util.forceType(a, 'string');
   */

  var Util =
  /** @class */
  function () {
    function Util() {}

    Object.defineProperty(Util, "Environments", {
      /**
       * Possible runtime environments for the library. Used to define available
       * behavior and services.
       *
       * @since 1.0.3
       * @type {Object}
       */
      get: function get() {
        return {
          Admin: AdministrationEnvironment,
          Production: ProductionEnvironment,
          SandboxAdmin: SandboxAdministrationEnvironment,
          SandboxDev: SandboxDevEnvironment,
          SandboxTwitch: SandboxTwitchEnvironment,
          Server: ServerEnvironment,
          Testing: TestingEnvironment,
          StagingDev: StagingDevEnvironment,
          StagingTwitch: StagingTwitchEnvironment,
          StagingAdmin: StagingAdministrationEnvironment
        };
      },
      enumerable: true,
      configurable: true
    });
    /**
     * Wraps a string error response in an (immediately rejected) promise.
     * @since 1.0.0
     *
     * @param {string} err - A string error that the promise will reject.
     *
     * @returns {Promise<string>} Immediately rejects the returned Promise.
     */

    Util.errorPromise = function (err) {
      return Promise.reject(err);
    };
    /**
     * Returns the length of the longest line in the provided array.
     *
     * @since 1.0.0
     * @ignore
     *
     * @param {string[]} lines - An array of strings.
     */


    Util.widestLine = function (lines) {
      return Math.max.apply(null, lines.map(function (x) {
        return x.length;
      }));
    };
    /**
     * Draws a box around the lines of text provided.
     *
     * @since 1.0.0
     * @ignore
     *
     * @param {string[]} lines - An array of strings to surround.
     *
     * @returns {string} A string containing all `lines` of text surrounded
     * in an ASCII box art.
     */


    Util.asciiBox = function (lines) {
      var contentWidth = Util.widestLine(lines);
      var intro = ' '.repeat(contentWidth / 2) + "\uD83E\uDD8A";
      var out = [intro];
      out.push("\u250C" + ''.repeat(contentWidth + 2) + "\u2510");
      lines.forEach(function (line) {
        var paddingRight = ' '.repeat(contentWidth - line.length);
        out.push("| " + line + paddingRight + " |");
      });
      out.push("\u2514" + ''.repeat(contentWidth + 2) + "\u2518");
      return out;
    };
    /**
     * Checks if the current window object is running in an iframe.
     *
     * @since 1.0.0
     * @ignore
     */


    Util.isWindowFramed = function (overrideWindow) {
      var vWindow;

      if (typeof window !== 'undefined') {
        vWindow = window;
      }

      if (overrideWindow) {
        vWindow = overrideWindow;
      }

      var isNotChildWindow = !vWindow.opener; // Cannot compare WindowProxy objects with ===/!==

      var windowTop = vWindow.top && vWindow != vWindow.top; // tslint:disable-line:triple-equals

      var windowParent = vWindow.parent && vWindow != vWindow.parent; // tslint:disable-line:triple-equals

      var hasWindowAncestors = !!(windowTop || windowParent);
      return isNotChildWindow && hasWindowAncestors;
    };
    /**
     * currentEnvironment uses the hostname and available info to determine in what
     * environment the SDK is running. Possible values are available in {@link Util.Environments}.
     * @since 1.0.0
     *
     * @returns {string} Returns a string representation of the current
     * execution environment.
     */


    Util.currentEnvironment = function (overrideWindow) {
      var vWindow;

      if (typeof window !== 'undefined') {
        vWindow = window;
      }

      if (overrideWindow) {
        vWindow = overrideWindow;
      }

      if (Util.overrideEnvironment) {
        return Util.overrideEnvironment;
      }

      try {
        // NodeJS module system, assume server.
        // istanbul ignore if
        if (typeof module !== 'undefined' && module.exports && typeof vWindow === 'undefined') {
          return ENVIRONMENTS.SERVER;
        } // Not in an iframe, assume sandbox dev.


        if (!Util.isWindowFramed(vWindow)) {
          // See if we're in the admin state.
          var urlParams = new URLSearchParams(window.location.search);

          if (urlParams.get('muxyAdminInterface') || vWindow.name === 'SandboxAdmin') {
            return ENVIRONMENTS.SANDBOX_ADMIN;
          }

          return ENVIRONMENTS.SANDBOX_DEV;
        } // See if we're in the admin pane.


        if (vWindow.name === 'Admin') {
          return ENVIRONMENTS.ADMIN;
        } // See if we're in the admin state, but in an iframed context.


        var iFrameUrlParams = new URLSearchParams(window.location.search);

        if (iFrameUrlParams.get('muxyAdminInterface') || vWindow.name === 'SandboxAdmin') {
          return ENVIRONMENTS.SANDBOX_ADMIN;
        } // Loaded from Twitch's CDN, assume production.


        if (vWindow.location.origin.indexOf('.ext-twitch.tv') !== -1) {
          return ENVIRONMENTS.PRODUCTION;
        } // Not on Twitch but with their referrer, assume sandbox twitch.


        if (vWindow.document.referrer && vWindow.document.referrer.indexOf('twitch.tv') !== -1) {
          return ENVIRONMENTS.SANDBOX_TWITCH;
        } // Explicity set testing variable, assume testing.


        if (vWindow.testing) {
          return ENVIRONMENTS.TESTING;
        }
      } catch (err) {
        Util.consolePrint(err.toString(), {
          type: 'error'
        });
      } // Default, assume we're running in sandbox dev environment.


      return ENVIRONMENTS.SANDBOX_DEV;
    };
    /**
     * consolePrint prints each line of text with optional global settings and per-line
     * console flags.
     *
     * **NOTE:** Twitch's CSP enforcement disallows printing to console. This function
     * will not print anything to the console if it is running in production mode.
     *
     * @since 1.0.0
     * @public
     *
     * @param {string|string[]} lines - A single string to output, or an array of lines
     * of text. If lines is an array, each line will appear on its own line. If lines is
     * a single string, it will be split on '\n'.
     *
     * @param {object?} options - An object containing global options.
     * @param {boolean} options.boxed - If true, surrounds the output in an ASCII art box.
     * @param {string} options.style - A CSS style string to append to the console call.
     * @param {string} options.type - The type of print command. May be one of:
     * ['log', 'error', 'debug', 'info', 'warn'], although browser support may not be
     * available for all. Defaults to 'log'.
     *
     * @example
     * consolePrint('Hello World');
     *  Hello World
     *
     * consolePrint('This is a box', { boxed: true });
     *  
     *  | This is a box |
     *  
     */


    Util.consolePrint = function (lines, options) {
      if (options === void 0) {
        options = {};
      }

      if (!lines || Util.currentEnvironment() === Util.Environments.Production) {
        return;
      }

      var style = 'font-family: monospace;';
      var lineArr = Array.isArray(lines) ? lines : lines.split('\n');
      var type = options.type || 'log';

      if (options.boxed) {
        lineArr = Util.asciiBox(lineArr);
      }

      if (options.style) {
        style += options.style;
      }

      if (Util.currentEnvironment() === Util.Environments.Server) {
        console[type].call(this, lineArr.join('\n')); // eslint-disable-line no-console
      } else {
        console[type].call(this, "%c" + lineArr.join('\n'), style); // eslint-disable-line no-console
      }
    };
    /**
     * Matches an input event name with a pattern. An event name is a : delimited
     * list of terms, while a pattern is a : delimited list of terms, with an
     * optional * instead of a term. '*' will match any term.
     *
     * @since 1.0.0
     * @private
     *
     * @param {string} input - An input event name, : delimited.
     * Allowed characters are alpha-numeric and _
     * @param {string} pattern - A pattern to match against, : delimited.
     * Allowed characters are alpha-numeric and _ and *
     *
     * @return Returns true if the pattern matches the input, false otherwise.
     */


    Util.eventPatternMatch = function (input, pattern) {
      var inputParts = input.split(':');
      var patternParts = pattern.split(':');

      if (inputParts.length !== patternParts.length) {
        return false;
      }

      for (var i = 0; i < inputParts.length; i += 1) {
        if (inputParts[i] !== patternParts[i] && patternParts[i] !== '*') {
          return false;
        }
      }

      return true;
    };
    /**
     * Takes a variable and a Javascript Type identifier and throws a TypeError
     * if the variable's type is not in the provided type list. If the type check
     * passes, the function returns without error. As a convenience, the type may
     * also be an array of types.
     *
     * Acceptable types:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof
     *
     * @since 1.0.0
     * @public
     *
     * @param {any} value - Any JavaScript variable.
     * @param {string} type - A single type string, or an array of multiple types.
     *
     * @throws {TypeError} Throws if typeof value is not in the type list.
     */


    Util.forceType = function (value, type) {
      var types = [].concat(type);

      var typeString = _typeof(value);

      if (types.indexOf(typeString) === -1) {
        throw new TypeError("expected '" + typeString + "' to be one of [" + types + "]");
      }
    };
    /**
     * Returns information about the current extension environment on twitch
     *
     * @public
     *
     * @return {TwitchEnvironment}
     */


    Util.getTwitchEnvironment = function () {
      var url = new URL(window.location.search);
      var env = {
        anchor: null,
        language: null,
        mode: null,
        platform: null,
        state: null,
        version: null
      };
      var path = url.pathname;
      var splitPath = path.split('/');

      if (splitPath.length > 2) {
        env.version = splitPath[2];
      }

      var urlParams = url.searchParams;
      env.anchor = urlParams.get('anchor');
      env.language = urlParams.get('language');
      env.mode = urlParams.get('mode');
      env.platform = urlParams.get('platform');
      env.state = urlParams.get('state');
      return env;
    };
    /**
     * Attempts to parse the provided JWT and return the payload info
     *
     * @param {Object} jwt - The auth JWT token as returned from the auth harness.
     */


    Util.extractJWTInfo = function (jwt) {
      try {
        var splitToken = jwt.split('.');

        if (splitToken.length === 3) {
          return JSON.parse(window.atob(splitToken[1]));
        }
      } catch (err) {
        throw new Error('Failed to parse JWT');
      }
    };

    return Util;
  }();
  /** @ignore */


  var consolePrint = Util.consolePrint;
  /** @ignore */

  var forceType = Util.forceType;
  /** @ignore */

  var eventPatternMatch = Util.eventPatternMatch;
  /** @ignore */

  var CurrentEnvironment = Util.currentEnvironment;
  /**
   * @module SDK
   */
  // TwitchMessenger implements the basic 'messenger' interface, which should be implemented
  // for all pubsub implementations. This is used by SDK to provide low-level access
  // to a pubsub implementation.

  var TwitchMessenger =
  /** @class */
  function () {
    function TwitchMessenger(debug) {
      this.channelID = '';
      this.extensionID = '';
      this.debug = debug;
    }
    /**
     * send will send a message to all clients.
     * @param id the extension id or app id of the app thats sending the message.
     * @param event an event name. Event names should be in the form [a-z0-9_]+
     * @param either 'broadcast' or 'whisper-<opaque-user-id>'
     * @param body a json object to send
     * @param client a state-client instance. Used to make external calls.
     * The twitch messenger does not need the client, so its not shown in the signature
     * below.
     */

    /* eslint-disable class-methods-use-this */


    TwitchMessenger.prototype.send = function (id, event, target, body) {
      var data = body || {};
      this.debug.onPubsubSend(id, event, target, body);
      window.Twitch.ext.send(target, 'application/json', {
        data: data,
        event: CurrentEnvironment().environment + ":" + id + ":" + event
      });
    };
    /* eslint-enable class-methods-use-this */

    /**
     * listen is the low level listening interface.
     * @param id the extension id or app id of the app thats sending the message.
     * @param topic either `broadcast` or `whisper-<opaque-user-id>`.
     * @param callback a function(body)
     * @return a handle that can be passed into unlisten to unbind the callback.
     */

    /* eslint-disable class-methods-use-this */


    TwitchMessenger.prototype.listen = function (id, topic, callback) {
      var _this = this;

      var cb = function cb(t, datatype, message) {
        try {
          var parsed = JSON.parse(message);

          _this.debug.onPubsubReceive(id, topic, parsed);

          callback(parsed);
        } catch (err) {// TODO: Silent failure?
        }
      };

      this.debug.onPubsubListen(id, topic);
      window.Twitch.ext.listen(topic, cb);

      if (topic === 'broadcast') {
        window.Twitch.ext.listen('global', cb);
      }

      return {
        cb: cb,
        target: topic
      };
    };
    /* eslint-enable class-methods-use-this */

    /**
     * unlisten will unregister a listening callback.
     * @param id the extension id or app id of the app thats sending the message.
     * @param h the handle returned from listen
     */

    /* eslint-disable class-methods-use-this */


    TwitchMessenger.prototype.unlisten = function (id, h) {
      window.Twitch.ext.unlisten(h.target, h.cb);
    };
    /* eslint-enable class-methods-use-this */


    TwitchMessenger.prototype.close = function () {
      /* Nothing to close on Twitch */
    };

    return TwitchMessenger;
  }(); // PusherMessenger adheres to the 'messenger' interface, but uses https://pusher.com
  // as a pubsub notification provider.


  var PusherMessenger =
  /** @class */
  function () {
    function PusherMessenger(debug) {
      // @ts-ignore
      this.client = new Pusher('18c26c0d1c7fafb78ba2', {
        cluster: 'us2',
        encrypted: true
      });
      this.channelID = '';
      this.debug = debug;
    }

    PusherMessenger.prototype.send = function (id, event, target, body, client) {
      var scopedEvent = CurrentEnvironment().environment + ":" + id + ":" + event;
      this.debug.onPubsubSend(id, event, target, body);
      client.signedRequest(id, 'POST', 'pusher_broadcast', JSON.stringify({
        data: body,
        event: scopedEvent,
        target: target,
        user_id: this.channelID
      }));
    };

    PusherMessenger.prototype.listen = function (id, topic, callback) {
      var _this = this;

      if (!this.channel) {
        var channelName = "twitch.pubsub." + this.extensionID + "." + this.channelID;
        var globalName = "twitch.pubsub." + this.extensionID + ".all";
        this.channel = this.client.subscribe(channelName);
        this.globalChannel = this.client.subscribe(globalName);
      }

      var cb = function cb(message) {
        try {
          var parsed = JSON.parse(message.message);

          _this.debug.onPubsubReceive(id, topic, parsed);

          callback(parsed);
        } catch (err) {// TODO: Silent failure?
        }
      };

      this.debug.onPubsubListen(id, topic);
      this.channel.bind(topic, cb);
      this.globalChannel.bind(topic, cb);
      return {
        cb: cb,
        target: topic
      };
    };

    PusherMessenger.prototype.unlisten = function (id, h) {
      this.channel.unbind(h.target, h.cb);
      this.globalChannel.unbind(h.target, h.cb);
    };

    PusherMessenger.prototype.close = function () {
      this.client.disconnect();
    };

    return PusherMessenger;
  }(); // ServerMessenger implements a 'messenger' that is broadcast-only. It cannot
  // listen for messages, but is able to send with a backend-signed JWT.


  var ServerMessenger =
  /** @class */
  function () {
    function ServerMessenger(debug, ch) {
      this.channelID = ch;
      this.debug = debug;
    }

    ServerMessenger.prototype.send = function (id, event, target, body, client) {
      this.debug.onPubsubSend(id, event, target, body);
      client.signedRequest(id, 'POST', 'broadcast', JSON.stringify({
        data: body,
        event: event,
        target: target,
        user_id: this.channelID
      }));
    };
    /* tslint:disable:no-console */


    ServerMessenger.prototype.listen = function (id, topic, callback) {
      console.error('Server-side message receiving is not implemented.');
      return {
        cb: function cb() {
          /* Not Implemented */
        },
        target: ''
      };
    };

    ServerMessenger.prototype.unlisten = function (id, handle) {
      console.error('Server-side message receiving is not implemented.');
    };
    /* tslint:enable:no-console */


    ServerMessenger.prototype.close = function () {
      /* Nothing to close server-side. */
    };

    return ServerMessenger;
  }();

  function DefaultMessenger(debug) {
    switch (CurrentEnvironment()) {
      case ENVIRONMENTS.SANDBOX_DEV:
      case ENVIRONMENTS.ADMIN: // Currently unable to hook into the twitch pubsub system from admin

      case ENVIRONMENTS.SANDBOX_ADMIN:
      case ENVIRONMENTS.STAGING_ADMIN:
      case ENVIRONMENTS.STAGING_DEV:
        return new PusherMessenger(debug);

      case ENVIRONMENTS.SANDBOX_TWITCH:
      case ENVIRONMENTS.PRODUCTION:
      case ENVIRONMENTS.STAGING_TWITCH:
        return new TwitchMessenger(debug);

      case ENVIRONMENTS.SERVER:
        return new ServerMessenger(debug);

      default:
        throw new Error('Could not determine execution environment.');
    }
  }
  /**
   * @module SDK
   */


  var Observer =
  /** @class */
  function () {
    function Observer() {
      this.observers = [];
    }

    Observer.prototype.register = function (observer) {
      this.observers.push(observer);
    };

    Observer.prototype.unregister = function (observer) {
      var n = this.observers.indexOf(observer);
      this.observers.splice(n, 1);
    };

    Observer.prototype.notify = function (obj) {
      var i = 0;
      var max = this.observers.length;

      for (; i < max; i += 1) {
        this.observers[i].notify(obj);
      }
    };

    return Observer;
  }();

  var ObserverHandler =
  /** @class */
  function () {
    function ObserverHandler() {}

    ObserverHandler.prototype.notify = function (obj) {
      throw new Error('Abstract Method!');
    };

    return ObserverHandler;
  }();
  /**
   * @module SDK
   */
  // Twitch types


  var TwitchAuth =
  /** @class */
  function () {
    function TwitchAuth() {}

    return TwitchAuth;
  }();

  var ContextUpdateCallbackHandle =
  /** @class */
  function (_super) {
    __extends(ContextUpdateCallbackHandle, _super);

    function ContextUpdateCallbackHandle(cb) {
      var _this = _super.call(this) || this;

      _this.cb = cb;
      return _this;
    }

    ContextUpdateCallbackHandle.prototype.notify = function (context) {
      this.cb(context);
    };

    return ContextUpdateCallbackHandle;
  }(ObserverHandler);

  var DEFAULT_CONTENT_TYPE = 'application/x-www-form-urlencoded; charset=UTF-8';

  var XHRPromise =
  /** @class */
  function () {
    function XHRPromise(options) {
      if (options === void 0) {
        options = {};
      }

      this.options = {
        data: null,
        headers: {},
        method: 'GET'
      };
      Object.assign(this.options, options);
    }

    XHRPromise.prototype.send = function () {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (!XMLHttpRequest) {
          _this.handleResponse('browser', reject, null, "browser doesn't support XMLHttpRequest");

          return;
        }

        if (typeof _this.options.url !== 'string' || _this.options.url.length === 0) {
          _this.handleResponse('url', reject, null, 'URL is a required parameter');

          return;
        }

        _this.xhr = new XMLHttpRequest();

        _this.xhr.onload = function () {
          var responseText;

          try {
            responseText = _this.getResponseText();
          } catch (err) {
            _this.handleResponse('parse', reject, null, 'invalid JSON response');

            return;
          }

          return resolve({
            headers: _this.getAllResponseHeaders(),
            responseText: responseText,
            status: _this.xhr.status,
            statusText: _this.xhr.statusText,
            url: _this.getResponseURL(),
            xhr: _this.xhr
          });
        };

        _this.xhr.onerror = function () {
          return _this.handleResponse('error', reject);
        };

        _this.xhr.ontimeout = function () {
          return _this.handleResponse('timeout', reject);
        };

        _this.xhr.onabort = function () {
          return _this.handleResponse('abort', reject);
        };

        _this.xhr.open(_this.options.method, _this.options.url);

        if (_this.options.data !== null && !_this.options.headers['Content-Type']) {
          _this.options.headers['Content-Type'] = DEFAULT_CONTENT_TYPE;
        }

        var ref = _this.options.headers;

        for (var header in ref) {
          if (ref.hasOwnProperty(header)) {
            var value = ref[header];

            _this.xhr.setRequestHeader(header, value);
          }
        }

        try {
          return _this.xhr.send(_this.options.data);
        } catch (err) {
          return _this.handleResponse('send', reject, null, err.toString());
        }
      });
    };

    XHRPromise.prototype.getXHR = function () {
      return this.xhr;
    }; // Converts response headers to map.


    XHRPromise.prototype.getAllResponseHeaders = function () {
      var map = {};

      if (this.xhr.readyState !== this.xhr.HEADERS_RECEIVED) {
        return map;
      }

      var headers = this.xhr.getAllResponseHeaders();
      var arr = headers.trim().split(/[\r\n]+/);
      arr.forEach(function (header) {
        var parts = header.split(': ');
        var h = parts.shift();
        var v = parts.join(': ');
        map[h] = v;
      });
      return map;
    }; // Returns the XHR response, parsing as json if applicable.


    XHRPromise.prototype.getResponseText = function () {
      var type = (this.xhr.getResponseHeader('Content-Type') || '').split(';')[0];
      var text = typeof this.xhr.responseText === 'string' ? this.xhr.responseText : '';

      if (type === 'application/json' || type === 'text/javascript') {
        text = JSON.parse("" + text);
      }

      return text;
    };

    XHRPromise.prototype.getResponseURL = function () {
      if (this.xhr.responseURL !== null) {
        return this.xhr.responseURL;
      }

      if (/^X-Request-URL:/m.test(this.xhr.getAllResponseHeaders())) {
        return this.xhr.getResponseHeader('X-Request-URL');
      }

      return '';
    };

    XHRPromise.prototype.handleResponse = function (reason, response, status, statusText) {
      return response({
        reason: reason,
        status: status || this.xhr.status,
        statusText: statusText || this.xhr.statusText,
        xhr: this.xhr
      });
    };

    return XHRPromise;
  }();
  /**
   * @module SDK
   */

  /**
   * Muxy production API URL.
   * @ignore
   */


  var API_URL = 'https://api.muxy.io';
  /**
   * Muxy sandbox API URL.
   * @ignore
   */

  var SANDBOX_URL = 'https://sandbox.api.muxy.io';
  SANDBOX_URL = API_URL;
  /**
   * Localhost for testing purposes.
   * @ignore
   */

  var LOCALHOST_URL = 'http://localhost:5000';
  /**
   * Muxy staging API URL.
   * @ignore
   */

  var STAGING_URL = 'https://staging.api.muxy.io';
  /**
   * API URL to use for backend requests. Uses production API be default, but
   * can be updated using {@link setEnvironment}.
   * @ignore
   */

  var SERVER_URL = API_URL;
  var FAKEAUTH_URL = SANDBOX_URL;
  /**
   * ServerState enum maps the subsets of state persisted to the server to
   * their respective endpoints.
   * @ignore
   */

  var ServerState = {
    ALL: 'all_state',
    AUTHENTICATION: 'authentication',
    CHANNEL: 'channel_state',
    EXTENSION: 'extension_state',
    EXTENSION_SECRET: 'extension_hidden_state',
    EXTENSION_VIEWER: 'extension_viewer_state',
    USER: 'user_info',
    VIEWER: 'viewer_state'
  };
  /**
   * Wraps all extension backend accessor and mutator endpoints in convenience functions.
   *
   * Should not normally be created directly, instead an instance is made available
   * and namespaced appropriately when using {@link Muxy.SDK}.
   *
   * @private
   *
   * @example
   * const sdk = new Muxy.SDK();
   * sdk.getAllState().then((state) => {
   *   console.log(state);
   * });
   */

  var StateClient =
  /** @class */
  function () {
    /** @ignore */
    function StateClient(loadedPromise, debug) {
      var _this = this;
      /**
       * getState requests a subset of state stored on the server and sets the
       * local cached version of the state to the response.
       * @ignore
       */


      this.getState = function (identifier, substate) {
        return _this.signedRequest(identifier, 'GET', substate || ServerState.ALL);
      };
      /**
       * postState sends data to the current EBS substate endpoint for persistence.
       * @ignore
       */


      this.postState = function (identifier, substate, data) {
        return _this.signedRequest(identifier, 'POST', substate || ServerState.ALL, data);
      };
      /** @ignore */


      this.getUserInfo = function (identifier) {
        return _this.getState(identifier, ServerState.USER);
      };
      /** @ignore */


      this.immediateGetUserInfo = function (identifier) {
        return _this.signedRequest(identifier, 'GET', ServerState.USER, undefined, true);
      };
      /** @ignore */


      this.getViewerState = function (identifier) {
        return _this.getState(identifier, ServerState.VIEWER);
      };
      /** @ignore */


      this.getExtensionViewerState = function (identifier) {
        return _this.getState(identifier, ServerState.EXTENSION_VIEWER);
      };
      /** @ignore */


      this.getExtensionSecretState = function (identifier) {
        return _this.getState(identifier, ServerState.EXTENSION_SECRET);
      };
      /** @ignore */


      this.getChannelState = function (identifier) {
        return _this.getState(identifier, ServerState.CHANNEL);
      };
      /** @ignore */


      this.getExtensionState = function (identifier) {
        return _this.getState(identifier, ServerState.EXTENSION);
      };
      /** @ignore */


      this.setViewerState = function (identifier, state) {
        return _this.postState(identifier, ServerState.VIEWER, JSON.stringify(state));
      };
      /** @ignore */


      this.setExtensionViewerState = function (identifier, state) {
        return _this.postState(identifier, ServerState.EXTENSION_VIEWER, JSON.stringify(state));
      };
      /** @ignore */


      this.patchExtensionViewerState = function (identifier, multiState) {
        return _this.signedRequest(identifier, 'PATCH', 'extension_viewer_state', JSON.stringify(multiState));
      };
      /** @ignore */


      this.multiGetExtensionViewerState = function (identifier, users) {
        return _this.signedRequest(identifier, 'GET', "extension_viewer_state?user_ids=" + users.join(','));
      };
      /** @ignore */


      this.setExtensionSecretState = function (identifier, state) {
        return _this.postState(identifier, ServerState.EXTENSION_SECRET, JSON.stringify(state));
      };
      /** @ignore */


      this.setChannelState = function (identifier, state) {
        return _this.postState(identifier, ServerState.CHANNEL, JSON.stringify(state));
      };
      /** @ignore */


      this.setExtensionState = function (identifier, state) {
        return _this.postState(identifier, ServerState.EXTENSION, JSON.stringify(state));
      };
      /** @ignore */


      this.getAccumulation = function (identifier, id, start) {
        return _this.signedRequest(identifier, 'GET', "accumulate?id=" + (id || 'default') + "&start=" + start);
      };
      /** @ignore */


      this.accumulate = function (identifier, id, data) {
        return _this.signedRequest(identifier, 'POST', "accumulate?id=" + (id || 'default'), JSON.stringify(data));
      };
      /** @ignore */


      this.vote = function (identifier, id, data) {
        return _this.signedRequest(identifier, 'POST', "vote?id=" + (id || 'default'), JSON.stringify(data));
      };
      /** @ignore */


      this.getVotes = function (identifier, id) {
        return _this.signedRequest(identifier, 'GET', "vote?id=" + (id || 'default'));
      };
      /** @ignore */


      this.getFullVoteLogs = function (identifier, id) {
        return _this.signedRequest(identifier, 'GET', "vote_logs?id=" + (id || 'default'));
      };
      /** @ignore */


      this.rank = function (identifier, id, data) {
        return _this.signedRequest(identifier, 'POST', "rank?id=" + (id || 'default'), JSON.stringify(data));
      };
      /** @ignore */


      this.getRank = function (identifier, id) {
        if (id === void 0) {
          id = 'default';
        }

        return _this.signedRequest(identifier, 'GET', "rank?id=" + id);
      };
      /** @ignore */


      this.deleteRank = function (identifier, id) {
        return _this.signedRequest(identifier, 'DELETE', "rank?id=" + (id || 'default'));
      };
      /** @ignore */


      this.getJSONStore = function (identifier, id) {
        return _this.signedRequest(identifier, 'GET', "json_store?id=" + (id || 'default'));
      };
      /** @ignore */


      this.validateCode = function (identifier, code) {
        return _this.signedRequest(identifier, 'POST', 'validate_pin', JSON.stringify({
          pin: code
        }));
      };
      /** @ignore */


      this.pinTokenExists = function (identifier) {
        return _this.signedRequest(identifier, 'GET', 'pin_token_exists');
      };
      /** @ignore */


      this.revokeAllPINCodes = function (identifier) {
        return _this.signedRequest(identifier, 'DELETE', 'pin');
      };
      /** @ignore */


      this.getEligibleCodes = function (identifier) {
        return _this.signedRequest(identifier, 'GET', 'codes/eligible');
      };
      /** @ignore */


      this.getRedeemedCodes = function (identifier) {
        return _this.signedRequest(identifier, 'GET', 'codes/redeemed');
      };
      /** @ignore */


      this.redeemCode = function (identifier, prizeIndex) {
        return _this.signedRequest(identifier, 'POST', 'codes/redeem', JSON.stringify({
          prize: prizeIndex
        }));
      };
      /** @ignore */


      this.getExtensionUsers = function (identifier, cursor) {
        return _this.signedRequest(identifier, 'GET', "user_ids?cursor=" + (cursor || 0));
      };
      /** @ignore */


      this.joinExtensionTriviaTeam = function (identifier) {
        return _this.signedRequest(identifier, 'POST', 'team_membership');
      };
      /** @ignore */


      this.getExtensionTriviaJoinedTeam = function (identifier) {
        return _this.signedRequest(identifier, 'GET', 'team_membership');
      };
      /** @ignore */


      this.addExtensionTriviaQuestion = function (identifier, triviaQuestion) {
        return _this.signedRequest(identifier, 'POST', 'curated_poll_edit', JSON.stringify(triviaQuestion));
      };
      /** @ignore */


      this.removeExtensionTriviaQuestion = function (identifier, triviaQuestionID) {
        return _this.signedRequest(identifier, 'DELETE', 'curated_poll_edit', JSON.stringify({
          id: triviaQuestionID
        }));
      };
      /** @ignore */


      this.addExtensionTriviaOptionToQuestion = function (identifier, questionID, option) {
        return _this.signedRequest(identifier, 'POST', 'curated_poll_edit_option', JSON.stringify({
          question: questionID,
          option: option
        }));
      };
      /** @ignore */


      this.removeExtensionTriviaOptionFromQuestion = function (identifier, questionID, optionID) {
        return _this.signedRequest(identifier, 'DELETE', 'curated_poll_edit_option', JSON.stringify({
          question: questionID,
          option: optionID
        }));
      };
      /** @ignore */


      this.setExtensionTriviaQuestionState = function (identifier, questionID, state, winner) {
        return _this.signedRequest(identifier, 'POST', "curated_poll_state?id=" + questionID, JSON.stringify({
          transition: state,
          winner: winner
        }));
      };
      /** @ignore */


      this.setExtensionTriviaQuestionVote = function (identifier, questionID, optionID) {
        return _this.signedRequest(identifier, 'POST', 'curated_poll', JSON.stringify({
          question_id: questionID,
          vote: optionID
        }));
      };
      /** @ignore */


      this.getExtensionTriviaQuestions = function (identifier) {
        return _this.signedRequest(identifier, 'GET', 'curated_poll');
      };
      /** @ignore */


      this.getExtensionTriviaQuestion = function (identifier, questionID) {
        return _this.signedRequest(identifier, 'GET', "curated_poll?id=" + questionID);
      };
      /** @ignore */


      this.getExtensionTriviaLeaderboard = function (identifer) {
        return _this.signedRequest(identifer, 'GET', 'curated_poll_leaderboard');
      };
      /** @ignore */


      this.token = null;
      this.debug = debug;
      this.loaded = loadedPromise;
    }
    /** @ignore */


    StateClient.fetchTestAuth = function (extensionID, debug) {
      var _this = this;

      var data = JSON.stringify({
        app_id: extensionID,
        channel_id: debug.channelID,
        role: debug.role,
        user_id: debug.userID || '12345678'
      });
      var xhr = new XHRPromise({
        data: data,
        headers: {
          'Content-Type': 'application/json'
        },
        method: 'POST',
        url: (debug.url || SANDBOX_URL) + "/v1/e/authtoken?role=" + debug.role // pass roll as a param for fixtures

      });
      return xhr.send().then(function (resp) {
        if (resp && resp.status < 400) {
          _this.setEnvironment(null, debug); // Update the API Server variable to point to test


          var auth = Object.assign(new TwitchAuth(), resp.responseText, {
            channelId: debug.channelID,
            clientId: extensionID,
            userId: debug.userID ? "U" + debug.userID : 'U12345678'
          });
          return Promise.resolve(auth);
        } else {
          return Promise.reject(resp.statusText);
        }
      });
    };
    /** @ignore */


    StateClient.setEnvironment = function (env, debug) {
      if (env === ENVIRONMENTS.SANDBOX_DEV || env === ENVIRONMENTS.SANDBOX_TWITCH || env === ENVIRONMENTS.SANDBOX_ADMIN) {
        SERVER_URL = SANDBOX_URL;
      }

      if (env === ENVIRONMENTS.STAGING_DEV || env === ENVIRONMENTS.STAGING_TWITCH) {
        SERVER_URL = STAGING_URL;
        FAKEAUTH_URL = STAGING_URL;
      }

      if (env === ENVIRONMENTS.TESTING) {
        SERVER_URL = LOCALHOST_URL;
        FAKEAUTH_URL = LOCALHOST_URL;
      }

      if (debug && debug.url) {
        SERVER_URL = debug.url;
        FAKEAUTH_URL = debug.url;
      }
    };
    /** @ignore */


    StateClient.prototype.updateAuth = function (token) {
      this.token = token;
    };
    /**
     * signedRequest checks that we have a valid JWT and wraps a standard AJAX
     * request to the EBS with valid auth credentials.s
     * @ignore
     */


    StateClient.prototype.signedRequest = function (extensionID, method, endpoint, data, skipPromise) {
      var _this = this;

      var waitedPromise = this.loaded;

      if (skipPromise) {
        waitedPromise = Promise.resolve();
      }

      return waitedPromise.then(function () {
        if (!_this.validateJWT()) {
          return Promise.reject('Your authentication token has expired.');
        }

        var xhrPromise = new XHRPromise({
          data: data,
          headers: {
            Authorization: extensionID + " " + _this.token
          },
          method: method,
          url: SERVER_URL + "/v1/e/" + endpoint
        });
        return xhrPromise.send().then(function (resp) {
          try {
            if (resp.status < 400) {
              return Promise.resolve(resp.responseText);
            } else if (resp.responseText) {
              return Promise.reject(resp.responseText);
            } else {
              return Promise.reject("Server returned status " + resp.status);
            }
          } catch (err) {
            return Promise.reject(err);
          }
        });
      });
    };
    /**
     * validateJWT ensures that the current JWT is valid and not expired.
     * @ignore
     */


    StateClient.prototype.validateJWT = function () {
      try {
        var splitToken = this.token.split('.');

        if (splitToken.length !== 3) {
          return false;
        }

        var tk = JSON.parse(atob(splitToken[1]));

        if (!tk.exp) {
          return false;
        }

        var now = new Date().valueOf();

        if (tk.exp < now / 1000) {
          return false;
        }

        return true;
      } catch (err) {
        return false;
      }
    };

    return StateClient;
  }(); // 25 minutes between updates of the testing auth token.


  var TEST_AUTH_TIMEOUT_MS = 25 * 60 * 1000; // Only process context callbacks once every 30 seconds.

  var CONTEXT_CALLBACK_TIMEOUT = 30 * 1000; // Wrapper around global Twitch extension object.

  var Ext =
  /** @class */
  function () {
    function Ext() {}

    Ext.fetchTestAuth = function (opts, cb) {
      StateClient.fetchTestAuth(this.extensionID, opts).then(function (auth) {
        cb(auth);
      }).catch(cb);
    };

    Ext.fetchAdminAuth = function (debug, cb) {
      var _this = this;

      var allowedOrigins = ['^https://dev\\.staging.muxy\\.io$', '^https://dev\\.muxy\\.io$', '^https?://localhost']; // Show that we're ready to receive.

      var connectionAttempts = 0;
      var connection = setInterval(function () {
        connectionAttempts++; // Once we've tried 60 times, back off on attempting to once every 1.5 seconds or so.

        if (connectionAttempts > 60) {
          if (connectionAttempts % 10 !== 0) {
            return;
          }
        }

        window.parent.postMessage({
          type: 'connect',
          id: _this.extensionID
        }, '*');
      }, 150);
      window.addEventListener('message', function (auth) {
        var allowed = false;
        allowedOrigins.forEach(function (origin) {
          var r = new RegExp(origin);

          if (r.test(auth.origin)) {
            allowed = true;
          }
        });

        if (!allowed) {
          return;
        }

        if (auth.data.type === 'jwt') {
          StateClient.setEnvironment(null, debug);
          var resp = Object.assign(new TwitchAuth(), {
            channelId: debug.channelID,
            clientId: _this.extensionID,
            token: auth.data.jwt,
            userId: debug.userID || 'T12345678'
          });
          clearInterval(connection);
          return cb(resp);
        }
      });
    };

    Ext.onAuthorized = function (opts, cb) {
      if (opts.jwt) {
        var auth_1 = this.authFromJWT(opts.jwt);
        return setTimeout(function () {
          StateClient.setEnvironment(null, opts);
          cb(auth_1);
        });
      }

      switch (CurrentEnvironment()) {
        case ENVIRONMENTS.SANDBOX_DEV:
        case ENVIRONMENTS.STAGING_DEV:
          Ext.fetchTestAuth(opts, cb);
          setInterval(Ext.fetchTestAuth, TEST_AUTH_TIMEOUT_MS, opts, cb);
          break;

        case ENVIRONMENTS.SANDBOX_ADMIN:
        case ENVIRONMENTS.STAGING_ADMIN:
        case ENVIRONMENTS.ADMIN:
          Ext.fetchAdminAuth(opts, cb);
          break;

        case ENVIRONMENTS.SANDBOX_TWITCH:
        case ENVIRONMENTS.STAGING_TWITCH:
        case ENVIRONMENTS.PRODUCTION:
          {
            var timer_1 = setTimeout(cb, 1000 * 15);
            window.Twitch.ext.onAuthorized(function (auth) {
              clearTimeout(timer_1);
              StateClient.setEnvironment(null, opts);
              cb(auth);
            });
            break;
          }

        default:
          consolePrint("No authorization callback for " + CurrentEnvironment(), {
            type: 'error'
          });
      }
    };

    Ext.onContext = function (cb) {
      switch (CurrentEnvironment()) {
        case ENVIRONMENTS.SANDBOX_TWITCH:
        case ENVIRONMENTS.STAGING_TWITCH:
        case ENVIRONMENTS.PRODUCTION:
          (function setupOnContextCallback() {
            // Twitch currently (2017-08-25) has an issue where certain browser mis-configurations
            // (like having incorrect system time/timezone settings) will cause the onContext callback
            // function to fire repeatedly as quickly as possible. To deal with this issue, we
            // throttle the onContext callbacks.
            var lastContextCall = 0;
            window.Twitch.ext.onContext(function (context) {
              // Check the last time the auth callback was called and restrict.
              var diff = new Date().getTime() - lastContextCall;

              if (diff < CONTEXT_CALLBACK_TIMEOUT) {
                return;
              }

              lastContextCall = new Date().getTime();
              cb(context);
            });
          })();

          break;

        default:
      }
    };

    Ext.beginPurchase = function (sku) {
      switch (CurrentEnvironment()) {
        case ENVIRONMENTS.SANDBOX_TWITCH:
        case ENVIRONMENTS.STAGING_TWITCH:
        case ENVIRONMENTS.PRODUCTION:
          window.Twitch.ext.purchases.beginPurchase(sku);
          break;

        default:
          consolePrint("beginPurchase not supported for " + CurrentEnvironment(), {
            type: 'error'
          });
      }
    };

    Ext.getPrices = function (cb) {
      switch (CurrentEnvironment()) {
        case ENVIRONMENTS.SANDBOX_TWITCH:
        case ENVIRONMENTS.STAGING_TWITCH:
        case ENVIRONMENTS.PRODUCTION:
          window.Twitch.ext.purchases.getPrices().then(function (prices) {
            cb(prices);
          }).catch(cb);
          break;

        default:
          consolePrint("getPrices not supported for " + CurrentEnvironment(), {
            type: 'error'
          });
      }
    };

    Ext.onReloadEntitlements = function (cb) {
      switch (CurrentEnvironment()) {
        case ENVIRONMENTS.SANDBOX_TWITCH:
        case ENVIRONMENTS.STAGING_TWITCH:
        case ENVIRONMENTS.PRODUCTION:
          window.Twitch.ext.purchases.onReloadEntitlements(cb);
          break;

        default:
          consolePrint("onReloadEntitlements not supported for " + CurrentEnvironment(), {
            type: 'error'
          });
      }
    };

    Ext.onVisibilityChanged = function (callback) {
      switch (CurrentEnvironment()) {
        case ENVIRONMENTS.SANDBOX_TWITCH:
        case ENVIRONMENTS.STAGING_TWITCH:
        case ENVIRONMENTS.PRODUCTION:
          window.Twitch.ext.onVisibilityChanged(callback);
          break;

        default:
          consolePrint("onVisibilityChanged not supported for " + CurrentEnvironment(), {
            type: 'error'
          });
      }
    };

    Ext.onPositionChanged = function (callback) {
      switch (CurrentEnvironment()) {
        case ENVIRONMENTS.SANDBOX_TWITCH:
        case ENVIRONMENTS.STAGING_TWITCH:
        case ENVIRONMENTS.PRODUCTION:
          window.Twitch.ext.onPositionChanged(callback);
          break;

        default:
          consolePrint("onVisibilityChanged not supported for " + CurrentEnvironment(), {
            type: 'error'
          });
      }
    };

    Ext.authFromJWT = function (jwt) {
      var claims = JSON.parse(atob(jwt.split('.')[1]));
      var res = new TwitchAuth();
      res.token = jwt;
      res.channelId = claims.channel_id;
      res.userId = claims.user_id;
      res.clientId = Ext.extensionID;
      return res;
    };

    return Ext;
  }();

  var UserUpdateCallbackHandle =
  /** @class */
  function (_super) {
    __extends(UserUpdateCallbackHandle, _super);

    function UserUpdateCallbackHandle(cb) {
      var _this = _super.call(this) || this;

      _this.cb = cb;
      return _this;
    }

    UserUpdateCallbackHandle.prototype.notify = function (user) {
      this.cb(user);
    };

    return UserUpdateCallbackHandle;
  }(ObserverHandler);
  /**
   * Stores fields related to the current extension user, either a viewer or the broadcaster.
   * These fields are automatically updated by the SDK.
   */


  var User =
  /** @class */
  function () {
    /**
     * @since 1.0.0
     * @param {Object} auth - An auth token usable by this user for backend requests.
     */
    function User(auth) {
      /**
       * channelID holds the numeric id of the channel the user is currently watching.
       *
       * @since 1.0.0
       * @type {string}
       */
      this.channelID = auth.channelId;
      /**
       * twitchJWT holds the raw JWT response from the Twitch Extension SDK.
       *
       * @since 1.0.0
       * @type {Object}
       */

      this.twitchJWT = auth.token;
      /**
       * twitchOpaqueID is a Twitch generated ID that will uniquely identify this
       * user (if they are logged in), but does not give us access to their Twitch ID.
       *
       * @since 1.0.0
       * @type {string}
       */

      this.twitchOpaqueID = auth.userId;
      /**
       * twitchID is this viewer's actual Twitch ID. Used to coordinate access to
       * other Twitch services and across the Twitch universe. Only set if the user
       * grants access, null otherwise.
       *
       * @since 1.0.0
       * @type {null|string}
       */

      this.twitchID = null;
      /**
       * registeredWithMuxy will be true if the user has an active muxy account.
       *
       * @since 1.0.0
       * @type {boolean}
       */

      this.registeredWithMuxy = false;
      /**
       * muxyID is this viewer's ID on Muxy. Null if the user has not authenticated with
       * Muxy or is not sharing their Twitch ID with the extension.
       *
       * @since 1.0.0
       * @type {null|string}
       */

      this.muxyID = null;
      /**
       * visualizationID is a unique user string that can be used to identify this user
       * on Muxy's a.muxy.io subdomain. This is used for things like alerts and
       * cheer visualizations, but is not generally useful. Empty string if
       * `registeredWithMuxy` is false.
       *
       * @since 1.0.0
       * @type {string}
       */

      this.visualizationID = '';
      /**
       * role is the current user's role in the extension. May be one of {@link Roles}.
       *
       * @since 1.0.0
       * @type {string}
       */

      this.role = User.Roles.Viewer;
      /**
       * ip is the current user's IP address. May be an empty string if undetectable.
       *
       * @since 1.0.0
       * @type {string}
       */

      this.ip = '';
      /**
       * game is the title of the current channel's game as set by the broadcaster.
       *
       * @since 1.0.0
       * @type {string}
       */

      this.game = '';
      /**
       * User's current video mode. One of {@link VideoModes}.
       *
       * @since 1.0.0
       * @type {string}
       */

      this.videoMode = User.VideoModes.Default;
      /**
       * Current video bitrate. Null if no video or unknown.
       *
       * @since 1.0.0
       * @type {null|number}
       */

      this.bitrate = null;
      /**
       * Current video latency. Null if no video or unknown.
       *
       * @since 1.0.0
       * @type {null|number}
       */

      this.latency = null;
      /**
       * Current buffer size of the viewer's player. Null if no video or unknown.
       *
       * @since 1.0.0
       * @type {null|number}
       */

      this.buffer = null;
      /**
       * Current theme the user has selected on twitch. Null if unknown, otherwise "light" or "dark"
       * @type {null|string}
       */

      this.theme = null;
      /**
       * Current volume level of the Twitch video player. Values between 0 and 1.
       * @type {number}
       */

      this.volume = 0; // If the user has authorized an extension to see their Twitch ID, it will be
      // hidden in the JWT payload.

      this.extractJWTInfo(auth.token);
      /**
       * Offset of this user from the server time.
       * @private
       */

      this.timeOffset = 0;
    }

    Object.defineProperty(User, "Roles", {
      /**
       * Defines the current user's role on Twitch relative to the current channel being
       * viewed. May be "viewer" if the user is simply viewing the channel, "moderator"
       * if the user is a moderator of the channel or "broadcaster" if the user is also
       * the broadcaster of the channel.
       *
       * @since 1.0.3
       */
      get: function get() {
        return {
          Broadcaster: 'broadcaster',
          Moderator: 'moderator',
          Viewer: 'viewer'
        };
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(User, "VideoModes", {
      /**
       * Defines the video mode for the current user. This may be "default" for the default
       * windowed viewing experience on Twitch, "fullscreen" for the fullscreen, video-only
       * mode or "theatre" for the video full window-width.
       *
       * @since 1.0.3
       */
      get: function get() {
        return {
          Default: 'default',
          Fullscreen: 'fullscreen',
          Theatre: 'theatre'
        };
      },
      enumerable: true,
      configurable: true
    });
    /**
     * Attempts to parse the provided JWT and persist any found information in store.
     * @since 1.0.0
     *
     * @param {Object} jwt - The auth JWT token as returned from the auth harness.
     */

    User.prototype.extractJWTInfo = function (jwt) {
      try {
        var token = Util.extractJWTInfo(jwt);
        this.role = token.role;

        if (token.user_id) {
          this.twitchID = token.user_id;
        }
      } catch (err) {// Silently fail (enforcement of Twitch ID is done externally).
      }
    };
    /**
     * Returns whether or not the current extension user is anonymous.
     * Twitch defines an anonymous user as one who is not logged in to the channel
     * page running this extension, or one who has not opted-in to sharing
     * auth information with this extension.
     * @since 1.0.0
     *
     * @return {boolean} True if the user is not logged in to Twitch or has not granted
     * access to their Twitch ID.
     */


    User.prototype.anonymous = function () {
      return !this.twitchOpaqueID || this.twitchOpaqueID[0] !== 'U';
    };
    /**
     * Stores values from a new auth token in the local store.
     * @since 1.0.0
     *
     * @param {Object} auth - An auth JWT with updated user information.
     */


    User.prototype.updateAuth = function (auth) {
      this.twitchJWT = auth.token;
      this.extractJWTInfo(auth.token);
    };
    /**
     * Returns a date object that is based on the Muxy server time.
     *
     * @return {Date}
     */


    User.prototype.getOffsetDate = function () {
      return new Date(new Date().getTime() + this.timeOffset);
    };

    return User;
  }();
  /**
   * @module SDK
   */


  var TriviaQuestionState;

  (function (TriviaQuestionState) {
    // Inactive marks a poll as inactive. Only admins can see an inactive poll.
    TriviaQuestionState["Inactive"] = "state-inactive"; // Unlocked marks a poll as being visible to everyone, and open to votes.

    TriviaQuestionState["Unlocked"] = "state-unlocked"; // Unlocked marks a poll as being visible to everyone, but closed to votes. No results
    // are visible while unlocked.

    TriviaQuestionState["Locked"] = "state-locked"; // Results marks a poll as complete, and results are available.

    TriviaQuestionState["Results"] = "state-results";
  })(TriviaQuestionState || (TriviaQuestionState = {}));
  /**
   * The Muxy Extensions SDK, used to communicate with Muxy's Extension Backend Service.
   *
   * Instances of this class created through the global `Muxy` object can be used to easily
   * interact with Muxy's Extension Backend Service. It includes functionality to aggregate
   * and persist user data, set extension configuration, send analytics events and authenticate
   * broadcasters across servers and applications.
   *
   * To begin using the SDK, create a new instance by calling `const sdk = Muxy.SDK()`.
   *
   * **Note for Overlay App Developers:**
   * An instance of the Muxy SDK is automatically created for you that is namespaced to your
   * app id. You can access it in any app that imports AppMixin as `this.muxy.<method>`. The
   * methods described below behave similarly to how they would in an extension context, however
   * all data is exclusive to your app. Differences are noted in the comments to the individual
   * methods.
   */


  var SDK =
  /** @class */
  function () {
    /** @ignore */
    function SDK(id) {
      if (!mxy.setupCalled) {
        throw new Error('Muxy.setup() must be called before creating a new SDK instance');
      }

      var identifier = id || mxy.twitchClientID;

      if (!identifier) {
        return null;
      }

      if (!mxy.watchingAuth) {
        mxy.watchingAuth = true;
        mxy.watchAuth(identifier);
      }

      if (!mxy.SDKClients[identifier]) {
        this.setup(identifier, mxy.client, mxy.user, mxy.messenger, mxy.analytics, mxy.loadPromise, mxy.SKUs, mxy.debugOptions);
        mxy.SDKClients[identifier] = this;
      }

      return mxy.SDKClients[identifier];
    }
    /**
     * Returns a Promise that will resolve once this SDK instance is ready for use.
     * Will reject if an error occurs communicating with the backend server.
     * @since 1.0.0
     *
     * @return {Promise}
     *
     * @example
     * const sdk = new Muxy.SDK();
     * sdk.loaded().then(() => {
     *   sdk.send('Hello World');
     * }).catch((err) => {
     *   console.error(err);
     * });
     */


    SDK.prototype.loaded = function () {
      return this.loadPromise;
    };
    /**
     * Updates the internally stored user object with the provided value.
     * Also calls any stored user update callbacks with the new user object.
     * @since 1.5
     *
     * @example
     * const sdk = new Muxy.SDK();
     * sdk.loaded().then(() => {
     *   sdk.updateUser({<user object>});
     * });
     */


    SDK.prototype.updateUser = function (user) {
      this.user = user;
      this.userObservers.notify(user);
    };
    /**
     * Registers a new callback for when the current user's info is updated.
     */


    SDK.prototype.onUserUpdate = function (callback) {
      var handler = new UserUpdateCallbackHandle(callback);
      this.userObservers.register(handler);
      return handler;
    };
    /**
     * Registers a new callback for when the context is updated.
     */


    SDK.prototype.onContextUpdate = function (callback) {
      var handler = new ContextUpdateCallbackHandle(callback);
      this.contextObservers.register(handler);
      return handler;
    };
    /**
     * Returns a date object that is based on the Muxy server time.
     * This method only returns valid results after .loaded() resolves.
     *
     * @return {Date}
     */


    SDK.prototype.getOffsetDate = function () {
      return new Date(new Date().getTime() + this.timeOffset);
    };
    /**
     * Returns a promise to get the user object. This automatically
     * waits for .loaded() to resolve.
     */


    SDK.prototype.getUser = function () {
      var _this = this;

      return this.loaded().then(function () {
        return Promise.resolve(_this.user);
      });
    };
    /**
     * Invokes a request to the backend.
     */


    SDK.prototype.signedRequest = function (method, endpoint, data) {
      return this.client.signedRequest(this.identifier, method, endpoint, data);
    };
    /**
     * Data Accumulation
     */

    /**
     * Fetches the accumulated user data for a given id received by the backend since start.
     *
     * Broadcaster-only functionality.
     *
     * @async
     * @since 1.0.0
     *
     * @throws {TypeError} Will throw an error if accumulationID is not a string.
     *
     * @param {string} accumulationID - The identifier of the accumulated data to fetch.
     * @param {number} start - A Unix timestamp in milliseconds of the earliest accumulation
     * record to fetch.
     *
     * @return {Promise<AccumulateData>} Resolves with requested accumulation data on
     * server response.
     *
     * @example
     * const oneMinuteAgo = (new Date().getTime()) - (1000 * 60);
     * sdk.getAccumulation('awesomeness_level', oneMinuteAgo).then((resp) => {
     *   console.log(`${resp.data.length}: ${resp.latest}`);
     *   console.log(resp.data); // A list of all accumulate values since oneMinuteAgo.
     * });
     */


    SDK.prototype.getAccumulateData = function (accumulationID, start) {
      forceType(accumulationID, 'string');
      return this.client.getAccumulation(this.identifier, accumulationID, start);
    };
    /**
     * @deprecated Use getAccumulateData instead.
     */


    SDK.prototype.getAccumulation = function (accumulationID, start) {
      return this.getAccumulateData(accumulationID, start);
    };
    /**
     * Sends data to be accumulated by the server.
     * @since 1.0.0
     *
     * @param {string} accumulationID - The identifier that this datum is accumulated with.
     * @param {Object} data - Any JSON serializable JavaScript object.
     *
     * @return {Promise} Will resolve on successful server-send. Rejects on failure.
     *
     * @example
     * sdk.accumulate('awesomeness_level', {
     *   awesomeness_level: {
     *     great: 10,
     *     good: 2.5,
     *     poor: 'dank'
     *   }
     * });
     */


    SDK.prototype.accumulate = function (accumulationID, data) {
      forceType(accumulationID, 'string');
      return this.client.accumulate(this.identifier, accumulationID, data);
    };
    /**
     * User Voting
     */

    /**
     * Fetches the current stored vote data for a given vote identifier.
     * @async
     * @since 1.0.0
     *
     * @throws {TypeError} Will throw an error if voteID is not a string.
     *
     * @param {string} voteID - The identifer to fetch associated vote data.
     *
     * @return {Promise<VoteData>} Resolves with requested vote data on server response. Rejects on
     * server error.
     *
     * @example
     * sdk.getVoteData('poll-number-1').then((voteData) => {
     *   console.log(voteData.sum);
     * });
     */


    SDK.prototype.getVoteData = function (voteID) {
      forceType(voteID, 'string');
      return this.client.getVotes(this.identifier, voteID);
    };
    /**
     * Gets the vote logs for a given vote ID. This endpoint may only be called by
     * an admin.
     *
     * @async
     * @param voteID - the identifier to fetch the vote logs for.
     * @return {Promise<VoteLog>} Resolves with the logs on server response. Rejects on server error.
     *
     * @example
     * const sdk = new Muxy.SDK();
     * sdk.getFullVoteLogs('global-12345').then((logs) => {
     *   const audit = logs.result;
     *
     *   // ... process the audit logs ...
     *   const valueToUsersMapping = {};
     *   for (const i = 0; i < audit.length; ++i) {
     *     const value = audit[i].value;
     *     const identifier = audit[i].identifier;
     *
     *     const list = valueToUsersMapping[value] || [];
     *     list.append(identifier);
     *
     *     valueTousersMapping[value] = list;
     *   }
     * });
     */


    SDK.prototype.getFullVoteLogs = function (voteID) {
      forceType(voteID, 'string');
      return this.client.getFullVoteLogs(this.identifier, voteID);
    };
    /**
     * Submit a user vote associated with a vote identifier.
     * @async
     * @since 1.0.0
     *
     * @throws {TypeError} Will throw an error if `voteID` is not a string or if `value` is not
     * a Number.
     *
     * @param {string} voteID - The identifer to fetch associated vote data.
     * @param {number} value - Any numeric value to represent this user's vote. Note that only
     * values of 0-5 will be included in the `specific` field returned from `getVoteData`.
     *
     * @return {Promise} Will resolve on successful server-send. Rejects on failure.
     *
     * @example
     * sdk.vote('poll-number-1', 1);
     */


    SDK.prototype.vote = function (voteID, value) {
      forceType(voteID, 'string');
      forceType(value, 'number');
      return this.client.vote(this.identifier, voteID, {
        value: value
      });
    };
    /**
     * User Ranking
     */

    /**
     * Fetches the current ranked data associated with the rank identifier.
     * @async
     * @since 1.0.0
     *
     * @throws {TypeError} Will throw an error if rankID is not a string.
     *
     * @param {string} rankID - The identifier to fetch associated rank data.
     *
     * @return {Promise<RankData>} Resolves with requested rank data on server response. Rejects
     * on server error.
     *
     * @example
     * sdk.getRankData('favorite_color').then((colors) => {
     *   if (colors.length > 0) {
     *     colors.forEach((color) => {
     *       console.log(`${color.key}: ${color.score}`);
     *     });
     *   }
     * });
     */


    SDK.prototype.getRankData = function (rankID) {
      var _this = this;

      forceType(rankID, 'string');
      return new Promise(function (accept, reject) {
        _this.client.getRank(_this.identifier, rankID).then(function (data) {
          accept(data.data);
        }).catch(reject);
      });
    };
    /**
     * Submit user rank data associated with a rank identifier.
     * @async
     * @since 1.0.0
     *
     * @throws {TypeError} Will throw an error if rankID or value are not strings.
     *
     * @param {string} rankID - The identifer to fetch associated rank data.
     * @param {string} value - Any string value to represent this user's rank data. Will be returned
     * as the `key` field when rank data is requested.
     *
     * @return {Promise<RankResponse>} Will resolve on success. Rejects on failure.
     *
     * @example
     * const usersFavoriteColor = 'rebeccapurple';
     * this.muxy.rank('favorite_color', usersFavoriteColor);
     */


    SDK.prototype.rank = function (rankID, value) {
      forceType(rankID, 'string');
      forceType(value, 'string');
      return this.client.rank(this.identifier, rankID, {
        key: value
      });
    };
    /**
     * Clear all rank data associated with the rank identifier.
     *
     * Broadcaster-only functionality.
     *
     * @async
     * @since 1.0.0
     *
     * @throws {TypeError} Will throw an error if rankID is not a string.
     *
     * @param {string} rankID - The identifer to fetch associated rank data.
     *
     * @return {Promise} Will resolve on success. Rejects on failure.
     */


    SDK.prototype.clearRankData = function (rankID) {
      forceType(rankID, 'string');
      return this.client.deleteRank(this.identifier, rankID);
    };
    /**
     * @deprecated Deprecated in 1.0.0. Use getRankData instead.
     */


    SDK.prototype.getRankingData = function (rankID) {
      return this.getRankData(rankID);
    };
    /**
     * @deprecated Deprecated in 1.0.0. Use clearRankData instead.
     */


    SDK.prototype.clearRanking = function (rankID) {
      return this.clearRanking(rankID);
    };
    /**
     * User State
     */

    /**
     * Sets the channel specific viewer-specific state to a JS object, this can be called by
     * any viewer.
     * Future calls to {@link getAllState} by **this** user will have a clone of this object in the
     * `viewer` field.
     * @async
     * @since 1.0.0
     *
     * @param {Object} state - A complete JS object representing the current viewer state.
     *
     * @return {Promise} Will resolve on successful server-send. Rejects on failure.
     *
     * @example
     * sdk.setViewerState({
     *   favorite_movie: 'Jaws: The Revenge'
     * }).then(() => {
     *   console.log('Viewer state saved!');
     * }).catch((err) => {
     *   console.error(`Failed saving viewer state: ${err}`);
     * });
     */


    SDK.prototype.setViewerState = function (state) {
      return this.client.setViewerState(this.identifier, state);
    };
    /**
     * Sets the extension wide viewer-specific state to a JS object, this is only a valid call for a
     * user that has shared their identity.
     * Future calls to {@link getAllState} by **this** user will have a clone of this object in the
     * `extension_viewer` field.
     * @async
     * @since 1.1.0
     *
     * @param {Object} state - A complete JS object representing the current viewer state.
     *
     * @return {Promise} Will resolve on successful server-send. Rejects on failure.
     *
     * @example
     * sdk.setExtensionViewerState({
     *   favorite_movie: 'Jaws: The Revenge'
     * }).then(() => {
     *   console.log('Viewer state saved!');
     * }).catch((err) => {
     *   console.error(`Failed saving viewer state: ${err}`);
     * });
     */


    SDK.prototype.setExtensionViewerState = function (state) {
      return this.client.setExtensionViewerState(this.identifier, state);
    };
    /**
     * Applies a set of patches to multiple extension-wide viewer-specific states.
     * This method requires a mapping of user_id to objects. The provided state
     * objects per user are merged server-side. A key may be specified to be 'null'
     * to delete the key on the server. Arrays are overwritten in their entirety on merge.
     * Objects are merged recursively.
     *
     * This method can only set state for viewers who have shared their ID.
     *
     * This method requires an admin context.
     * @async
     * @param userStates - a mapping of userID to patch objects.
     *
     * @return {Promise} Will resolve on successful setting of state. Rejects on failure.
     *
     * @example
     * sdk.patchExtensionViewerState({
     *  '12452': { 'hello': 'world' },
     *  '12422': { 'foo': 'bar' }
     * });
     */


    SDK.prototype.patchExtensionViewerState = function (userStates) {
      return this.client.patchExtensionViewerState(this.identifier, userStates);
    };
    /**
     * Sets the extension wide state to a JS object, this may only be called in a broadcaster context
     * for the extension owner. Extension owner may be configured through the development portal.
     * Future calls to {@link getAllState} by all users will have a clone of this object in the
     * `extension` field.
     * @async
     * @since 1.1.0
     *
     * @param {Object} state - A complete JS object representing the current extension's state.
     *
     * @return {Promise} Will resolve on successful server-send. Rejects on failure.
     *
     * @example
     * sdk.setExtensionState({
     *   favorite_movie: 'Jaws: The Revenge'
     * }).then(() => {
     *   console.log('Extension state saved!');
     * }).catch((err) => {
     *   console.error(`Failed saving viewer state: ${err}`);
     * });
     */


    SDK.prototype.setExtensionState = function (state) {
      return this.client.setExtensionState(this.identifier, state);
    };
    /**
     * Sets the extension-wide secret state to a JS object, this may only be called by an extension
     * owner. This state object will never be returned to the broadcaster or viewers.
     * @async
     * @since 2.0.0
     *
     * @param {Object} state - A complete JS object
     *
     * @return {Promise} Will resolve on successful server-send. Rejects on failure.
     *
     * @example
     * sdk.setExtensionSecretState({
     *   favorite_movie: 'Twilight: New Moon'
     * }).then(() => {
     *   console.log('Extension secrets saved!');
     * }).catch((err) => {
     *   console.error(`Failed saving secret state: ${err}`);
     * });
     */


    SDK.prototype.setExtensionSecretState = function (state) {
      return this.client.setExtensionSecretState(this.identifier, state);
    };
    /**
     * Sets the channel-specific state to a JS object. Future calls to {@link getAllState} by **any**
     * user on this channel will have a clone of this object in the `channel` field.
     *
     * Broadcaster-only functionality.
     *
     * @async
     * @since 1.0.0
     *
     * @param {Object} state - A complete JS object representing the current channel state.
     *
     * @return {Promise} Will resolve on successful server-send. Rejects on failure.
     *
     * @example
     * sdk.setChannelState({
     *   broadcasters_mood: 'sanguine, my brother',
     *   chats_mood: 'kreygasm'
     * }).then(() => {
     *   // Let viewers know that new channel state is available.
     * }).catch((err) => {
     *   console.error(`Failed saving channel state: ${err}`);
     * });
     */


    SDK.prototype.setChannelState = function (state) {
      return this.client.setChannelState(this.identifier, state);
    };
    /**
     * Returns the current state object as set for the current extension, channel and
     * viewer combination.
     * @async
     * @since 1.0.0
     *
     * @return {Promise<AllState>} Resolves on successful server request with a populated AllState
     * object.
     *
     * @example
     * sdk.getAllState().then((state) => {
     *   if (state.channel.broadcasters_mood) {
     *     console.log(`Broadcaster set their mood as: ${state.channel.broadcasters_mood}`);
     *   }
     *   if (state.viewer.favorite_movie) {
     *     console.log(`But your favorite movie is: ${state.viewer.favorite_movie}`);
     *   }
     * });
     */


    SDK.prototype.getAllState = function () {
      return this.client.getState(this.identifier);
    };
    /**
     * Returns the current extension state object
     * @async
     *
     * @return {Promise<Object>} Resolves on successful server request with a populated extension state object.
     */


    SDK.prototype.getExtensionState = function () {
      return this.client.getExtensionState(this.identifier);
    };
    /**
     * Returns the current channel state object
     * @async
     *
     * @return {Promise<Object>} Resolves on successful server request with a populated channel state object.
     */


    SDK.prototype.getChannelState = function () {
      return this.client.getChannelState(this.identifier);
    };
    /**
     * Returns the current extension viewer state object
     * @async
     *
     * @return {Promise<Object>} Resolves on successful server request with a populated extension viewer state object.
     */


    SDK.prototype.getExtensionViewerState = function () {
      return this.client.getExtensionViewerState(this.identifier);
    };
    /**
     * Returns the current viewer state object
     * @async
     *
     * @return {Promise<Object>} Resolves on successful server request with a populated viewer state object.
     */


    SDK.prototype.getViewerState = function () {
      return this.client.getViewerState(this.identifier);
    };
    /**
     * Returns the current extension secret state if the requesting user has access to the secret state.
     * @async
     *
     * @return {Promise<Object>} Resolves on successful server request with a populated extension secret state object.
     */


    SDK.prototype.getExtensionSecretState = function () {
      return this.client.getExtensionSecretState(this.identifier);
    };
    /**
     * Returns a mapping of user_id to extension specific viewer states.
     * If a viewer doesn't have state set, but was requested, that user will
     * not be in the response object. The maximum numer of users that can be
     * queried with this call is 1000.
     * @async
     *
     * @param users - an array of userIDs to request state for.
     *
     * @return {Promise<object>} Resolves on successful server request with an object that is a mapping
     *  of userID to state. Rejects on failure.
     *
     * @example
     * sdk.patchExtensionViewerState({
     *  'valid-user-id': {
     *    'hello': 'world'
     *  }
     * }).then(() => {
     *  sdk.multiGetExtensionViewerState(['valid-user-id', 'invalid-user-id']).then(state => {
     *    console.log(state['valid-user-id'].hello) // prints 'world'
     *    console.log(state['invalid-user-id']) // is undefined.
     *  });
     * }
     */


    SDK.prototype.multiGetExtensionViewerState = function (users) {
      if (users.length > 1000) {
        throw new Error('Too many users specified in call to multiGetExtensionViewerState');
      }

      return this.client.multiGetExtensionViewerState(this.identifier, users);
    };
    /**
     * JSON Store
     */

    /**
     * The JSON store is used similarly to the channel state, in that a broadcaster can use it to
     * store arbitrary JSON data that is accessible to all viewers. The stored data is specific to
     * a particular channel and cannot be accessed by viewers of a different channel.
     *
     * Unlike channel state however, each channel can have several JSON stores, accessed by different
     * keys. The data associated with each key must be under 2KB, but there is no limit to the number
     * of keys in use.
     *
     * Also, when pushing new data to the JSON store, a messenger event is automatically sent to all
     * active viewers of the associated channel and the broadcaster's live and config pages. This
     * event will have the format `json_store_update:${key}`. See {@link listen} for details on
     * receiving this event.
     *
     * @async
     * @since 1.0.0
     *
     * @throws {TypeError} Will throw an error if key is provided but is not a string.
     *
     * @param {string?} key - The lookup key for data in the JSON store. Uses 'default' if no value
     * is provided.
     *
     * @return {Promise<Object>} Resolves with the stored JSON parsed to a JS Object associated with
     * the key. Rejects on server error or if the key has no associated data.
     *
     * @example
     * sdk.getJSONStore('basecamp').then((basecamp) => {
     *   if (basecamp && basecamp.tanks) {
     *     deploy(basecamp.tanks);
     *   }
     * });
     */


    SDK.prototype.getJSONStore = function (key) {
      if (key) {
        forceType(key, 'string');
      }

      return this.client.getJSONStore(this.identifier, key);
    };
    /**
     * Two-Factor Auth
     */

    /**
     * Attempts to validate a broadcaster's PIN with Muxy's Two-Factor auth system. For this to work,
     * the broadcaster must have initiated a Two-Factor request for this channel within the auth
     * window.
     *
     * Broadcaster-only functionality.
     *
     * @async
     * @since 1.0.0
     *
     * @throws {TypeError} Will throw an error if `pin` is not a string.
     *
     * @param {string} pin - The broadcaster's PIN to validate the associated auth token.
     *
     * @return {Promise} Resolves if the auth token associated with this PIN can now be used to make
     * requests on behalf of this broadcaster, rejects with an error otherwise.
     *
     * @example
     * sdk.validateCode('MUXY').then(() => {
     *   console.log('Validated! Go go go!');
     * });
     */


    SDK.prototype.validateCode = function (pin) {
      forceType(pin, 'string');
      return this.client.validateCode(this.identifier, pin);
    };
    /**
     * Checks to see if the broadcaster has validated an auth token in the current context. It does
     * not return information about the PIN used or auth token that is valid.
     *
     * Broadcaster-only functionality.
     *
     * @async
     * @since 1.0.0
     *
     * @return {Promise<Object>}
     * @property {boolean} exists - True if an auth token has been validated, false otherwise.
     *
     * @example
     * sdk.pinTokenExists().then((resp) => {
     *   if (!resp.exists) {
     *     showBroadcasterPINInput();
     *   } else {
     *     console.log('Already authorized');
     *   }
     * });
     */


    SDK.prototype.pinTokenExists = function () {
      return this.client.pinTokenExists(this.identifier);
    };
    /**
     * Revokes all auth tokens ever generated for this channel and identifier. After calling this
     * method, tokens currently in use by external apps will cease to function.
     *
     * Broadcaster-only functionality.
     *
     * @async
     * @since 1.0.0
     *
     * @return {Promise} Resolves on sucess, rejects with an error otherwise.
     *
     * @example
     * sdk.revokeAllPINCodes().then(() => {
     *   console.log('No more data coming in!');
     * });
     */


    SDK.prototype.revokeAllPINCodes = function () {
      return this.client.revokeAllPINCodes(this.identifier);
    };
    /**
     * Event System
     */

    /**
     * Sends a message to all listening clients. And viewers or broadcaters listening for the
     * event name will be automatically notified. See {@link listen} for receiving events.
     *
     * Broadcaster-only functionality.
     *
     * @async
     * @since 1.0.0
     *
     * @param {string} event - An event name, in the form [a-z0-9_]+
     * @param {string|*} userID - An optional opaque user id, used to limit the
     * scope of send to that user only.
     * @param {*} [data] - Any JSON serializable primitive to send to all viewers.
     *
     * @example
     * sdk.send('new_song', {
     *   artist: 'Celine Dion',
     *   title: 'My Heart Will Go On',
     *   album: 'Let\'s Talk About Love',
     *   year: 1997
     * });
     */


    SDK.prototype.send = function (event, userID, data) {
      if (!mxy.didLoad) {
        throw new Error('sdk.loaded() was not complete. Please call this method only after the promise has resolved.');
      }

      forceType(event, 'string');
      var target = 'broadcast';
      var realData = data;

      if (!data) {
        realData = userID;
      } else {
        target = "whisper-" + userID;
      }

      this.messenger.send(this.identifier, event, target, realData, this.client);
    };
    /**
     * Registers a callback to listen for events. In general, events are named in the form
     * `event[:identifier]`, where the identifier is the `event` parameter to {@link send}.
     *
     * You can listen to wildcards by using * instead of an event or identifier name.
     *
     * Some methods also automatically send special namespaced events. See {@link vote} and
     * {@link getJSONStore} for examples.
     *
     * You can listen for these events by using `vote_update:next_game` or `vote_update:*`
     * to receive vote updates for specifically the `next_game` vote id, or all vote
     * updates respectively.
     *
     * @since 1.0.0
     *
     * @param {string} inEvent - The event name to listen on. May include wildcards `*`.
     * @param {string|Function} inUserID - An optional opaque user id, used to limit
     * the scope of this listen to that user only.
     * @param {Function} [inCallback] - A callback with the signature `function(body, eventname)`.
     * This callback will receive the message body as its first parameter and the `event` parameter
     * to {@link send} as the second.
     *
     * @return {Object} A listener handle that can be passed to {@see unlisten} to unbind
     * this callback.
     *
     * @example
     * sdk.listen('new_song', (track) => {
     *   console.log(`${track.artist} - {track.title} (${track.year})`);
     * });
     */


    SDK.prototype.listen = function (inEvent, inUserID, inCallback) {
      var _this = this;

      if (!mxy.didLoad) {
        throw new Error('sdk.loaded() was not complete. Please call this method only after the promise has resolved.');
      }

      var realEvent = CurrentEnvironment().environment + ":" + this.identifier + ":" + inEvent;
      realEvent = "production:" + this.identifier + ":" + inEvent;
      console.log("muxy real event", realEvent);
      var l = 'broadcast';
      var callback = inCallback;

      if (callback) {
        l = "whisper-" + inUserID;
      } else {
        callback = inUserID;
      }

      var messageBuffer = [];

      var cb = function cb(msg) {
        try {
          // Production messages may be unprefixed.
          if (CurrentEnvironment().environment === 'production' || true) {
            if (eventPatternMatch(msg.event, _this.identifier + ":" + inEvent)) {
              var truncatedEvent = msg.event.split(':').slice(1).join(':');
              callback(msg.data, truncatedEvent);
              return;
            }
          }

          if (eventPatternMatch(msg.event, realEvent)) {
            // Consumers of the SDK only ever interact with events
            // without the app-id or extension-id prefix.
            var truncatedEvent = msg.event.split(':').slice(2).join(':');
            var serialized_1 = JSON.stringify(msg);
            var now_1 = new Date().valueOf();
            var deduped_1 = false;
            messageBuffer.forEach(function (b) {
              if (b.content === serialized_1) {
                if (now_1 - b.timestamp < 5 * 1000) {
                  deduped_1 = true;
                }
              }
            });

            if (deduped_1) {
              return;
            }

            messageBuffer.unshift({
              content: serialized_1,
              timestamp: now_1
            });
            messageBuffer = messageBuffer.slice(0, 10);
            callback(msg.data, truncatedEvent);
          }
        } catch (err) {
          // TODO: Should this fail silently?
          consolePrint(err, {
            type: 'error'
          });
        }
      };

      return this.messenger.listen(this.identifier, l, cb);
    };
    /**
     * Unbinds a callback from the event system.
     *
     * @since 1.0.0
     *
     * @param {Object} handle - An event handle as returned from {@see listen}.
     */


    SDK.prototype.unlisten = function (handle) {
      return this.messenger.unlisten(this.identifier, handle);
    };
    /**
     * Analytics
     */

    /**
     * Sends an arbitrary event to the analytics backend.
     *
     * @async
     * @since 1.0.0
     *
     * @param {string} name - A unique identifier for this event.
     * @param {number} [value=1] - A value to associate with this event.
     * @param {string} [label=''] - A human-readable label for this event.
     */


    SDK.prototype.sendAnalyticsEvent = function (name, value, label) {
      if (value === void 0) {
        value = 1;
      }

      if (label === void 0) {
        label = '';
      }

      this.analytics.sendEvent(this.identifier, name, value, label);
    };
    /**
     * Monetization
     */

    /**
     * Begins the purchase flow for a given product's SKU.
     *
     * @param {string} sku - The SKU of the digital good that the user has indicated they want to buy.
     */


    SDK.prototype.beginPurchase = function (sku) {
      if (this.SKUs.length === 0) {
        throw new Error('beginPurchase() cannot be used unless SKUs are provided.');
      }

      forceType(sku, 'string');
      return Ext.beginPurchase(sku);
    };
    /**
     * Gets the current price for each item offered.
     *
     * @async
     *
     * @return {Object} An object with the SKU codes as keys.
     */


    SDK.prototype.getPrices = function () {
      if (this.SKUs.length === 0) {
        throw new Error('getPrices() cannot be used unless SKUs are provided.');
      }

      return new Promise(function (resolve) {
        Ext.getPrices(function (prices) {
          resolve(prices);
        });
      });
    };
    /**
     * Sets a function to be used as a callback when entitlements need to be reloaded, i.e. after a
     * purchase has been made.
     *
     * @param {function} callback - A function to be called to update user entitlements.
     */


    SDK.prototype.onReloadEntitlements = function (callback) {
      if (this.SKUs.length === 0) {
        throw new Error('onReloadEntitlements() cannot be used unless SKUs are provided.');
      }

      return Ext.onReloadEntitlements(callback);
    };
    /**
     * Sets a function to be used as a callback that is triggered when the extension visibility changes
     * (This occurs only for mobile or component extensions.)
     *
     * @param {function} callback
     */


    SDK.prototype.onVisibilityChanged = function (callback) {
      return Ext.onVisibilityChanged(callback);
    };
    /**
     * Sets a function to be used as a callback that is triggered when the extension changes position in the player
     * This occurs only for video-component extensions.
     *
     * @param {function} callback
     */


    SDK.prototype.onPositionChanged = function (callback) {
      return Ext.onPositionChanged(callback);
    };
    /**
     * Attempt to exchange one eligibility status for a single prize code.
     * If a code is redeemed, the returned body will have a `code` member, which is the code that was redeemed.
     * @async
     *
     * @throws {TypeError} Will throw an error if prizeIndex is not a valid number
     *
     * @param {number} prize_idx - The prize index
     *
     * @return {Promise<RedeemResult>}
     */


    SDK.prototype.redeemCode = function (prizeIndex) {
      forceType(prizeIndex, 'number');
      return this.client.redeemCode(this.identifier, prizeIndex);
    };
    /**
     * Fetches all codes that the user has redeemed for this extension.
     * @async
     *
     * @return {Promise<RedeemedCodes>} Will resolve on success. Rejects on failure.
     */


    SDK.prototype.getRedeemedCodes = function () {
      return this.client.getRedeemedCodes(this.identifier);
    };
    /**
     * Fetches information about which codes a user is eligible for
     * @async
     *
     * @return {Promise<EligibleCodes>} Will resolve on success. Rejects on failure.
     */


    SDK.prototype.getEligibleCodes = function () {
      return this.client.getEligibleCodes(this.identifier);
    };
    /**
     * Sets the user's trivia team to the current channel.
     * @async
     *
     * @return {Promise<any>}
     */


    SDK.prototype.joinExtensionTriviaTeam = function () {
      return this.client.joinExtensionTriviaTeam(this.identifier);
    };
    /**
     * Return the user's stored trivia team.
     * @async
     *
     * @return {Promise<TriviaTeam>}
     */


    SDK.prototype.getExtensionTriviaJoinedTeam = function () {
      return this.client.getExtensionTriviaJoinedTeam(this.identifier);
    };
    /**
     * Add a trivia question to the extension.
     * Requires extension admin permissions.
     * @async
     *
     * @return {Promise<any>}
     */


    SDK.prototype.addExtensionTriviaQuestion = function (question) {
      return this.client.addExtensionTriviaQuestion(this.identifier, question);
    };
    /**
     * Removes a trivia question from the extension.
     * Requires extension admin permissions.
     * @async
     *
     * @return {Promise<any>}
     */


    SDK.prototype.removeExtensionTriviaQuestion = function (triviaQuestionID) {
      return this.client.removeExtensionTriviaQuestion(this.identifier, triviaQuestionID);
    };
    /**
     * Add an option to a trivia question.
     * Requires extension admin permissions.
     * @async
     *
     * @return {Promise<any>}
     */


    SDK.prototype.addExtensionTriviaOptionToQuestion = function (questionID, option) {
      return this.client.addExtensionTriviaOptionToQuestion(this.identifier, questionID, option);
    };
    /**
     * Remove an option from a trivia question.
     * Requires extension admin permissions.
     * @async
     *
     * @return {Promise<any>}
     */


    SDK.prototype.removeExtensionTriviaOptionFromQuestion = function (questionID, optionID) {
      return this.client.removeExtensionTriviaOptionFromQuestion(this.identifier, questionID, optionID);
    };
    /**
     * Change the state of a extension trivia question.
     * Requires extension admin permissions.
     * @async
     *
     * @return {Promise<any>}
     */


    SDK.prototype.setExtensionTriviaQuestionState = function (questionID, state, winner) {
      return this.client.setExtensionTriviaQuestionState(this.identifier, questionID, state, winner);
    };
    /**
     * As a user place a vote on a trivia question
     * @async
     *
     * @return {Promise<any>}
     */


    SDK.prototype.setExtensionTriviaQuestionVote = function (questionID, optionID) {
      return this.client.setExtensionTriviaQuestionVote(this.identifier, questionID, optionID);
    };
    /**
     * Returns all of the current trivia questions
     * @async
     *
     * @return {Promise<TriviaQuestionResponse>}
     */


    SDK.prototype.getExtensionTriviaQuestions = function () {
      return this.client.getExtensionTriviaQuestions(this.identifier);
    };
    /**
     * Get information about a specific trivia question
     * @async
     *
     * @return {Promise<TriviaQuestion>}
     */


    SDK.prototype.getExtensionTriviaQuestion = function (questionID) {
      return this.client.getExtensionTriviaQuestion(this.identifier, questionID);
    };
    /**
     * Return the trivia leaderboard
     * @async
     *
     * @return {Promise<TriviaLeaderboardTeam[]>}
     */


    SDK.prototype.getExtensionTriviaLeaderboard = function () {
      return this.client.getExtensionTriviaLeaderboard(this.identifier);
    };
    /**
     * Admin-level functionality
     */

    /**
     * Fetches a list of all users who have shared their identity with the extension.
     *
     * This function takes an optional `next` value which should match that returned from previous
     * invocations to iterate through the response. If the returned `next` value is `0`, all
     * available values have been returned and iteration can be stopped.
     *
     * At most 1000 entries will be returned in a single call.
     *
     * Note that because of the asynchronous nature, duplicate entries may be returned and should be
     * uniqued on the client.
     *
     * Admin-only function.
     * @async
     *
     * @return {Promise<ExtensionUsersResult>} Will resolve on success. Rejects on failure.
     */


    SDK.prototype.getExtensionUsers = function (next) {
      return this.client.getExtensionUsers(this.identifier, next);
    };
    /**
     * Private Instance Methods
     */

    /** @ignore */


    SDK.prototype.setup = function (identifier, client, user, messenger, analytics, loadPromise, SKUs, debug) {
      /** @ignore */
      this.userObservers = new Observer();
      /** @ignore */

      this.contextObservers = new Observer();
      /** @ignore */

      this.loadPromise = loadPromise;
      /**
       * A unique instance identifier. Either the extension or app ID.
       * @public
       * @type {string}
       */

      this.identifier = identifier;
      /**
       * The backend state client.
       * @private
       * @type {Client}
       *
       */

      this.client = client;
      /**
       * The backend event messenger client.
       * @private
       * @type {Messenger}
       *
       */

      this.messenger = messenger;
      /**
       * The backend analytics client.
       * @private
       * @type {Analytics}
       *
       */

      this.analytics = analytics;
      /**
       * An automatically updated User instance for the current extension user.
       * This is only valid after .loaded() has resolved.
       * @public
       * @type {User}
       */

      this.user = user;
      /**
       * SKUs associated with the products offered in the extension.
       * @public
       * @type {Object}
       */

      this.SKUs = SKUs;
      /** @ignore */

      this.debug = debug;
    };

    return SDK;
  }();
  /**
   * A single good object as from {@link getUserGoods}.
   *
   * @typedef {Object} ExtensionGood
   *
   * @property {string} next_instruction - The next instruction (action) for the purchase. Can be:
   *   - "NOOP" - No action is needed, the good was fullfilled.
   *   - "FULFILL" - Fulfill the purchase, then call the Twitch entitlement system to indicate
   *     successful completion of the fullfillment.
   *   - "REVOKE" - Unwind the transaction.
   * @property {string} receipt_id - An ID which uniquely identifies the purchase transaction.
   * @property {string} sku - The SKU for the digital good.
   */

  /**
   * A receipt detailing which good's fulfillment status needs to be set. Used as a parameter for
   * {@link updateFulfilledGoods}.
   *
   * @typedef {Object} Receipt
   *
   * @property {string} fulfillment_address - Twitch User ID
   * @property {string} receipt_id - Receipt ID for the digital good, returned by {@link getUserGoods}
   * @property {string} last_instruction - The last thing you did. Corresponds to the "next
   * instruction" for the purchase returned by {@link getUserGoods}. Value value: `FULFILL`.
   */

  /**
   * Provides a convenient interface for Twitch API requests with an automatically set and updated
   * extension client id.
   *
   * Should not normally be created directly, instead an instance is made available
   * and namespaced appropriately when using {@link Muxy.TwitchClient}.
   *
   * @private
   *
   * @example
   * const twitchClient = new Muxy.TwitchClient();
   * twitchClient.getAllState().then((state) => {
   *   console.log(state);
   * });
   */


  var TwitchClient =
  /** @class */
  function () {
    /**
     * Create an instance of TwitchClient bound to the provided client ID.
     *
     * Prefer {@link Muxy.TwitchClient} instead.
     *
     * @since 1.0.0
     * @ignore
     *
     * @param {string} clientID - A valid Twitch Extension Client ID.
     */
    function TwitchClient(clientID) {
      /** @ignore */
      this.extensionId = clientID;
      /** @ignore */

      this.promise = Promise.resolve();
    }
    /**
     * Returns a promise which will resolve once the TwitchClient is available for use.
     *
     * @since 1.0.0
     * @public
     *
     * @return {Promise} Will resolve when the TwitchClient is ready for use.
     */


    TwitchClient.prototype.loaded = function () {
      return this.promise;
    };
    /**
     * Wraps an AJAX request to Twitch's kraken API. Used internally by the API
     * convenience methods.
     *
     * @async
     * @since 1.0.0
     * @ignore
     *
     * @param {string} method - The AJAX request method, e.g. "POST", "GET", etc.
     * @param {string} endpoint - The Twitch kraken API endpoint.
     * @param {string?} data - A string-encoded JSON payload to send with the request.
     * @param {Object} JWT - Signed JWT, accessible from sdk.user.twitchJWT.
     *
     * @return {Promise} Resolves with the AJAX payload on response < 400.
     * Rejects otherwise.
     */


    TwitchClient.prototype.signedTwitchRequest = function (method, endpoint, data, JWT) {
      var headers = {
        Accept: 'application/vnd.twitchtv.v5+json',
        'Client-ID': this.extensionId,
        Authorization: undefined
      };

      if (JWT) {
        headers.Authorization = "Bearer " + JWT;
      }

      return new Promise(function (resolve, reject) {
        var xhrPromise = new XHRPromise({
          data: data,
          headers: headers,
          method: method,
          url: "https://api.twitch.tv/kraken/" + endpoint
        });
        return xhrPromise.send().catch(reject).then(function (resp) {
          if (resp.status < 400) {
            resolve(resp.responseText);
          }

          reject(resp.responseText);
        });
      });
    };
    /**
     * Wraps an AJAX request to Twitch's helix API. Used internally by the API
     * convenience methods.
     *
     * @async
     * @ignore
     *
     * @param {string} method - The AJAX request method, e.g. "POST", "GET", etc.
     * @param {string} endpoint - The Twitch helix API endpoint.
     * @param {string?} data - A string-encoded JSON payload to send with the request.
     * @param {Object} JWT - Signed JWT, accessible from sdk.user.twitchJWT.
     *
     * @return {Promise} Resolves with the AJAX payload on response < 400.
     * Rejects otherwise.
     */


    TwitchClient.prototype.signedTwitchHelixRequest = function (method, endpoint, data, JWT) {
      var headers = {
        Authorization: undefined,
        'Client-ID': this.extensionId
      };

      if (JWT) {
        headers.Authorization = "Bearer " + JWT;
      }

      return new Promise(function (resolve, reject) {
        var xhrPromise = new XHRPromise({
          data: data,
          headers: headers,
          method: method,
          url: "https://api.twitch.tv/helix/" + endpoint
        });
        return xhrPromise.send().then(function (resp) {
          if (resp.status < 400) {
            try {
              if (resp.responseText.hasOwnProperty('data')) {
                var anyResp = resp.responseText;
                var r = anyResp.data;
                resolve(r);
              } else {
                resolve(resp.responseText);
              }
            } catch (err) {
              reject('Unexpected response from Twitch');
            }
          }

          reject(resp.responseText);
        }).catch(reject);
      });
    };
    /**
     * Wraps an AJAX request to Twitch's Extension API. Used internally by the API
     * convenience methods.
     *
     * @async
     * @ignore
     *
     * @param {string} method - The AJAX request method, e.g. "POST", "GET", etc.
     * @param {string} endpoint - The Twitch Extension API endpoint.
     * @param {string?} data - A string-encoded JSON payload to send with the request.
     * @param {Object} JWT - Signed JWT, accessible from sdk.user.twitchJWT.
     *
     * @return {Promise} Resolves with the AJAX payload on response < 400.
     * Rejects otherwise.
     */


    TwitchClient.prototype.signedTwitchExtensionRequest = function (method, endpoint, data, JWT) {
      var headers = {
        'Client-ID': this.extensionId,
        Authorization: undefined
      };

      if (JWT) {
        headers.Authorization = "Bearer " + JWT;
      }

      return new Promise(function (resolve, reject) {
        var xhrPromise = new XHRPromise({
          data: data,
          headers: headers,
          method: method,
          url: "https://api.twitch.tv/extensions/" + endpoint
        });
        return xhrPromise.send().catch(reject).then(function (resp) {
          if (resp.status < 400) {
            resolve(resp.responseText);
          }

          reject(resp.responseText);
        });
      });
    };
    /**
     * Returns a list of Twitch User objects for a given list of usernames.
     *
     * @async
     * @since 1.0.0
     *
     * @throws {TypeError} Will throw an error if users is not an array of strings.
     *
     * @param {[]string} usernames - A list of usernames to lookup on Twitch.
     *
     * @return {Promise<[]TwitchUser>} Resolves with a list of {@link TwitchUser}
     * objects for each of the usernames provided.
     *
     * @example
     * twitchClient.getTwitchUsers(['muxy'], (response) => {
     *  console.log(response.users[0].display_name);
     * });
     */


    TwitchClient.prototype.getTwitchUsers = function (usernames) {
      if (usernames.length === 0) {
        return Promise.resolve([]);
      }

      return this.signedTwitchRequest('GET', "users?login=" + usernames.join(','));
    };
    /**
     * Returns a list of Twitch User objects for a given list of user IDs.
     *
     * @async
     *
     * @throws {TypeError} Will throw an error if userIDs is not an array of strings.
     *
     * @param {[]string} userIDs - A list of user IDs to lookup on Twitch.
     *
     * @return {Promise<[]HelixTwitchUser>} Resolves with a list of {@link HelixTwitchUser}
     * objects for each of the user IDs provided.
     *
     * @example
     * twitchClient.getTwitchUsersByID(['126955211'], (response) => {
     *  console.log(response.users[0].display_name);
     * });
     */


    TwitchClient.prototype.getTwitchUsersByID = function (userIDs) {
      if (userIDs.length === 0) {
        return Promise.resolve([]);
      }

      return this.signedTwitchHelixRequest('GET', "users?id=" + userIDs.join(','));
    };
    /**
     * Monetization
     */

    /**
     * Gets a list of the digital goods the current user has.
     *
     * @param {Object} jwt - Signed JWT, accessible from sdk.user.twitchJWT
     *
     * @return {Promise<[]ExtensionGood>} Resolves with a list of {@link ExtensionGood} objects for
     * each of the goods the user is entitled to.
     */


    TwitchClient.prototype.getUserGoods = function (jwt) {
      return this.signedTwitchRequest('POST', 'commerce/user/goods', '{}', jwt);
    };
    /**
     * Sets the fulfillment status for the specified receipts (purchases).
     *
     * @param {Object} jwt - Signed JWT, accessible from sdk.user.twitchJWT
     * @param {[]Receipt} receipts - List of {@link Receipt} objects detailing which goods need to be
     * updated.
     *
     * @return {Promise<[]Object>} Resolves with a list of results, one for each Receipt in the
     * Receipts parameter.
     */


    TwitchClient.prototype.updateFulfilledGoods = function (jwt, receipts) {
      return this.signedTwitchRequest('POST', 'commerce/user/goods/fulfill', receipts, jwt);
    };
    /**
     * Sets the required configuration string enabling an extension to be enabled
     *
     * SEE: https://dev.twitch.tv/docs/extensions/reference/#set-extension-required-configuration
     *
     * @param jwt - Signed JWT, accessible from sdk.user.twitchJWT
     * @param configurationString - A string that matches the required configuration string in the extension config
     */


    TwitchClient.prototype.setExtensionRequiredConfiguration = function (jwt, configurationString) {
      var environment = Util.getTwitchEnvironment();
      var data = {
        required_configuration: configurationString
      };
      var token = Util.extractJWTInfo(jwt);
      return this.signedTwitchExtensionRequest('PUT', this.extensionId + "/" + environment.version + "/required_configuration?channel_id=" + token.channel_id, JSON.stringify(data), jwt);
    };

    return TwitchClient;
  }();

  var author = "Muxy, Inc.";
  var version = "2.2.6";
  var repository = "https://github.com/muxy/extensions-js";
  /**
   * @module Muxy
   */

  /**
   * The main extension entry interface, available as the global `Muxy` object.
   *
   * This class handles environment detection, data harness collection and updates (for
   * authentication and backend communication) and SDK instance creation.
   *
   * On import or inclusion in an HTML file, a singleton object will be globally accessible
   * as `Muxy`.
   */

  var Muxy =
  /** @class */
  function () {
    /**
     * Private constructor for singleton use only.
     * @ignore
     */
    function Muxy() {
      var _this = this;
      /**
       * Returns a version of the Muxy SDK associated with the provided identifier.
       * @since 1.0.0
       * @public
       *
       * @param {string?} id - A unique identifier for this extension or app. If omitted, the
       * extension client id will be used.
       *
       * @throws {Error} Will throw an error if called before {@link Muxy.setup}.
       *
       * @returns {SDK} An instance of the SDK class.
       *
       * @example
       * const sdk = new Muxy.SDK();
       * sdk.loaded().then(() => {
       *   sdk.send('Hello World');
       * }).catch((err) => {
       *   console.error(err);
       * });
       */


      this.SDK = SDK;
      /**
       * Makes trivia state enum available from the global `Muxy` object
       */

      this.TriviaQuestionState = TriviaQuestionState;
      this.Util = Util;
      this.setupCalled = false;
      this.testChannelID = '23161357';
      this.testJWTRole = 'viewer';
      this.twitchClientID = '';
      this.SDKClients = {};
      this.client = null;
      this.messenger = null;
      this.cachedTwitchClient = null;
      this.analytics = null;
      this.user = null;
      this.didLoad = false;
      this.loadPromise = new Promise(function (resolve, reject) {
        /** @ignore */
        _this.loadResolve = resolve;
        /** @ignore */

        _this.loadReject = reject;
      });
      this.SKUs = [];
      this.debugOptions = null;
      this.watchingAuth = false;
      StateClient.setEnvironment(Util.currentEnvironment(), null);
    }
    /**
     * Prints to console a description of the library's current version and
     * environment info. This is called automatically when the library is
     * setup, unless the `quiet` parameter is passed to {@link setup}.
     *
     * @since 1.0.0
     * @public
     *
     * @example
     * Muxy.printInfo();
     * 
     * | Muxy Extensions SDK                              |
     * | v1.0.0  2017 Muxy, Inc.                         |
     * | https://github.com/muxy/extensions-js            |
     * |                                                  |
     * | Running in sandbox environment outside of Twitch |
     * 
     *
     */


    Muxy.printInfo = function () {
      var SDKInfoText = ['Muxy Extensions SDK', "v" + version + " \xA9 " + new Date().getFullYear() + " " + author, repository, ''];

      switch (Util.currentEnvironment()) {
        case Util.Environments.Production:
          SDKInfoText.push('Running on production');
          break;

        case Util.Environments.SandboxDev:
          SDKInfoText.push('Running in sandbox environment outside of Twitch');
          break;

        case Util.Environments.SandboxTwitch:
          SDKInfoText.push('Running in sandbox environment on Twitch');
          break;

        case Util.Environments.SandboxAdmin:
          SDKInfoText.push('Running in sandbox environment in the Admin panel');
          break;

        case Util.Environments.Admin:
          SDKInfoText.push('Running in the Admin panel');
          break;

        case Util.Environments.Testing:
          SDKInfoText.push('Running in testing environment outside of Twitch');
          break;

        case Util.Environments.Server:
          SDKInfoText.push('Running on a NodeJS server');
          break;

        default:
          SDKInfoText.push('Could not determine execution environment.');
      }

      Util.consolePrint(SDKInfoText, {
        boxed: true
      });
    };
    /**
     * Called the first time the {@link setup} is called to start watching the auth
     * and context callbacks and updating values automatically. This method should
     * not normally be called directly.
     *
     * @since 1.0.0
     * @ignore
     *
     * @param {string} extensionID - The Twitch Extension Client ID to use for all
     * Twitch API requests.
     */


    Muxy.prototype.watchAuth = function (extensionID) {
      var _this = this;

      Ext.extensionID = extensionID; // Auth callback handler

      Ext.onAuthorized(this.debugOptions, function (auth) {
        if (!auth) {
          _this.loadReject('Received invalid authorization from Twitch');

          return;
        }

        _this.twitchClientID = auth.clientId;
        _this.messenger.extensionID = auth.clientId;
        _this.messenger.channelID = auth.channelId;

        _this.client.updateAuth(auth.token);

        var resolvePromise = function resolvePromise(user) {
          _this.user = user;
          var keys = Object.keys(_this.SDKClients);

          for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];

            _this.SDKClients[key].updateUser(_this.user);
          }

          if (_this.analytics) {
            _this.analytics.user = _this.user;
          }
        };

        var onFirstAuth = function onFirstAuth() {
          _this.client.immediateGetUserInfo(extensionID).then(function (userinfo) {
            var offset = userinfo.server_time - new Date().getTime();
            var user = new User(auth);
            user.ip = userinfo.ip_address;
            user.registeredWithMuxy = userinfo.registered || false;
            user.visualizationID = userinfo.visualization_id || '';
            user.timeOffset = offset;
            var keys = Object.keys(_this.SDKClients);

            for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
              var key = keys_2[_i];
              _this.SDKClients[key].timeOffset = offset;
            }

            updateUserContextSettings.call(_this);
            _this.didLoad = true;
            resolvePromise(user);

            _this.loadResolve();
          }).catch(function (err) {
            _this.loadReject(err);
          });
        };

        if (_this.user) {
          _this.user.updateAuth(auth);

          resolvePromise(_this.user);
        } else {
          onFirstAuth();
        }
      }); // Context callback handler

      var updateUserContextSettings = function updateUserContextSettings() {
        if (!_this.user || !_this.context) {
          return;
        } // Set Video Mode


        if (_this.context.isFullScreen) {
          _this.user.videoMode = 'fullscreen';
        } else if (_this.context.isTheatreMode) {
          _this.user.videoMode = 'theatre';
        } else {
          _this.user.videoMode = 'default';
        }

        _this.user.game = _this.context.game;
        _this.user.bitrate = Math.round(_this.context.bitrate || 0);
        _this.user.latency = _this.context.hlsLatencyBroadcaster;
        _this.user.buffer = _this.context.bufferSize;
        _this.user.theme = _this.context.theme;
        _this.user.volume = _this.context.volume;
        var keys = Object.keys(_this.SDKClients);

        for (var _i = 0, keys_3 = keys; _i < keys_3.length; _i++) {
          var key = keys_3[_i];

          _this.SDKClients[key].updateUser(_this.user);
        } // If buffer size goes to 0, send an analytics event that
        // this user's video is buffering.


        if (_this.context.bufferSize < 1 && _this.analytics) {
          _this.analytics.user = _this.user;

          _this.analytics.sendEvent('video', 'buffer', 1);
        }
      };

      Ext.onContext(function (context) {
        _this.context = context;

        if (_this.user) {
          updateUserContextSettings.call(_this);
        }

        var keys = Object.keys(_this.SDKClients);

        for (var _i = 0, keys_4 = keys; _i < keys_4.length; _i++) {
          var key = keys_4[_i];

          _this.SDKClients[key].contextObservers.notify(context);
        }
      });
    };
    /**
     * Mandatory SDK setup call. Must be called once and only once to establish the Extension
     * environment and client ID to use.
     *
     * @since 1.0.0
     * @public
     *
     * @param {Object} options
     *
     * @param {string} options.clientID - The Extension Client ID as provided by Twitch.
     * @since 1.0.4
     *
     * @param {string?} options.uaString - An optional Google Analytics UA_String to send
     * events to.
     * @since 1.0.0
     *
     * @param {boolean?} options.quiet - If true, will not print library information to the
     * console. This is always true when running in production.
     * @since 1.0.3
     *
     * @throws {Error} Will throw an error if setup() has already been called, or if no
     * Extension Client ID is provided.
     *
     * @example
     * Muxy.setup({
     *   clientID: <your extension client id>
     * });
     */


    Muxy.prototype.setup = function (options) {
      if (this.setupCalled) {
        throw new Error('Muxy.setup() can only be called once.');
      }

      if (!options) {
        throw new Error('Muxy.setup() was called with invalid options');
      }

      var clientID = options.clientID || options.extensionID;

      if (!clientID) {
        throw new Error('Muxy.setup() was called without an Extension Client ID');
      }

      if (!this.debugOptions) {
        var noop = function noop() {
          var args = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          /* Default to doing nothing on callback */

        };

        this.debugOptions = {
          channelID: this.testChannelID,
          role: this.testJWTRole,
          onPubsubListen: noop,
          onPubsubReceive: noop,
          onPubsubSend: noop
        };
      }

      if (this.debugOptions.environment) {
        Util.overrideEnvironment = Util.Environments[this.debugOptions.environment];
      }

      this.client = new StateClient(this.loadPromise, this.debugOptions);
      this.messenger = DefaultMessenger(this.debugOptions);
      this.twitchClientID = clientID;
      this.cachedTwitchClient = new TwitchClient(this.twitchClientID);
      this.cachedTwitchClient.promise = this.loadPromise;

      if (options.uaString) {
        this.analytics = new Analytics(options.uaString, this.loadPromise);
      }

      if (!options.quiet) {
        Muxy.printInfo();
      }

      this.setupCalled = true;
    };
    /**
     * Setup debugging options for the application. This allows the application to fake
     * what user they are running as, the channel the extension is running on, pubsub debug
     * message frequency, and even the backend URL that the extension uses.
     *
     * This should be called before setup().
     *
     * @param {*} options - an instance of DebuggingOptions
     */


    Muxy.prototype.debug = function (options) {
      this.debugOptions = _assign({
        channelID: this.testChannelID,
        role: this.testJWTRole
      }, this.debugOptions, options.options);
    };
    /**
     * Returns a twitch client to use. Can only be used after the loaded promise resolves.
     *
     * @since 1.0.0
     * @public
     *
     * @returns {TwitchClient} An instance of the TwitchClient class.
     *
     * @throws {Error} Will throw an error if called before {@link Muxy.setup}.
     */


    Muxy.prototype.TwitchClient = function () {
      /* Implemented below to deal with scoping issues. */
      return undefined;
    };

    return Muxy;
  }();
  /**
   * Global Muxy singleton object.
   * @ignore
   */


  var mxy = new Muxy();
  /** @ignore */

  mxy.TwitchClient = function NewTwitchClient() {
    if (!mxy.setupCalled) {
      throw new Error('Muxy.setup() must be called before creating a new TwitchClient instance');
    }

    return mxy.cachedTwitchClient;
  };

  mxy.DebuggingOptions = DebuggingOptions; // Backwards compatibility shim
  // tslint:disable-next-line

  mxy['default'] = mxy;
  return mxy;
});
},{"buffer":"../../.nvm/versions/node/v11.10.1/lib/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"../../.nvm/versions/node/v11.10.1/lib/node_modules/parcel-bundler/node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"jquery.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
var define;
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
(function (global, factory) {
  "use strict";

  if ((typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && _typeof(module.exports) === "object") {
    // For CommonJS and CommonJS-like environments where a proper `window`
    // is present, execute the factory and get jQuery.
    // For environments that do not have a `window` with a `document`
    // (such as Node.js), expose a factory as module.exports.
    // This accentuates the need for the creation of a real `window`.
    // e.g. var jQuery = require("jquery")(window);
    // See ticket #14549 for more info.
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }

      return factory(w);
    };
  } else {
    factory(global);
  } // Pass this if window is not defined yet

})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {
  // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
  // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
  // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
  // enough that all such attempts are guarded in a try block.
  "use strict";

  var arr = [];
  var document = window.document;
  var getProto = Object.getPrototypeOf;
  var _slice = arr.slice;
  var concat = arr.concat;
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var fnToString = hasOwn.toString;
  var ObjectFunctionString = fnToString.call(Object);
  var support = {};

  var isFunction = function isFunction(obj) {
    // Support: Chrome <=57, Firefox <=52
    // In some browsers, typeof returns "function" for HTML <object> elements
    // (i.e., `typeof document.createElement( "object" ) === "function"`).
    // We don't want to classify *any* DOM node as a function.
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  };

  var isWindow = function isWindow(obj) {
    return obj != null && obj === obj.window;
  };

  var preservedScriptAttributes = {
    type: true,
    src: true,
    noModule: true
  };

  function DOMEval(code, doc, node) {
    doc = doc || document;
    var i,
        script = doc.createElement("script");
    script.text = code;

    if (node) {
      for (i in preservedScriptAttributes) {
        if (node[i]) {
          script[i] = node[i];
        }
      }
    }

    doc.head.appendChild(script).parentNode.removeChild(script);
  }

  function toType(obj) {
    if (obj == null) {
      return obj + "";
    } // Support: Android <=2.3 only (functionish RegExp)


    return _typeof(obj) === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : _typeof(obj);
  }
  /* global Symbol */
  // Defining this global in .eslintrc.json would create a danger of using the global
  // unguarded in another place, it seems safer to define global only for this module


  var version = "3.3.1",
      // Define a local copy of jQuery
  jQuery = function jQuery(selector, context) {
    // The jQuery object is actually just the init constructor 'enhanced'
    // Need init if jQuery is called (just allow error to be thrown if not included)
    return new jQuery.fn.init(selector, context);
  },
      // Support: Android <=4.0 only
  // Make sure we trim BOM and NBSP
  rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

  jQuery.fn = jQuery.prototype = {
    // The current version of jQuery being used
    jquery: version,
    constructor: jQuery,
    // The default length of a jQuery object is 0
    length: 0,
    toArray: function toArray() {
      return _slice.call(this);
    },
    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    get: function get(num) {
      // Return all the elements in a clean array
      if (num == null) {
        return _slice.call(this);
      } // Return just the one element from the set


      return num < 0 ? this[num + this.length] : this[num];
    },
    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function pushStack(elems) {
      // Build a new jQuery matched element set
      var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)

      ret.prevObject = this; // Return the newly-formed element set

      return ret;
    },
    // Execute a callback for every element in the matched set.
    each: function each(callback) {
      return jQuery.each(this, callback);
    },
    map: function map(callback) {
      return this.pushStack(jQuery.map(this, function (elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function slice() {
      return this.pushStack(_slice.apply(this, arguments));
    },
    first: function first() {
      return this.eq(0);
    },
    last: function last() {
      return this.eq(-1);
    },
    eq: function eq(i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function end() {
      return this.prevObject || this.constructor();
    },
    // For internal use only.
    // Behaves like an Array's method, not like a jQuery method.
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };

  jQuery.extend = jQuery.fn.extend = function () {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false; // Handle a deep copy situation

    if (typeof target === "boolean") {
      deep = target; // Skip the boolean and the target

      target = arguments[i] || {};
      i++;
    } // Handle case when target is a string or something (possible in deep copy)


    if (_typeof(target) !== "object" && !isFunction(target)) {
      target = {};
    } // Extend jQuery itself if only one argument is passed


    if (i === length) {
      target = this;
      i--;
    }

    for (; i < length; i++) {
      // Only deal with non-null/undefined values
      if ((options = arguments[i]) != null) {
        // Extend the base object
        for (name in options) {
          src = target[name];
          copy = options[name]; // Prevent never-ending loop

          if (target === copy) {
            continue;
          } // Recurse if we're merging plain objects or arrays


          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && Array.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            } // Never move original objects, clone them


            target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    } // Return the modified object


    return target;
  };

  jQuery.extend({
    // Unique for each copy of jQuery on the page
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    // Assume jQuery is ready without the ready module
    isReady: true,
    error: function error(msg) {
      throw new Error(msg);
    },
    noop: function noop() {},
    isPlainObject: function isPlainObject(obj) {
      var proto, Ctor; // Detect obvious negatives
      // Use toString instead of jQuery.type to catch host objects

      if (!obj || toString.call(obj) !== "[object Object]") {
        return false;
      }

      proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain

      if (!proto) {
        return true;
      } // Objects with prototype are plain iff they were constructed by a global Object function


      Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
      return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
    },
    isEmptyObject: function isEmptyObject(obj) {
      /* eslint-disable no-unused-vars */
      // See https://github.com/eslint/eslint/issues/6125
      var name;

      for (name in obj) {
        return false;
      }

      return true;
    },
    // Evaluates a script in a global context
    globalEval: function globalEval(code) {
      DOMEval(code);
    },
    each: function each(obj, callback) {
      var length,
          i = 0;

      if (isArrayLike(obj)) {
        length = obj.length;

        for (; i < length; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      }

      return obj;
    },
    // Support: Android <=4.0 only
    trim: function trim(text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },
    // results is for internal usage only
    makeArray: function makeArray(arr, results) {
      var ret = results || [];

      if (arr != null) {
        if (isArrayLike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }

      return ret;
    },
    inArray: function inArray(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    // Support: Android <=4.0 only, PhantomJS 1 only
    // push.apply(_, arraylike) throws on ancient WebKit
    merge: function merge(first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;

      for (; j < len; j++) {
        first[i++] = second[j];
      }

      first.length = i;
      return first;
    },
    grep: function grep(elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert; // Go through the array, only saving the items
      // that pass the validator function

      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);

        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }

      return matches;
    },
    // arg is for internal usage only
    map: function map(elems, callback, arg) {
      var length,
          value,
          i = 0,
          ret = []; // Go through the array, translating each of the items to their new values

      if (isArrayLike(elems)) {
        length = elems.length;

        for (; i < length; i++) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        } // Go through every key on the object,

      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        }
      } // Flatten any nested arrays


      return concat.apply([], ret);
    },
    // A global GUID counter for objects
    guid: 1,
    // jQuery.support is not used in Core but other projects attach their
    // properties to it so it needs to exist.
    support: support
  });

  if (typeof Symbol === "function") {
    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
  } // Populate the class2type map


  jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });

  function isArrayLike(obj) {
    // Support: real iOS 8.2 only (not reproducible in simulator)
    // `in` check used to prevent JIT error (gh-2145)
    // hasOwn isn't used here due to false negatives
    // regarding Nodelist length in IE
    var length = !!obj && "length" in obj && obj.length,
        type = toType(obj);

    if (isFunction(obj) || isWindow(obj)) {
      return false;
    }

    return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
  }

  var Sizzle =
  /*!
   * Sizzle CSS Selector Engine v2.3.3
   * https://sizzlejs.com/
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license
   * http://jquery.org/license
   *
   * Date: 2016-08-08
   */
  function (window) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        // Local document vars
    setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        // Instance-specific data
    expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function sortOrder(a, b) {
      if (a === b) {
        hasDuplicate = true;
      }

      return 0;
    },
        // Instance methods
    hasOwn = {}.hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        // Use a stripped-down indexOf as it's faster than native
    // https://jsperf.com/thor-indexof-vs-for/5
    indexOf = function indexOf(list, elem) {
      var i = 0,
          len = list.length;

      for (; i < len; i++) {
        if (list[i] === elem) {
          return i;
        }
      }

      return -1;
    },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        // Regular expressions
    // http://www.w3.org/TR/css3-selectors/#whitespace
    whitespace = "[\\x20\\t\\r\\n\\f]",
        // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
    identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
    attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
    "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
    // 1. quoted (capture 3; capture 4 or capture 5)
    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
    ".*" + ")\\)|)",
        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
      "ID": new RegExp("^#(" + identifier + ")"),
      "CLASS": new RegExp("^\\.(" + identifier + ")"),
      "TAG": new RegExp("^(" + identifier + "|[*])"),
      "ATTR": new RegExp("^" + attributes),
      "PSEUDO": new RegExp("^" + pseudos),
      "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
      "bool": new RegExp("^(?:" + booleans + ")$", "i"),
      // For use in libraries implementing .is()
      // We use this for POS matching in `select`
      "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
    },
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        // Easily-parseable/retrievable ID or TAG or CLASS selectors
    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        // CSS escapes
    // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
    runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
        funescape = function funescape(_, escaped, escapedWhitespace) {
      var high = "0x" + escaped - 0x10000; // NaN means non-codepoint
      // Support: Firefox<24
      // Workaround erroneous numeric interpretation of +"0x"

      return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint
      String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)
      String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
    },
        // CSS string/identifier serialization
    // https://drafts.csswg.org/cssom/#common-serializing-idioms
    rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
        fcssescape = function fcssescape(ch, asCodePoint) {
      if (asCodePoint) {
        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
        if (ch === "\0") {
          return "\uFFFD";
        } // Control characters and (dependent upon position) numbers get escaped as code points


        return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
      } // Other potentially-special ASCII characters get backslash-escaped


      return "\\" + ch;
    },
        // Used for iframes
    // See setDocument()
    // Removing the function wrapper causes a "Permission Denied"
    // error in IE
    unloadHandler = function unloadHandler() {
      setDocument();
    },
        disabledAncestor = addCombinator(function (elem) {
      return elem.disabled === true && ("form" in elem || "label" in elem);
    }, {
      dir: "parentNode",
      next: "legend"
    }); // Optimize for push.apply( _, NodeList )


    try {
      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0
      // Detect silently failing push.apply

      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {
        apply: arr.length ? // Leverage slice if possible
        function (target, els) {
          push_native.apply(target, slice.call(els));
        } : // Support: IE<9
        // Otherwise append directly
        function (target, els) {
          var j = target.length,
              i = 0; // Can't trust NodeList.length

          while (target[j++] = els[i++]) {}

          target.length = j - 1;
        }
      };
    }

    function Sizzle(selector, context, results, seed) {
      var m,
          i,
          elem,
          nid,
          match,
          groups,
          newSelector,
          newContext = context && context.ownerDocument,
          // nodeType defaults to 9, since context defaults to document
      nodeType = context ? context.nodeType : 9;
      results = results || []; // Return early from calls with invalid selector or context

      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      } // Try to shortcut find operations (as opposed to filters) in HTML documents


      if (!seed) {
        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
          setDocument(context);
        }

        context = context || document;

        if (documentIsHTML) {
          // If the selector is sufficiently simple, try using a "get*By*" DOM method
          // (excepting DocumentFragment context, where the methods don't exist)
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            // ID selector
            if (m = match[1]) {
              // Document context
              if (nodeType === 9) {
                if (elem = context.getElementById(m)) {
                  // Support: IE, Opera, Webkit
                  // TODO: identify versions
                  // getElementById can match elements by name instead of ID
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                } // Element context

              } else {
                // Support: IE, Opera, Webkit
                // TODO: identify versions
                // getElementById can match elements by name instead of ID
                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } // Type selector

            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results; // Class selector
            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          } // Take advantage of querySelectorAll


          if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
            if (nodeType !== 1) {
              newContext = context;
              newSelector = selector; // qSA looks outside Element context, which is not what we want
              // Thanks to Andrew Dupont for this workaround technique
              // Support: IE <=8
              // Exclude object elements
            } else if (context.nodeName.toLowerCase() !== "object") {
              // Capture the context ID, setting it first if necessary
              if (nid = context.getAttribute("id")) {
                nid = nid.replace(rcssescape, fcssescape);
              } else {
                context.setAttribute("id", nid = expando);
              } // Prefix every selector in the list


              groups = tokenize(selector);
              i = groups.length;

              while (i--) {
                groups[i] = "#" + nid + " " + toSelector(groups[i]);
              }

              newSelector = groups.join(","); // Expand context for sibling selectors

              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
            }

            if (newSelector) {
              try {
                push.apply(results, newContext.querySelectorAll(newSelector));
                return results;
              } catch (qsaError) {} finally {
                if (nid === expando) {
                  context.removeAttribute("id");
                }
              }
            }
          }
        }
      } // All others


      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    /**
     * Create key-value caches of limited size
     * @returns {function(string, object)} Returns the Object data after storing it on itself with
     *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
     *	deleting the oldest entry
     */


    function createCache() {
      var keys = [];

      function cache(key, value) {
        // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
        if (keys.push(key + " ") > Expr.cacheLength) {
          // Only keep the most recent entries
          delete cache[keys.shift()];
        }

        return cache[key + " "] = value;
      }

      return cache;
    }
    /**
     * Mark a function for special use by Sizzle
     * @param {Function} fn The function to mark
     */


    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    /**
     * Support testing using an element
     * @param {Function} fn Passed the created element and returns a boolean result
     */


    function assert(fn) {
      var el = document.createElement("fieldset");

      try {
        return !!fn(el);
      } catch (e) {
        return false;
      } finally {
        // Remove from its parent by default
        if (el.parentNode) {
          el.parentNode.removeChild(el);
        } // release memory in IE


        el = null;
      }
    }
    /**
     * Adds the same handler for all of the specified attrs
     * @param {String} attrs Pipe-separated list of attributes
     * @param {Function} handler The method that will be applied
     */


    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
          i = arr.length;

      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    /**
     * Checks document order of two siblings
     * @param {Element} a
     * @param {Element} b
     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
     */


    function siblingCheck(a, b) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes

      if (diff) {
        return diff;
      } // Check if b follows a


      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }

      return a ? 1 : -1;
    }
    /**
     * Returns a function to use in pseudos for input types
     * @param {String} type
     */


    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    /**
     * Returns a function to use in pseudos for buttons
     * @param {String} type
     */


    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    /**
     * Returns a function to use in pseudos for :enabled/:disabled
     * @param {Boolean} disabled true for :disabled; false for :enabled
     */


    function createDisabledPseudo(disabled) {
      // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
      return function (elem) {
        // Only certain elements can match :enabled or :disabled
        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
        if ("form" in elem) {
          // Check for inherited disabledness on relevant non-disabled elements:
          // * listed form-associated elements in a disabled fieldset
          //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
          //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
          // * option elements in a disabled optgroup
          //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
          // All such elements have a "form" property.
          if (elem.parentNode && elem.disabled === false) {
            // Option elements defer to a parent optgroup if present
            if ("label" in elem) {
              if ("label" in elem.parentNode) {
                return elem.parentNode.disabled === disabled;
              } else {
                return elem.disabled === disabled;
              }
            } // Support: IE 6 - 11
            // Use the isDisabled shortcut property to check for disabled fieldset ancestors


            return elem.isDisabled === disabled || // Where there is no isDisabled, check manually

            /* jshint -W018 */
            elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
          }

          return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.
          // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
          // even exist on them, let alone have a boolean value.
        } else if ("label" in elem) {
          return elem.disabled === disabled;
        } // Remaining elements are neither :enabled nor :disabled


        return false;
      };
    }
    /**
     * Returns a function to use in pseudos for positionals
     * @param {Function} fn
     */


    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length; // Match elements found at the specified indexes

          while (i--) {
            if (seed[j = matchIndexes[i]]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    /**
     * Checks a node for validity as a Sizzle context
     * @param {Element|Object=} context
     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
     */


    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    } // Expose support vars for convenience


    support = Sizzle.support = {};
    /**
     * Detects XML nodes
     * @param {Element|Object} elem An element or a document
     * @returns {Boolean} True iff elem is a non-HTML XML node
     */

    isXML = Sizzle.isXML = function (elem) {
      // documentElement is verified for cases where it doesn't yet exist
      // (such as loading iframes in IE - #4833)
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== "HTML" : false;
    };
    /**
     * Sets document-related variables once based on the current document
     * @param {Element|Object} [doc] An element or document object to use to set the document
     * @returns {Object} Returns the current document
     */


    setDocument = Sizzle.setDocument = function (node) {
      var hasCompare,
          subWindow,
          doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected

      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      } // Update global variables


      document = doc;
      docElem = document.documentElement;
      documentIsHTML = !isXML(document); // Support: IE 9-11, Edge
      // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)

      if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
        // Support: IE 11, Edge
        if (subWindow.addEventListener) {
          subWindow.addEventListener("unload", unloadHandler, false); // Support: IE 9 - 10 only
        } else if (subWindow.attachEvent) {
          subWindow.attachEvent("onunload", unloadHandler);
        }
      }
      /* Attributes
      ---------------------------------------------------------------------- */
      // Support: IE<8
      // Verify that getAttribute really returns attributes and not properties
      // (excepting IE8 booleans)


      support.attributes = assert(function (el) {
        el.className = "i";
        return !el.getAttribute("className");
      });
      /* getElement(s)By*
      ---------------------------------------------------------------------- */
      // Check if getElementsByTagName("*") returns only elements

      support.getElementsByTagName = assert(function (el) {
        el.appendChild(document.createComment(""));
        return !el.getElementsByTagName("*").length;
      }); // Support: IE<9

      support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10
      // Check if getElementById returns elements by name
      // The broken getElementById methods don't pick up programmatically-set names,
      // so use a roundabout getElementsByName test

      support.getById = assert(function (el) {
        docElem.appendChild(el).id = expando;
        return !document.getElementsByName || !document.getElementsByName(expando).length;
      }); // ID filter and find

      if (support.getById) {
        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            return elem.getAttribute("id") === attrId;
          };
        };

        Expr.find["ID"] = function (id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var elem = context.getElementById(id);
            return elem ? [elem] : [];
          }
        };
      } else {
        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        }; // Support: IE 6 - 7 only
        // getElementById is not reliable as a find shortcut


        Expr.find["ID"] = function (id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var node,
                i,
                elems,
                elem = context.getElementById(id);

            if (elem) {
              // Verify the id attribute
              node = elem.getAttributeNode("id");

              if (node && node.value === id) {
                return [elem];
              } // Fall back on getElementsByName


              elems = context.getElementsByName(id);
              i = 0;

              while (elem = elems[i++]) {
                node = elem.getAttributeNode("id");

                if (node && node.value === id) {
                  return [elem];
                }
              }
            }

            return [];
          }
        };
      } // Tag


      Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function (tag, context) {
        var elem,
            tmp = [],
            i = 0,
            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
        results = context.getElementsByTagName(tag); // Filter out possible comments

        if (tag === "*") {
          while (elem = results[i++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }

          return tmp;
        }

        return results;
      }; // Class

      Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      /* QSA/matchesSelector
      ---------------------------------------------------------------------- */
      // QSA and matchesSelector support
      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)


      rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)
      // We allow this because of a bug in IE8/9 that throws an error
      // whenever `document.activeElement` is accessed on an iframe
      // So, we allow :focus to pass through QSA all the time to avoid the IE error
      // See https://bugs.jquery.com/ticket/13378

      rbuggyQSA = [];

      if (support.qsa = rnative.test(document.querySelectorAll)) {
        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function (el) {
          // Select is set to empty string on purpose
          // This is to test IE's treatment of not explicitly
          // setting a boolean content attribute,
          // since its presence should be enough
          // https://bugs.jquery.com/ticket/12359
          docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>"; // Support: IE8, Opera 11-12.16
          // Nothing should be selected when empty strings follow ^= or $= or *=
          // The test attribute must be unknown in Opera but "safe" for WinRT
          // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section

          if (el.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          } // Support: IE8
          // Boolean attributes and "value" are not treated correctly


          if (!el.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+


          if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          } // Webkit/Opera - :checked should return selected option elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          // IE8 throws error here and will not see later tests


          if (!el.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          } // Support: Safari 8+, iOS 8+
          // https://bugs.webkit.org/show_bug.cgi?id=136851
          // In-page `selector#id sibling-combinator selector` fails


          if (!el.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          }
        });
        assert(function (el) {
          el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>"; // Support: Windows 8 Native Apps
          // The type and name attributes are restricted during .innerHTML assignment

          var input = document.createElement("input");
          input.setAttribute("type", "hidden");
          el.appendChild(input).setAttribute("name", "D"); // Support: IE8
          // Enforce case-sensitivity of name attribute

          if (el.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
          // IE8 throws error here and will not see later tests


          if (el.querySelectorAll(":enabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          } // Support: IE9-11+
          // IE's :disabled selector does not pick up the children of disabled fieldsets


          docElem.appendChild(el).disabled = true;

          if (el.querySelectorAll(":disabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          } // Opera 10-11 does not throw on post-comma invalid pseudos


          el.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }

      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
        assert(function (el) {
          // Check to see if it's possible to do matchesSelector
          // on a disconnected node (IE 9)
          support.disconnectedMatch = matches.call(el, "*"); // This should fail with an exception
          // Gecko does not error, returns false instead

          matches.call(el, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }

      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      /* Contains
      ---------------------------------------------------------------------- */

      hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another
      // Purposefully self-exclusive
      // As in, an element does not contain itself

      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function (a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }

        return false;
      };
      /* Sorting
      ---------------------------------------------------------------------- */
      // Document order sorting

      sortOrder = hasCompare ? function (a, b) {
        // Flag for duplicate removal
        if (a === b) {
          hasDuplicate = true;
          return 0;
        } // Sort on method existence if only one input has compareDocumentPosition


        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;

        if (compare) {
          return compare;
        } // Calculate position if both inputs belong to the same document


        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
        1; // Disconnected nodes

        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
          // Choose the first element that is related to our preferred document
          if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
            return -1;
          }

          if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
            return 1;
          } // Maintain original order


          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
        }

        return compare & 4 ? -1 : 1;
      } : function (a, b) {
        // Exit early if the nodes are identical
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }

        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b]; // Parentless nodes are either documents or disconnected

        if (!aup || !bup) {
          return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check
        } else if (aup === bup) {
          return siblingCheck(a, b);
        } // Otherwise we need full lists of their ancestors for comparison


        cur = a;

        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }

        cur = b;

        while (cur = cur.parentNode) {
          bp.unshift(cur);
        } // Walk down the tree looking for a discrepancy


        while (ap[i] === bp[i]) {
          i++;
        }

        return i ? // Do a sibling check if the nodes have a common ancestor
        siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
        ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return document;
    };

    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };

    Sizzle.matchesSelector = function (elem, expr) {
      // Set document vars if needed
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      } // Make sure that attribute selectors are quoted


      expr = expr.replace(rattributeQuotes, "='$1']");

      if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes

          if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
          // fragment in IE 9
          elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {}
      }

      return Sizzle(expr, document, null, [elem]).length > 0;
    };

    Sizzle.contains = function (context, elem) {
      // Set document vars if needed
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }

      return contains(context, elem);
    };

    Sizzle.attr = function (elem, name) {
      // Set document vars if needed
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }

      var fn = Expr.attrHandle[name.toLowerCase()],
          // Don't get fooled by Object.prototype properties (jQuery #13807)
      val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };

    Sizzle.escape = function (sel) {
      return (sel + "").replace(rcssescape, fcssescape);
    };

    Sizzle.error = function (msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    /**
     * Document sorting and removing duplicates
     * @param {ArrayLike} results
     */


    Sizzle.uniqueSort = function (results) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0; // Unless we *know* we can detect duplicates, assume their presence

      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);

      if (hasDuplicate) {
        while (elem = results[i++]) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }

        while (j--) {
          results.splice(duplicates[j], 1);
        }
      } // Clear input after sorting to release objects
      // See https://github.com/jquery/sizzle/pull/225


      sortInput = null;
      return results;
    };
    /**
     * Utility function for retrieving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */


    getText = Sizzle.getText = function (elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;

      if (!nodeType) {
        // If no nodeType, this is expected to be an array
        while (node = elem[i++]) {
          // Do not traverse comment nodes
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        // Use textContent for elements
        // innerText usage removed for consistency of new lines (jQuery #11153)
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          // Traverse its children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      } // Do not include comment or processing instruction nodes


      return ret;
    };

    Expr = Sizzle.selectors = {
      // Can be adjusted by the user
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {
          dir: "parentNode"
        },
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {
          dir: "previousSibling"
        }
      },
      preFilter: {
        "ATTR": function ATTR(match) {
          match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted

          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }

          return match.slice(0, 4);
        },
        "CHILD": function CHILD(match) {
          /* matches from matchExpr["CHILD"]
          	1 type (only|nth|...)
          	2 what (child|of-type)
          	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
          	4 xn-component of xn+y argument ([+-]?\d*n|)
          	5 sign of xn-component
          	6 x of xn-component
          	7 sign of y-component
          	8 y of y-component
          */
          match[1] = match[1].toLowerCase();

          if (match[1].slice(0, 3) === "nth") {
            // nth-* requires argument
            if (!match[3]) {
              Sizzle.error(match[0]);
            } // numeric x and y parameters for Expr.filter.CHILD
            // remember that false/true cast respectively to 0/1


            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +(match[7] + match[8] || match[3] === "odd"); // other types prohibit arguments
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }

          return match;
        },
        "PSEUDO": function PSEUDO(match) {
          var excess,
              unquoted = !match[6] && match[2];

          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          } // Accept quoted arguments as-is


          if (match[3]) {
            match[2] = match[4] || match[5] || ""; // Strip excess characters from unquoted arguments
          } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)
          excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis
          excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            // excess is a negative index
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          } // Return only captures needed by the pseudo filter method (type and argument)


          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function TAG(nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function () {
            return true;
          } : function (elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function CLASS(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function ATTR(name, operator, check) {
          return function (elem) {
            var result = Sizzle.attr(elem, name);

            if (result == null) {
              return operator === "!=";
            }

            if (!operator) {
              return true;
            }

            result += "";
            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
          };
        },
        "CHILD": function CHILD(type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
          return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
          function (elem) {
            return !!elem.parentNode;
          } : function (elem, context, xml) {
            var cache,
                uniqueCache,
                outerCache,
                node,
                nodeIndex,
                start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType,
                diff = false;

            if (parent) {
              // :(first|last|only)-(child|of-type)
              if (simple) {
                while (dir) {
                  node = elem;

                  while (node = node[dir]) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  } // Reverse direction for :only-* (if we haven't yet done so)


                  start = dir = type === "only" && !start && "nextSibling";
                }

                return true;
              }

              start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`

              if (forward && useCache) {
                // Seek `elem` from a previously-cached index
                // ...in a gzip-friendly way
                node = parent;
                outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                // Defend against cloned attroperties (jQuery gh-1709)

                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];

                while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start
                diff = nodeIndex = 0) || start.pop()) {
                  // When found, cache indexes on `parent` and break
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    uniqueCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else {
                // Use previously-cached element index if available
                if (useCache) {
                  // ...in a gzip-friendly way
                  node = elem;
                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                  // Defend against cloned attroperties (jQuery gh-1709)

                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex;
                } // xml :nth-child(...)
                // or :nth-last-child(...) or :nth(-last)?-of-type(...)


                if (diff === false) {
                  // Use the same loop as above to seek `elem` from the start
                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                      // Cache the index of each encountered element
                      if (useCache) {
                        outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                        // Defend against cloned attroperties (jQuery gh-1709)

                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        uniqueCache[type] = [dirruns, diff];
                      }

                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
              } // Incorporate the offset, then check against cycle size


              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            }
          };
        },
        "PSEUDO": function PSEUDO(pseudo, argument) {
          // pseudo-class names are case-insensitive
          // http://www.w3.org/TR/selectors/#pseudo-classes
          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
          // Remember that setFilters inherits from pseudos
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo); // The user may use createPseudo to indicate that
          // arguments are needed to create the filter function
          // just as Sizzle does

          if (fn[expando]) {
            return fn(argument);
          } // But maintain support for old signatures


          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;

              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function (elem) {
              return fn(elem, 0, args);
            };
          }

          return fn;
        }
      },
      pseudos: {
        // Potentially complex pseudos
        "not": markFunction(function (selector) {
          // Trim the selector passed to compile
          // to avoid treating leading and trailing
          // spaces as combinators
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length; // Match elements unmatched by `matcher`

            while (i--) {
              if (elem = unmatched[i]) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function (elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results); // Don't keep the element (issue #299)

            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function (text) {
          text = text.replace(runescape, funescape);
          return function (elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        // "Whether an element is represented by a :lang() selector
        // is based solely on the element's language value
        // being equal to the identifier C,
        // or beginning with the identifier C immediately followed by "-".
        // The matching of C against the element's language value is performed case-insensitively.
        // The identifier C does not have to be a valid language name."
        // http://www.w3.org/TR/selectors/#lang-pseudo
        "lang": markFunction(function (lang) {
          // lang value must be a valid identifier
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }

          lang = lang.replace(runescape, funescape).toLowerCase();
          return function (elem) {
            var elemLang;

            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);

            return false;
          };
        }),
        // Miscellaneous
        "target": function target(elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function root(elem) {
          return elem === docElem;
        },
        "focus": function focus(elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        // Boolean properties
        "enabled": createDisabledPseudo(false),
        "disabled": createDisabledPseudo(true),
        "checked": function checked(elem) {
          // In CSS3, :checked should return both checked and selected elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          var nodeName = elem.nodeName.toLowerCase();
          return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
        },
        "selected": function selected(elem) {
          // Accessing this property makes selected-by-default
          // options in Safari work properly
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }

          return elem.selected === true;
        },
        // Contents
        "empty": function empty(elem) {
          // http://www.w3.org/TR/selectors/#empty-pseudo
          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
          //   but not by others (comment: 8; processing instruction: 7; etc.)
          // nodeType < 6 works because attributes (2) do not appear as children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }

          return true;
        },
        "parent": function parent(elem) {
          return !Expr.pseudos["empty"](elem);
        },
        // Element/input types
        "header": function header(elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function input(elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function button(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function text(elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ( // Support: IE<8
          // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
          (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        // Position-in-collection
        "first": createPositionalPseudo(function () {
          return [0];
        }),
        "last": createPositionalPseudo(function (matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function (matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function (matchIndexes, length) {
          var i = 0;

          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function (matchIndexes, length) {
          var i = 1;

          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;

          for (; --i >= 0;) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;

          for (; ++i < length;) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"]; // Add button/input type pseudos

    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }

    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    } // Easy API for creating new setFilters


    function setFilters() {}

    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();

    tokenize = Sizzle.tokenize = function (selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];

      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }

      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;

      while (soFar) {
        // Comma and first run
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            // Don't consume trailing commas as valid
            soFar = soFar.slice(match[0].length) || soFar;
          }

          groups.push(tokens = []);
        }

        matched = false; // Combinators

        if (match = rcombinators.exec(soFar)) {
          matched = match.shift();
          tokens.push({
            value: matched,
            // Cast descendant combinators to space
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        } // Filters


        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }

        if (!matched) {
          break;
        }
      } // Return the length of the invalid excess
      // if we're just parsing
      // Otherwise, throw an error or return tokens


      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
      tokenCache(selector, groups).slice(0);
    };

    function toSelector(tokens) {
      var i = 0,
          len = tokens.length,
          selector = "";

      for (; i < len; i++) {
        selector += tokens[i].value;
      }

      return selector;
    }

    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          skip = combinator.next,
          key = skip || dir,
          checkNonElements = base && key === "parentNode",
          doneName = done++;
      return combinator.first ? // Check against closest ancestor/preceding element
      function (elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }

        return false;
      } : // Check against all ancestor/preceding elements
      function (elem, context, xml) {
        var oldCache,
            uniqueCache,
            outerCache,
            newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching

        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only
              // Defend against cloned attroperties (jQuery gh-1709)

              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

              if (skip && skip === elem.nodeName.toLowerCase()) {
                elem = elem[dir] || elem;
              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                // Assign to newCache so results back-propagate to previous elements
                return newCache[2] = oldCache[2];
              } else {
                // Reuse newcache so results back-propagate to previous elements
                uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking

                if (newCache[2] = matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          }
        }

        return false;
      };
    }

    function elementMatcher(matchers) {
      return matchers.length > 1 ? function (elem, context, xml) {
        var i = matchers.length;

        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }

        return true;
      } : matchers[0];
    }

    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;

      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }

      return results;
    }

    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;

      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);

            if (mapped) {
              map.push(i);
            }
          }
        }
      }

      return newUnmatched;
    }

    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }

      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }

      return markFunction(function (seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            // Get initial elements from seed or context
        elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            // Prefilter to get matcher input, preserving a map for seed-results synchronization
        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
        postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
        [] : // ...otherwise use results directly
        results : matcherIn; // Find primary matches

        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        } // Apply postFilter


        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn

          i = temp.length;

          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }

        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              // Get the final matcherOut by condensing this intermediate into postFinder contexts
              temp = [];
              i = matcherOut.length;

              while (i--) {
                if (elem = matcherOut[i]) {
                  // Restore matcherIn since elem is not yet a final match
                  temp.push(matcherIn[i] = elem);
                }
              }

              postFinder(null, matcherOut = [], temp, xml);
            } // Move matched elements from seed to results to keep them synchronized


            i = matcherOut.length;

            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          } // Add elements to results, through postFinder if defined

        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);

          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }

    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          // The foundational matcher ensures that elements are reachable from top-level context(s)
      matchContext = addCombinator(function (elem) {
        return elem === checkContext;
      }, implicitRelative, true),
          matchAnyContext = addCombinator(function (elem) {
        return indexOf(checkContext, elem) > -1;
      }, implicitRelative, true),
          matchers = [function (elem, context, xml) {
        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)

        checkContext = null;
        return ret;
      }];

      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher

          if (matcher[expando]) {
            // Find the next relative operator (if any) for proper handling
            j = ++i;

            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }

            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`
            tokens.slice(0, i - 1).concat({
              value: tokens[i - 2].type === " " ? "*" : ""
            })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
          }

          matchers.push(matcher);
        }
      }

      return elementMatcher(matchers);
    }

    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function superMatcher(seed, context, xml, results, outermost) {
        var elem,
            j,
            matcher,
            matchedCount = 0,
            i = "0",
            unmatched = seed && [],
            setMatched = [],
            contextBackup = outermostContext,
            // We must always have either seed elements or outermost context
        elems = seed || byElement && Expr.find["TAG"]("*", outermost),
            // Use integer dirruns iff this is the outermost matcher
        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
            len = elems.length;

        if (outermost) {
          outermostContext = context === document || context || outermost;
        } // Add elements passing elementMatchers directly to results
        // Support: IE<9, Safari
        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id


        for (; i !== len && (elem = elems[i]) != null; i++) {
          if (byElement && elem) {
            j = 0;

            if (!context && elem.ownerDocument !== document) {
              setDocument(elem);
              xml = !documentIsHTML;
            }

            while (matcher = elementMatchers[j++]) {
              if (matcher(elem, context || document, xml)) {
                results.push(elem);
                break;
              }
            }

            if (outermost) {
              dirruns = dirrunsUnique;
            }
          } // Track unmatched elements for set filters


          if (bySet) {
            // They will have gone through all possible matchers
            if (elem = !matcher && elem) {
              matchedCount--;
            } // Lengthen the array for every element, matched or not


            if (seed) {
              unmatched.push(elem);
            }
          }
        } // `i` is now the count of elements visited above, and adding it to `matchedCount`
        // makes the latter nonnegative.


        matchedCount += i; // Apply set filters to unmatched elements
        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
        // no element matchers and no seed.
        // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
        // case, which will result in a "00" `matchedCount` that differs from `i` but is also
        // numerically zero.

        if (bySet && i !== matchedCount) {
          j = 0;

          while (matcher = setMatchers[j++]) {
            matcher(unmatched, setMatched, context, xml);
          }

          if (seed) {
            // Reintegrate element matches to eliminate the need for sorting
            if (matchedCount > 0) {
              while (i--) {
                if (!(unmatched[i] || setMatched[i])) {
                  setMatched[i] = pop.call(results);
                }
              }
            } // Discard index placeholder values to get only actual matches


            setMatched = condense(setMatched);
          } // Add matches to results


          push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting

          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
            Sizzle.uniqueSort(results);
          }
        } // Override manipulation of globals by nested matchers


        if (outermost) {
          dirruns = dirrunsUnique;
          outermostContext = contextBackup;
        }

        return unmatched;
      };

      return bySet ? markFunction(superMatcher) : superMatcher;
    }

    compile = Sizzle.compile = function (selector, match
    /* Internal Use Only */
    ) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];

      if (!cached) {
        // Generate a function of recursive functions that can be used to check each element
        if (!match) {
          match = tokenize(selector);
        }

        i = match.length;

        while (i--) {
          cached = matcherFromTokens(match[i]);

          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        } // Cache the compiled function


        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization

        cached.selector = selector;
      }

      return cached;
    };
    /**
     * A low-level selection function that works with Sizzle's compiled
     *  selector functions
     * @param {String|Function} selector A selector or a pre-compiled
     *  selector function built with Sizzle.compile
     * @param {Element} context
     * @param {Array} [results]
     * @param {Array} [seed] A set of elements to match against
     */


    select = Sizzle.select = function (selector, context, results, seed) {
      var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize(selector = compiled.selector || selector);
      results = results || []; // Try to minimize operations if there is only one selector in the list and no seed
      // (the latter of which guarantees us context)

      if (match.length === 1) {
        // Reduce context if the leading compound selector is an ID
        tokens = match[0] = match[0].slice(0);

        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];

          if (!context) {
            return results; // Precompiled matchers will still verify ancestry, so step up a level
          } else if (compiled) {
            context = context.parentNode;
          }

          selector = selector.slice(tokens.shift().value.length);
        } // Fetch a seed set for right-to-left matching


        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;

        while (i--) {
          token = tokens[i]; // Abort if we hit a combinator

          if (Expr.relative[type = token.type]) {
            break;
          }

          if (find = Expr.find[type]) {
            // Search, expanding context for leading sibling combinators
            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
              // If seed is empty or no tokens remain, we can return early
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);

              if (!selector) {
                push.apply(results, seed);
                return results;
              }

              break;
            }
          }
        }
      } // Compile and execute a filtering function if one is not provided
      // Provide `match` to avoid retokenization if we modified the selector above


      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    }; // One-time assignments
    // Sort stability


    support.sortStable = expando.split("").sort(sortOrder).join("") === expando; // Support: Chrome 14-35+
    // Always assume duplicates if they aren't passed to the comparison function

    support.detectDuplicates = !!hasDuplicate; // Initialize against the default document

    setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
    // Detached nodes confoundingly follow *each other*

    support.sortDetached = assert(function (el) {
      // Should return 1, but returns 4 (following)
      return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
    }); // Support: IE<8
    // Prevent attribute/property "interpolation"
    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx

    if (!assert(function (el) {
      el.innerHTML = "<a href='#'></a>";
      return el.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function (elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    } // Support: IE<9
    // Use defaultValue in place of getAttribute("value")


    if (!support.attributes || !assert(function (el) {
      el.innerHTML = "<input/>";
      el.firstChild.setAttribute("value", "");
      return el.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function (elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    } // Support: IE<9
    // Use getAttributeNode to fetch booleans when getAttribute lies


    if (!assert(function (el) {
      return el.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function (elem, name, isXML) {
        var val;

        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }

    return Sizzle;
  }(window);

  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors; // Deprecated

  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  jQuery.escapeSelector = Sizzle.escape;

  var dir = function dir(elem, _dir, until) {
    var matched = [],
        truncate = until !== undefined;

    while ((elem = elem[_dir]) && elem.nodeType !== 9) {
      if (elem.nodeType === 1) {
        if (truncate && jQuery(elem).is(until)) {
          break;
        }

        matched.push(elem);
      }
    }

    return matched;
  };

  var _siblings = function siblings(n, elem) {
    var matched = [];

    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        matched.push(n);
      }
    }

    return matched;
  };

  var rneedsContext = jQuery.expr.match.needsContext;

  function nodeName(elem, name) {
    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
  }

  ;
  var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; // Implement the identical functionality for filter and not

  function winnow(elements, qualifier, not) {
    if (isFunction(qualifier)) {
      return jQuery.grep(elements, function (elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    } // Single element


    if (qualifier.nodeType) {
      return jQuery.grep(elements, function (elem) {
        return elem === qualifier !== not;
      });
    } // Arraylike of elements (jQuery, arguments, Array)


    if (typeof qualifier !== "string") {
      return jQuery.grep(elements, function (elem) {
        return indexOf.call(qualifier, elem) > -1 !== not;
      });
    } // Filtered directly for both simple and complex selectors


    return jQuery.filter(qualifier, elements, not);
  }

  jQuery.filter = function (expr, elems, not) {
    var elem = elems[0];

    if (not) {
      expr = ":not(" + expr + ")";
    }

    if (elems.length === 1 && elem.nodeType === 1) {
      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
    }

    return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
      return elem.nodeType === 1;
    }));
  };

  jQuery.fn.extend({
    find: function find(selector) {
      var i,
          ret,
          len = this.length,
          self = this;

      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function () {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }

      ret = this.pushStack([]);

      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }

      return len > 1 ? jQuery.uniqueSort(ret) : ret;
    },
    filter: function filter(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function not(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function is(selector) {
      return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
      // so $("p:first").is("p:last") won't return true for a doc with two "p".
      typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  }); // Initialize a jQuery object
  // A central reference to the root jQuery(document)

  var rootjQuery,
      // A simple way to check for HTML strings
  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
  // Strict HTML recognition (#11290: must start with <)
  // Shortcut simple #id case for speed
  rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
      init = jQuery.fn.init = function (selector, context, root) {
    var match, elem; // HANDLE: $(""), $(null), $(undefined), $(false)

    if (!selector) {
      return this;
    } // Method init() accepts an alternate rootjQuery
    // so migrate can support jQuery.sub (gh-2101)


    root = root || rootjQuery; // Handle HTML strings

    if (typeof selector === "string") {
      if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
        // Assume that strings that start and end with <> are HTML and skip the regex check
        match = [null, selector, null];
      } else {
        match = rquickExpr.exec(selector);
      } // Match html or make sure no context is specified for #id


      if (match && (match[1] || !context)) {
        // HANDLE: $(html) -> $(array)
        if (match[1]) {
          context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat
          // Intentionally let the error be thrown if parseHTML is not present

          jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)

          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
            for (match in context) {
              // Properties of context are called as methods if possible
              if (isFunction(this[match])) {
                this[match](context[match]); // ...and otherwise set as attributes
              } else {
                this.attr(match, context[match]);
              }
            }
          }

          return this; // HANDLE: $(#id)
        } else {
          elem = document.getElementById(match[2]);

          if (elem) {
            // Inject the element directly into the jQuery object
            this[0] = elem;
            this.length = 1;
          }

          return this;
        } // HANDLE: $(expr, $(...))

      } else if (!context || context.jquery) {
        return (context || root).find(selector); // HANDLE: $(expr, context)
        // (which is just equivalent to: $(context).find(expr)
      } else {
        return this.constructor(context).find(selector);
      } // HANDLE: $(DOMElement)

    } else if (selector.nodeType) {
      this[0] = selector;
      this.length = 1;
      return this; // HANDLE: $(function)
      // Shortcut for document ready
    } else if (isFunction(selector)) {
      return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
      selector(jQuery);
    }

    return jQuery.makeArray(selector, this);
  }; // Give the init function the jQuery prototype for later instantiation


  init.prototype = jQuery.fn; // Initialize central reference

  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      // Methods guaranteed to produce a unique set when starting from a unique set
  guaranteedUnique = {
    children: true,
    contents: true,
    next: true,
    prev: true
  };
  jQuery.fn.extend({
    has: function has(target) {
      var targets = jQuery(target, this),
          l = targets.length;
      return this.filter(function () {
        var i = 0;

        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function closest(selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          targets = typeof selectors !== "string" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context

      if (!rneedsContext.test(selectors)) {
        for (; i < l; i++) {
          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
            // Always skip document fragments
            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle
            cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
              matched.push(cur);
              break;
            }
          }
        }
      }

      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
    },
    // Determine the position of an element within the set
    index: function index(elem) {
      // No argument, return index in parent
      if (!elem) {
        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
      } // Index in selector


      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      } // Locate the position of the desired element


      return indexOf.call(this, // If it receives a jQuery object, the first element is used
      elem.jquery ? elem[0] : elem);
    },
    add: function add(selector, context) {
      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function addBack(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });

  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}

    return cur;
  }

  jQuery.each({
    parent: function parent(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function parents(elem) {
      return dir(elem, "parentNode");
    },
    parentsUntil: function parentsUntil(elem, i, until) {
      return dir(elem, "parentNode", until);
    },
    next: function next(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function prev(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function nextAll(elem) {
      return dir(elem, "nextSibling");
    },
    prevAll: function prevAll(elem) {
      return dir(elem, "previousSibling");
    },
    nextUntil: function nextUntil(elem, i, until) {
      return dir(elem, "nextSibling", until);
    },
    prevUntil: function prevUntil(elem, i, until) {
      return dir(elem, "previousSibling", until);
    },
    siblings: function siblings(elem) {
      return _siblings((elem.parentNode || {}).firstChild, elem);
    },
    children: function children(elem) {
      return _siblings(elem.firstChild);
    },
    contents: function contents(elem) {
      if (nodeName(elem, "iframe")) {
        return elem.contentDocument;
      } // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
      // Treat the template element as a regular one in browsers that
      // don't support it.


      if (nodeName(elem, "template")) {
        elem = elem.content || elem;
      }

      return jQuery.merge([], elem.childNodes);
    }
  }, function (name, fn) {
    jQuery.fn[name] = function (until, selector) {
      var matched = jQuery.map(this, fn, until);

      if (name.slice(-5) !== "Until") {
        selector = until;
      }

      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }

      if (this.length > 1) {
        // Remove duplicates
        if (!guaranteedUnique[name]) {
          jQuery.uniqueSort(matched);
        } // Reverse order for parents* and prev-derivatives


        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }

      return this.pushStack(matched);
    };
  });
  var rnothtmlwhite = /[^\x20\t\r\n\f]+/g; // Convert String-formatted options into Object-formatted ones

  function createOptions(options) {
    var object = {};
    jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
      object[flag] = true;
    });
    return object;
  }
  /*
   * Create a callback list using the following parameters:
   *
   *	options: an optional list of space-separated options that will change how
   *			the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *	once:			will ensure the callback list can only be fired once (like a Deferred)
   *
   *	memory:			will keep track of previous values and will call any callback added
   *					after the list has been fired right away with the latest "memorized"
   *					values (like a Deferred)
   *
   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
   *
   *	stopOnFalse:	interrupt callings when a callback returns false
   *
   */


  jQuery.Callbacks = function (options) {
    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

    var // Flag to know if list is currently firing
    firing,
        // Last fire value for non-forgettable lists
    memory,
        // Flag to know if list was already fired
    _fired,
        // Flag to prevent firing
    _locked,
        // Actual callback list
    list = [],
        // Queue of execution data for repeatable lists
    queue = [],
        // Index of currently firing callback (modified by add/remove as needed)
    firingIndex = -1,
        // Fire callbacks
    fire = function fire() {
      // Enforce single-firing
      _locked = _locked || options.once; // Execute callbacks for all pending executions,
      // respecting firingIndex overrides and runtime changes

      _fired = firing = true;

      for (; queue.length; firingIndex = -1) {
        memory = queue.shift();

        while (++firingIndex < list.length) {
          // Run callback and check for early termination
          if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
            // Jump to end and forget the data so .add doesn't re-fire
            firingIndex = list.length;
            memory = false;
          }
        }
      } // Forget the data if we're done with it


      if (!options.memory) {
        memory = false;
      }

      firing = false; // Clean up if we're done firing for good

      if (_locked) {
        // Keep an empty list if we have data for future add calls
        if (memory) {
          list = []; // Otherwise, this object is spent
        } else {
          list = "";
        }
      }
    },
        // Actual Callbacks object
    self = {
      // Add a callback or a collection of callbacks to the list
      add: function add() {
        if (list) {
          // If we have memory from a past run, we should fire after adding
          if (memory && !firing) {
            firingIndex = list.length - 1;
            queue.push(memory);
          }

          (function add(args) {
            jQuery.each(args, function (_, arg) {
              if (isFunction(arg)) {
                if (!options.unique || !self.has(arg)) {
                  list.push(arg);
                }
              } else if (arg && arg.length && toType(arg) !== "string") {
                // Inspect recursively
                add(arg);
              }
            });
          })(arguments);

          if (memory && !firing) {
            fire();
          }
        }

        return this;
      },
      // Remove a callback from the list
      remove: function remove() {
        jQuery.each(arguments, function (_, arg) {
          var index;

          while ((index = jQuery.inArray(arg, list, index)) > -1) {
            list.splice(index, 1); // Handle firing indexes

            if (index <= firingIndex) {
              firingIndex--;
            }
          }
        });
        return this;
      },
      // Check if a given callback is in the list.
      // If no argument is given, return whether or not list has callbacks attached.
      has: function has(fn) {
        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
      },
      // Remove all callbacks from the list
      empty: function empty() {
        if (list) {
          list = [];
        }

        return this;
      },
      // Disable .fire and .add
      // Abort any current/pending executions
      // Clear all callbacks and values
      disable: function disable() {
        _locked = queue = [];
        list = memory = "";
        return this;
      },
      disabled: function disabled() {
        return !list;
      },
      // Disable .fire
      // Also disable .add unless we have memory (since it would have no effect)
      // Abort any pending executions
      lock: function lock() {
        _locked = queue = [];

        if (!memory && !firing) {
          list = memory = "";
        }

        return this;
      },
      locked: function locked() {
        return !!_locked;
      },
      // Call all callbacks with the given context and arguments
      fireWith: function fireWith(context, args) {
        if (!_locked) {
          args = args || [];
          args = [context, args.slice ? args.slice() : args];
          queue.push(args);

          if (!firing) {
            fire();
          }
        }

        return this;
      },
      // Call all the callbacks with the given arguments
      fire: function fire() {
        self.fireWith(this, arguments);
        return this;
      },
      // To know if the callbacks have already been called at least once
      fired: function fired() {
        return !!_fired;
      }
    };

    return self;
  };

  function Identity(v) {
    return v;
  }

  function Thrower(ex) {
    throw ex;
  }

  function adoptValue(value, resolve, reject, noValue) {
    var method;

    try {
      // Check for promise aspect first to privilege synchronous behavior
      if (value && isFunction(method = value.promise)) {
        method.call(value).done(resolve).fail(reject); // Other thenables
      } else if (value && isFunction(method = value.then)) {
        method.call(value, resolve, reject); // Other non-thenables
      } else {
        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
        // * false: [ value ].slice( 0 ) => resolve( value )
        // * true: [ value ].slice( 1 ) => resolve()
        resolve.apply(undefined, [value].slice(noValue));
      } // For Promises/A+, convert exceptions into rejections
      // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
      // Deferred#then to conditionally suppress rejection.

    } catch (value) {
      // Support: Android 4.0 only
      // Strict mode functions invoked without .call/.apply get global-object context
      reject.apply(undefined, [value]);
    }
  }

  jQuery.extend({
    Deferred: function Deferred(func) {
      var tuples = [// action, add listener, callbacks,
      // ... .then handlers, argument index, [final state]
      ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
          _state = "pending",
          _promise = {
        state: function state() {
          return _state;
        },
        always: function always() {
          deferred.done(arguments).fail(arguments);
          return this;
        },
        "catch": function _catch(fn) {
          return _promise.then(null, fn);
        },
        // Keep pipe for back-compat
        pipe: function pipe()
        /* fnDone, fnFail, fnProgress */
        {
          var fns = arguments;
          return jQuery.Deferred(function (newDefer) {
            jQuery.each(tuples, function (i, tuple) {
              // Map tuples (progress, done, fail) to arguments (done, fail, progress)
              var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })
              // deferred.done(function() { bind to newDefer or newDefer.resolve })
              // deferred.fail(function() { bind to newDefer or newDefer.reject })

              deferred[tuple[1]](function () {
                var returned = fn && fn.apply(this, arguments);

                if (returned && isFunction(returned.promise)) {
                  returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                } else {
                  newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                }
              });
            });
            fns = null;
          }).promise();
        },
        then: function then(onFulfilled, onRejected, onProgress) {
          var maxDepth = 0;

          function resolve(depth, deferred, handler, special) {
            return function () {
              var that = this,
                  args = arguments,
                  mightThrow = function mightThrow() {
                var returned, then; // Support: Promises/A+ section 2.3.3.3.3
                // https://promisesaplus.com/#point-59
                // Ignore double-resolution attempts

                if (depth < maxDepth) {
                  return;
                }

                returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1
                // https://promisesaplus.com/#point-48

                if (returned === deferred.promise()) {
                  throw new TypeError("Thenable self-resolution");
                } // Support: Promises/A+ sections 2.3.3.1, 3.5
                // https://promisesaplus.com/#point-54
                // https://promisesaplus.com/#point-75
                // Retrieve `then` only once


                then = returned && ( // Support: Promises/A+ section 2.3.4
                // https://promisesaplus.com/#point-64
                // Only check objects and functions for thenability
                _typeof(returned) === "object" || typeof returned === "function") && returned.then; // Handle a returned thenable

                if (isFunction(then)) {
                  // Special processors (notify) just wait for resolution
                  if (special) {
                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress
                  } else {
                    // ...and disregard older resolution values
                    maxDepth++;
                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                  } // Handle all other returned values

                } else {
                  // Only substitute handlers pass on context
                  // and multiple values (non-spec behavior)
                  if (handler !== Identity) {
                    that = undefined;
                    args = [returned];
                  } // Process the value(s)
                  // Default process is resolve


                  (special || deferred.resolveWith)(that, args);
                }
              },
                  // Only normal processors (resolve) catch and reject exceptions
              process = special ? mightThrow : function () {
                try {
                  mightThrow();
                } catch (e) {
                  if (jQuery.Deferred.exceptionHook) {
                    jQuery.Deferred.exceptionHook(e, process.stackTrace);
                  } // Support: Promises/A+ section 2.3.3.3.4.1
                  // https://promisesaplus.com/#point-61
                  // Ignore post-resolution exceptions


                  if (depth + 1 >= maxDepth) {
                    // Only substitute handlers pass on context
                    // and multiple values (non-spec behavior)
                    if (handler !== Thrower) {
                      that = undefined;
                      args = [e];
                    }

                    deferred.rejectWith(that, args);
                  }
                }
              }; // Support: Promises/A+ section 2.3.3.3.1
              // https://promisesaplus.com/#point-57
              // Re-resolve promises immediately to dodge false rejection from
              // subsequent errors


              if (depth) {
                process();
              } else {
                // Call an optional hook to record the stack, in case of exception
                // since it's otherwise lost when execution goes async
                if (jQuery.Deferred.getStackHook) {
                  process.stackTrace = jQuery.Deferred.getStackHook();
                }

                window.setTimeout(process);
              }
            };
          }

          return jQuery.Deferred(function (newDefer) {
            // progress_handlers.add( ... )
            tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )

            tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )

            tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
          }).promise();
        },
        // Get a promise for this deferred
        // If obj is provided, the promise aspect is added to the object
        promise: function promise(obj) {
          return obj != null ? jQuery.extend(obj, _promise) : _promise;
        }
      },
          deferred = {}; // Add list-specific methods

      jQuery.each(tuples, function (i, tuple) {
        var list = tuple[2],
            stateString = tuple[5]; // promise.progress = list.add
        // promise.done = list.add
        // promise.fail = list.add

        _promise[tuple[1]] = list.add; // Handle state

        if (stateString) {
          list.add(function () {
            // state = "resolved" (i.e., fulfilled)
            // state = "rejected"
            _state = stateString;
          }, // rejected_callbacks.disable
          // fulfilled_callbacks.disable
          tuples[3 - i][2].disable, // rejected_handlers.disable
          // fulfilled_handlers.disable
          tuples[3 - i][3].disable, // progress_callbacks.lock
          tuples[0][2].lock, // progress_handlers.lock
          tuples[0][3].lock);
        } // progress_handlers.fire
        // fulfilled_handlers.fire
        // rejected_handlers.fire


        list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }
        // deferred.resolve = function() { deferred.resolveWith(...) }
        // deferred.reject = function() { deferred.rejectWith(...) }

        deferred[tuple[0]] = function () {
          deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
          return this;
        }; // deferred.notifyWith = list.fireWith
        // deferred.resolveWith = list.fireWith
        // deferred.rejectWith = list.fireWith


        deferred[tuple[0] + "With"] = list.fireWith;
      }); // Make the deferred a promise

      _promise.promise(deferred); // Call given func if any


      if (func) {
        func.call(deferred, deferred);
      } // All done!


      return deferred;
    },
    // Deferred helper
    when: function when(singleValue) {
      var // count of uncompleted subordinates
      remaining = arguments.length,
          // count of unprocessed arguments
      i = remaining,
          // subordinate fulfillment data
      resolveContexts = Array(i),
          resolveValues = _slice.call(arguments),
          // the master Deferred
      master = jQuery.Deferred(),
          // subordinate callback factory
      updateFunc = function updateFunc(i) {
        return function (value) {
          resolveContexts[i] = this;
          resolveValues[i] = arguments.length > 1 ? _slice.call(arguments) : value;

          if (! --remaining) {
            master.resolveWith(resolveContexts, resolveValues);
          }
        };
      }; // Single- and empty arguments are adopted like Promise.resolve


      if (remaining <= 1) {
        adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)

        if (master.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
          return master.then();
        }
      } // Multiple arguments are aggregated like Promise.all array elements


      while (i--) {
        adoptValue(resolveValues[i], updateFunc(i), master.reject);
      }

      return master.promise();
    }
  }); // These usually indicate a programmer mistake during development,
  // warn about them ASAP rather than swallowing them by default.

  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

  jQuery.Deferred.exceptionHook = function (error, stack) {
    // Support: IE 8 - 9 only
    // Console exists when dev tools are open, which can happen at any time
    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
      window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    }
  };

  jQuery.readyException = function (error) {
    window.setTimeout(function () {
      throw error;
    });
  }; // The deferred used on DOM ready


  var readyList = jQuery.Deferred();

  jQuery.fn.ready = function (fn) {
    readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup
    // happens at the time of error handling instead of callback
    // registration.
    .catch(function (error) {
      jQuery.readyException(error);
    });
    return this;
  };

  jQuery.extend({
    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: false,
    // A counter to track how many items to wait for before
    // the ready event fires. See #6781
    readyWait: 1,
    // Handle when the DOM is ready
    ready: function ready(wait) {
      // Abort if there are pending holds or we're already ready
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      } // Remember that the DOM is ready


      jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be

      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      } // If there are functions bound, to execute


      readyList.resolveWith(document, [jQuery]);
    }
  });
  jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method

  function completed() {
    document.removeEventListener("DOMContentLoaded", completed);
    window.removeEventListener("load", completed);
    jQuery.ready();
  } // Catch cases where $(document).ready() is called
  // after the browser event has already occurred.
  // Support: IE <=9 - 10 only
  // Older IE sometimes signals "interactive" too soon


  if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
    // Handle it asynchronously to allow scripts the opportunity to delay ready
    window.setTimeout(jQuery.ready);
  } else {
    // Use the handy event callback
    document.addEventListener("DOMContentLoaded", completed); // A fallback to window.onload, that will always work

    window.addEventListener("load", completed);
  } // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function


  var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        len = elems.length,
        bulk = key == null; // Sets many values

    if (toType(key) === "object") {
      chainable = true;

      for (i in key) {
        access(elems, fn, i, key[i], true, emptyGet, raw);
      } // Sets one value

    } else if (value !== undefined) {
      chainable = true;

      if (!isFunction(value)) {
        raw = true;
      }

      if (bulk) {
        // Bulk operations run against the entire set
        if (raw) {
          fn.call(elems, value);
          fn = null; // ...except when executing function values
        } else {
          bulk = fn;

          fn = function fn(elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }

      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }

    if (chainable) {
      return elems;
    } // Gets


    if (bulk) {
      return fn.call(elems);
    }

    return len ? fn(elems[0], key) : emptyGet;
  }; // Matches dashed string for camelizing


  var rmsPrefix = /^-ms-/,
      rdashAlpha = /-([a-z])/g; // Used by camelCase as callback to replace()

  function fcamelCase(all, letter) {
    return letter.toUpperCase();
  } // Convert dashed to camelCase; used by the css and data modules
  // Support: IE <=9 - 11, Edge 12 - 15
  // Microsoft forgot to hump their vendor prefix (#9572)


  function camelCase(string) {
    return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
  }

  var acceptData = function acceptData(owner) {
    // Accepts only:
    //  - Node
    //    - Node.ELEMENT_NODE
    //    - Node.DOCUMENT_NODE
    //  - Object
    //    - Any
    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
  };

  function Data() {
    this.expando = jQuery.expando + Data.uid++;
  }

  Data.uid = 1;
  Data.prototype = {
    cache: function cache(owner) {
      // Check if the owner object already has a cache
      var value = owner[this.expando]; // If not, create one

      if (!value) {
        value = {}; // We can accept data for non-element nodes in modern browsers,
        // but we should not, see #8335.
        // Always return an empty object.

        if (acceptData(owner)) {
          // If it is a node unlikely to be stringify-ed or looped over
          // use plain assignment
          if (owner.nodeType) {
            owner[this.expando] = value; // Otherwise secure it in a non-enumerable property
            // configurable must be true to allow the property to be
            // deleted when data is removed
          } else {
            Object.defineProperty(owner, this.expando, {
              value: value,
              configurable: true
            });
          }
        }
      }

      return value;
    },
    set: function set(owner, data, value) {
      var prop,
          cache = this.cache(owner); // Handle: [ owner, key, value ] args
      // Always use camelCase key (gh-2257)

      if (typeof data === "string") {
        cache[camelCase(data)] = value; // Handle: [ owner, { properties } ] args
      } else {
        // Copy the properties one-by-one to the cache object
        for (prop in data) {
          cache[camelCase(prop)] = data[prop];
        }
      }

      return cache;
    },
    get: function get(owner, key) {
      return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
      owner[this.expando] && owner[this.expando][camelCase(key)];
    },
    access: function access(owner, key, value) {
      // In cases where either:
      //
      //   1. No key was specified
      //   2. A string key was specified, but no value provided
      //
      // Take the "read" path and allow the get method to determine
      // which value to return, respectively either:
      //
      //   1. The entire cache object
      //   2. The data stored at the key
      //
      if (key === undefined || key && typeof key === "string" && value === undefined) {
        return this.get(owner, key);
      } // When the key is not a string, or both a key and value
      // are specified, set or extend (existing objects) with either:
      //
      //   1. An object of properties
      //   2. A key and value
      //


      this.set(owner, key, value); // Since the "set" path can have two possible entry points
      // return the expected data based on which path was taken[*]

      return value !== undefined ? value : key;
    },
    remove: function remove(owner, key) {
      var i,
          cache = owner[this.expando];

      if (cache === undefined) {
        return;
      }

      if (key !== undefined) {
        // Support array or space separated string of keys
        if (Array.isArray(key)) {
          // If key is an array of keys...
          // We always set camelCase keys, so remove that.
          key = key.map(camelCase);
        } else {
          key = camelCase(key); // If a key with the spaces exists, use it.
          // Otherwise, create an array by matching non-whitespace

          key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
        }

        i = key.length;

        while (i--) {
          delete cache[key[i]];
        }
      } // Remove the expando if there's no more data


      if (key === undefined || jQuery.isEmptyObject(cache)) {
        // Support: Chrome <=35 - 45
        // Webkit & Blink performance suffers when deleting properties
        // from DOM nodes, so set to undefined instead
        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
        if (owner.nodeType) {
          owner[this.expando] = undefined;
        } else {
          delete owner[this.expando];
        }
      }
    },
    hasData: function hasData(owner) {
      var cache = owner[this.expando];
      return cache !== undefined && !jQuery.isEmptyObject(cache);
    }
  };
  var dataPriv = new Data();
  var dataUser = new Data(); //	Implementation Summary
  //
  //	1. Enforce API surface and semantic compatibility with 1.9.x branch
  //	2. Improve the module's maintainability by reducing the storage
  //		paths to a single mechanism.
  //	3. Use the same single mechanism to support "private" and "user" data.
  //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  //	5. Avoid exposing implementation details on user objects (eg. expando properties)
  //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /[A-Z]/g;

  function getData(data) {
    if (data === "true") {
      return true;
    }

    if (data === "false") {
      return false;
    }

    if (data === "null") {
      return null;
    } // Only convert to a number if it doesn't change the string


    if (data === +data + "") {
      return +data;
    }

    if (rbrace.test(data)) {
      return JSON.parse(data);
    }

    return data;
  }

  function dataAttr(elem, key, data) {
    var name; // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute

    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
      data = elem.getAttribute(name);

      if (typeof data === "string") {
        try {
          data = getData(data);
        } catch (e) {} // Make sure we set the data so it isn't changed later


        dataUser.set(elem, key, data);
      } else {
        data = undefined;
      }
    }

    return data;
  }

  jQuery.extend({
    hasData: function hasData(elem) {
      return dataUser.hasData(elem) || dataPriv.hasData(elem);
    },
    data: function data(elem, name, _data) {
      return dataUser.access(elem, name, _data);
    },
    removeData: function removeData(elem, name) {
      dataUser.remove(elem, name);
    },
    // TODO: Now that all calls to _data and _removeData have been replaced
    // with direct calls to dataPriv methods, these can be deprecated.
    _data: function _data(elem, name, data) {
      return dataPriv.access(elem, name, data);
    },
    _removeData: function _removeData(elem, name) {
      dataPriv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function data(key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes; // Gets all values

      if (key === undefined) {
        if (this.length) {
          data = dataUser.get(elem);

          if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
            i = attrs.length;

            while (i--) {
              // Support: IE 11 only
              // The attrs elements can be null (#14894)
              if (attrs[i]) {
                name = attrs[i].name;

                if (name.indexOf("data-") === 0) {
                  name = camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }

            dataPriv.set(elem, "hasDataAttrs", true);
          }
        }

        return data;
      } // Sets multiple values


      if (_typeof(key) === "object") {
        return this.each(function () {
          dataUser.set(this, key);
        });
      }

      return access(this, function (value) {
        var data; // The calling jQuery object (element matches) is not empty
        // (and therefore has an element appears at this[ 0 ]) and the
        // `value` parameter was not undefined. An empty jQuery object
        // will result in `undefined` for elem = this[ 0 ] which will
        // throw an exception if an attempt to read a data cache is made.

        if (elem && value === undefined) {
          // Attempt to get data from the cache
          // The key will always be camelCased in Data
          data = dataUser.get(elem, key);

          if (data !== undefined) {
            return data;
          } // Attempt to "discover" the data in
          // HTML5 custom data-* attrs


          data = dataAttr(elem, key);

          if (data !== undefined) {
            return data;
          } // We tried really hard, but the data doesn't exist.


          return;
        } // Set the data...


        this.each(function () {
          // We always store the camelCased key
          dataUser.set(this, key, value);
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function removeData(key) {
      return this.each(function () {
        dataUser.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function queue(elem, type, data) {
      var queue;

      if (elem) {
        type = (type || "fx") + "queue";
        queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup

        if (data) {
          if (!queue || Array.isArray(data)) {
            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }

        return queue || [];
      }
    },
    dequeue: function dequeue(elem, type) {
      type = type || "fx";

      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function next() {
        jQuery.dequeue(elem, type);
      }; // If the fx queue is dequeued, always remove the progress sentinel


      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }

      if (fn) {
        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if (type === "fx") {
          queue.unshift("inprogress");
        } // Clear up the last queue stop function


        delete hooks.stop;
        fn.call(elem, next, hooks);
      }

      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    // Not public - generate a queueHooks object, or return the current one
    _queueHooks: function _queueHooks(elem, type) {
      var key = type + "queueHooks";
      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
        empty: jQuery.Callbacks("once memory").add(function () {
          dataPriv.remove(elem, [type + "queue", key]);
        })
      });
    }
  });
  jQuery.fn.extend({
    queue: function queue(type, data) {
      var setter = 2;

      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }

      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }

      return data === undefined ? this : this.each(function () {
        var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue

        jQuery._queueHooks(this, type);

        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function dequeue(type) {
      return this.each(function () {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function clearQueue(type) {
      return this.queue(type || "fx", []);
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function promise(type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function resolve() {
        if (! --count) {
          defer.resolveWith(elements, [elements]);
        }
      };

      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }

      type = type || "fx";

      while (i--) {
        tmp = dataPriv.get(elements[i], type + "queueHooks");

        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }

      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
  var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
  var cssExpand = ["Top", "Right", "Bottom", "Left"];

  var isHiddenWithinTree = function isHiddenWithinTree(elem, el) {
    // isHiddenWithinTree might be called from jQuery#filter function;
    // in that case, element will be second argument
    elem = el || elem; // Inline style trumps all

    return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
    // Support: Firefox <=43 - 45
    // Disconnected elements can have computed display: none, so first confirm that elem is
    // in the document.
    jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, "display") === "none";
  };

  var swap = function swap(elem, options, callback, args) {
    var ret,
        name,
        old = {}; // Remember the old values, and insert the new ones

    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }

    ret = callback.apply(elem, args || []); // Revert the old values

    for (name in options) {
      elem.style[name] = old[name];
    }

    return ret;
  };

  function adjustCSS(elem, prop, valueParts, tween) {
    var adjusted,
        scale,
        maxIterations = 20,
        currentValue = tween ? function () {
      return tween.cur();
    } : function () {
      return jQuery.css(elem, prop, "");
    },
        initial = currentValue(),
        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
        // Starting value computation is required for potential unit mismatches
    initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

    if (initialInUnit && initialInUnit[3] !== unit) {
      // Support: Firefox <=54
      // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
      initial = initial / 2; // Trust units reported by jQuery.css

      unit = unit || initialInUnit[3]; // Iteratively approximate from a nonzero starting point

      initialInUnit = +initial || 1;

      while (maxIterations--) {
        // Evaluate and update our best guess (doubling guesses that zero out).
        // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
        jQuery.style(elem, prop, initialInUnit + unit);

        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
          maxIterations = 0;
        }

        initialInUnit = initialInUnit / scale;
      }

      initialInUnit = initialInUnit * 2;
      jQuery.style(elem, prop, initialInUnit + unit); // Make sure we update the tween properties later on

      valueParts = valueParts || [];
    }

    if (valueParts) {
      initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified

      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];

      if (tween) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }

    return adjusted;
  }

  var defaultDisplayMap = {};

  function getDefaultDisplay(elem) {
    var temp,
        doc = elem.ownerDocument,
        nodeName = elem.nodeName,
        display = defaultDisplayMap[nodeName];

    if (display) {
      return display;
    }

    temp = doc.body.appendChild(doc.createElement(nodeName));
    display = jQuery.css(temp, "display");
    temp.parentNode.removeChild(temp);

    if (display === "none") {
      display = "block";
    }

    defaultDisplayMap[nodeName] = display;
    return display;
  }

  function showHide(elements, show) {
    var display,
        elem,
        values = [],
        index = 0,
        length = elements.length; // Determine new display value for elements that need to change

    for (; index < length; index++) {
      elem = elements[index];

      if (!elem.style) {
        continue;
      }

      display = elem.style.display;

      if (show) {
        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
        // check is required in this first loop unless we have a nonempty display value (either
        // inline or about-to-be-restored)
        if (display === "none") {
          values[index] = dataPriv.get(elem, "display") || null;

          if (!values[index]) {
            elem.style.display = "";
          }
        }

        if (elem.style.display === "" && isHiddenWithinTree(elem)) {
          values[index] = getDefaultDisplay(elem);
        }
      } else {
        if (display !== "none") {
          values[index] = "none"; // Remember what we're overwriting

          dataPriv.set(elem, "display", display);
        }
      }
    } // Set the display of the elements in a second loop to avoid constant reflow


    for (index = 0; index < length; index++) {
      if (values[index] != null) {
        elements[index].style.display = values[index];
      }
    }

    return elements;
  }

  jQuery.fn.extend({
    show: function show() {
      return showHide(this, true);
    },
    hide: function hide() {
      return showHide(this);
    },
    toggle: function toggle(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }

      return this.each(function () {
        if (isHiddenWithinTree(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  var rcheckableType = /^(?:checkbox|radio)$/i;
  var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;
  var rscriptType = /^$|^module$|\/(?:java|ecma)script/i; // We have to close these tags to support XHTML (#13200)

  var wrapMap = {
    // Support: IE <=9 only
    option: [1, "<select multiple='multiple'>", "</select>"],
    // XHTML parsers do not magically insert elements in the
    // same way that tag soup parsers do. So we cannot shorten
    // this by omitting <tbody> or other required elements.
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  }; // Support: IE <=9 only

  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;

  function getAll(context, tag) {
    // Support: IE <=9 - 11 only
    // Use typeof to avoid zero-argument method invocation on host objects (#15151)
    var ret;

    if (typeof context.getElementsByTagName !== "undefined") {
      ret = context.getElementsByTagName(tag || "*");
    } else if (typeof context.querySelectorAll !== "undefined") {
      ret = context.querySelectorAll(tag || "*");
    } else {
      ret = [];
    }

    if (tag === undefined || tag && nodeName(context, tag)) {
      return jQuery.merge([context], ret);
    }

    return ret;
  } // Mark scripts as having already been evaluated


  function setGlobalEval(elems, refElements) {
    var i = 0,
        l = elems.length;

    for (; i < l; i++) {
      dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
  }

  var rhtml = /<|&#?\w+;/;

  function buildFragment(elems, context, scripts, selection, ignored) {
    var elem,
        tmp,
        tag,
        wrap,
        contains,
        j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;

    for (; i < l; i++) {
      elem = elems[i];

      if (elem || elem === 0) {
        // Add nodes directly
        if (toType(elem) === "object") {
          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node
        } else if (!rhtml.test(elem)) {
          nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div")); // Deserialize a standard representation

          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content

          j = wrap[0];

          while (j--) {
            tmp = tmp.lastChild;
          } // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit


          jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container

          tmp = fragment.firstChild; // Ensure the created nodes are orphaned (#12392)

          tmp.textContent = "";
        }
      }
    } // Remove wrapper from fragment


    fragment.textContent = "";
    i = 0;

    while (elem = nodes[i++]) {
      // Skip elements already in the context collection (trac-4087)
      if (selection && jQuery.inArray(elem, selection) > -1) {
        if (ignored) {
          ignored.push(elem);
        }

        continue;
      }

      contains = jQuery.contains(elem.ownerDocument, elem); // Append to fragment

      tmp = getAll(fragment.appendChild(elem), "script"); // Preserve script evaluation history

      if (contains) {
        setGlobalEval(tmp);
      } // Capture executables


      if (scripts) {
        j = 0;

        while (elem = tmp[j++]) {
          if (rscriptType.test(elem.type || "")) {
            scripts.push(elem);
          }
        }
      }
    }

    return fragment;
  }

  (function () {
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input"); // Support: Android 4.0 - 4.3 only
    // Check state lost if the name is set (#11217)
    // Support: Windows Web Apps (WWA)
    // `name` and `type` must use .setAttribute for WWA (#14901)

    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input); // Support: Android <=4.1 only
    // Older WebKit doesn't clone checked state correctly in fragments

    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only
    // Make sure textarea (and checkbox) defaultValue is properly cloned

    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();

  var documentElement = document.documentElement;
  var rkeyEvent = /^key/,
      rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
      rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

  function returnTrue() {
    return true;
  }

  function returnFalse() {
    return false;
  } // Support: IE <=9 only
  // See #13393 for more info


  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }

  function _on(elem, types, selector, data, fn, one) {
    var origFn, type; // Types can be a map of types/handlers

    if (_typeof(types) === "object") {
      // ( types-Object, selector, data )
      if (typeof selector !== "string") {
        // ( types-Object, data )
        data = data || selector;
        selector = undefined;
      }

      for (type in types) {
        _on(elem, type, selector, data, types[type], one);
      }

      return elem;
    }

    if (data == null && fn == null) {
      // ( types, fn )
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        // ( types, selector, fn )
        fn = data;
        data = undefined;
      } else {
        // ( types, data, fn )
        fn = data;
        data = selector;
        selector = undefined;
      }
    }

    if (fn === false) {
      fn = returnFalse;
    } else if (!fn) {
      return elem;
    }

    if (one === 1) {
      origFn = fn;

      fn = function fn(event) {
        // Can use an empty set, since event contains the info
        jQuery().off(event);
        return origFn.apply(this, arguments);
      }; // Use same guid so caller can remove using origFn


      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    }

    return elem.each(function () {
      jQuery.event.add(this, types, fn, data, selector);
    });
  }
  /*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */


  jQuery.event = {
    global: {},
    add: function add(elem, types, handler, data, selector) {
      var handleObjIn,
          eventHandle,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.get(elem); // Don't attach events to noData or text/comment nodes (but allow plain objects)

      if (!elemData) {
        return;
      } // Caller can pass in an object of custom data in lieu of the handler


      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      } // Ensure that invalid selectors throw exceptions at attach time
      // Evaluate against documentElement in case elem is a non-element node (e.g., document)


      if (selector) {
        jQuery.find.matchesSelector(documentElement, selector);
      } // Make sure that the handler has a unique ID, used to find/remove it later


      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      } // Init the element's event structure and main handler, if this is the first


      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }

      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function (e) {
          // Discard the second event of a jQuery.event.trigger() and
          // when an event is called after a page has unloaded
          return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      } // Handle multiple events separated by a space


      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;

      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort(); // There *must* be a type, no attaching namespace-only handlers

        if (!type) {
          continue;
        } // If event changes its type, use the special event handlers for the changed type


        special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type

        type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type

        special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers

        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn); // Init the event handler queue if we're the first

        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false

          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle);
            }
          }
        }

        if (special.add) {
          special.add.call(elem, handleObj);

          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        } // Add to the element's handler list, delegates in front


        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        } // Keep track of which events have ever been used, for event optimization


        jQuery.event.global[type] = true;
      }
    },
    // Detach an event or set of events from an element
    remove: function remove(elem, types, handler, selector, mappedTypes) {
      var j,
          origCount,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

      if (!elemData || !(events = elemData.events)) {
        return;
      } // Once for each type.namespace in types; type may be omitted


      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;

      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort(); // Unbind all events (on this namespace, if provided) for the element

        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }

          continue;
        }

        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"); // Remove matching events

        origCount = j = handlers.length;

        while (j--) {
          handleObj = handlers[j];

          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);

            if (handleObj.selector) {
              handlers.delegateCount--;
            }

            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        } // Remove generic event handler if we removed something and no more handlers exist
        // (avoids potential for endless recursion during removal of special event handlers)


        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }

          delete events[type];
        }
      } // Remove data and the expando if it's no longer used


      if (jQuery.isEmptyObject(events)) {
        dataPriv.remove(elem, "handle events");
      }
    },
    dispatch: function dispatch(nativeEvent) {
      // Make a writable jQuery.Event from the native event object
      var event = jQuery.event.fix(nativeEvent);
      var i,
          j,
          ret,
          matched,
          handleObj,
          handlerQueue,
          args = new Array(arguments.length),
          handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
          special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event

      args[0] = event;

      for (i = 1; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired

      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      } // Determine handlers


      handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us

      i = 0;

      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;

        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          // Triggered event must either 1) have no namespace, or 2) have namespace(s)
          // a subset or equal to those in the bound event (both can have no namespace).
          if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      } // Call the postDispatch hook for the mapped type


      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }

      return event.result;
    },
    handlers: function handlers(event, _handlers) {
      var i,
          handleObj,
          sel,
          matchedHandlers,
          matchedSelectors,
          handlerQueue = [],
          delegateCount = _handlers.delegateCount,
          cur = event.target; // Find delegate handlers

      if (delegateCount && // Support: IE <=9
      // Black-hole SVG <use> instance trees (trac-13180)
      cur.nodeType && // Support: Firefox <=42
      // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
      // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
      // Support: IE 11 only
      // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
      !(event.type === "click" && event.button >= 1)) {
        for (; cur !== this; cur = cur.parentNode || this) {
          // Don't check non-elements (#13208)
          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
          if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
            matchedHandlers = [];
            matchedSelectors = {};

            for (i = 0; i < delegateCount; i++) {
              handleObj = _handlers[i]; // Don't conflict with Object.prototype properties (#13203)

              sel = handleObj.selector + " ";

              if (matchedSelectors[sel] === undefined) {
                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
              }

              if (matchedSelectors[sel]) {
                matchedHandlers.push(handleObj);
              }
            }

            if (matchedHandlers.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matchedHandlers
              });
            }
          }
        }
      } // Add the remaining (directly-bound) handlers


      cur = this;

      if (delegateCount < _handlers.length) {
        handlerQueue.push({
          elem: cur,
          handlers: _handlers.slice(delegateCount)
        });
      }

      return handlerQueue;
    },
    addProp: function addProp(name, hook) {
      Object.defineProperty(jQuery.Event.prototype, name, {
        enumerable: true,
        configurable: true,
        get: isFunction(hook) ? function () {
          if (this.originalEvent) {
            return hook(this.originalEvent);
          }
        } : function () {
          if (this.originalEvent) {
            return this.originalEvent[name];
          }
        },
        set: function set(value) {
          Object.defineProperty(this, name, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
          });
        }
      });
    },
    fix: function fix(originalEvent) {
      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
    },
    special: {
      load: {
        // Prevent triggered image.load events from bubbling to window.load
        noBubble: true
      },
      focus: {
        // Fire native event if possible so blur/focus sequence is correct
        trigger: function trigger() {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function trigger() {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        // For checkbox, fire native event so checked state will be right
        trigger: function trigger() {
          if (this.type === "checkbox" && this.click && nodeName(this, "input")) {
            this.click();
            return false;
          }
        },
        // For cross-browser consistency, don't fire native .click() on links
        _default: function _default(event) {
          return nodeName(event.target, "a");
        }
      },
      beforeunload: {
        postDispatch: function postDispatch(event) {
          // Support: Firefox 20+
          // Firefox doesn't alert if the returnValue field is not set.
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    }
  };

  jQuery.removeEvent = function (elem, type, handle) {
    // This "if" is needed for plain objects
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle);
    }
  };

  jQuery.Event = function (src, props) {
    // Allow instantiation without the 'new' keyword
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    } // Event object


    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type; // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.

      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
      src.returnValue === false ? returnTrue : returnFalse; // Create target properties
      // Support: Safari <=6 - 7 only
      // Target should not be a text node (#504, #13143)

      this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
      this.currentTarget = src.currentTarget;
      this.relatedTarget = src.relatedTarget; // Event type
    } else {
      this.type = src;
    } // Put explicitly provided properties onto the event object


    if (props) {
      jQuery.extend(this, props);
    } // Create a timestamp if incoming event doesn't have one


    this.timeStamp = src && src.timeStamp || Date.now(); // Mark it as fixed

    this[jQuery.expando] = true;
  }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


  jQuery.Event.prototype = {
    constructor: jQuery.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    isSimulated: false,
    preventDefault: function preventDefault() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;

      if (e && !this.isSimulated) {
        e.preventDefault();
      }
    },
    stopPropagation: function stopPropagation() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;

      if (e && !this.isSimulated) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function stopImmediatePropagation() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;

      if (e && !this.isSimulated) {
        e.stopImmediatePropagation();
      }

      this.stopPropagation();
    }
  }; // Includes all common event props including KeyEvent and MouseEvent specific props

  jQuery.each({
    altKey: true,
    bubbles: true,
    cancelable: true,
    changedTouches: true,
    ctrlKey: true,
    detail: true,
    eventPhase: true,
    metaKey: true,
    pageX: true,
    pageY: true,
    shiftKey: true,
    view: true,
    "char": true,
    charCode: true,
    key: true,
    keyCode: true,
    button: true,
    buttons: true,
    clientX: true,
    clientY: true,
    offsetX: true,
    offsetY: true,
    pointerId: true,
    pointerType: true,
    screenX: true,
    screenY: true,
    targetTouches: true,
    toElement: true,
    touches: true,
    which: function which(event) {
      var button = event.button; // Add which for key events

      if (event.which == null && rkeyEvent.test(event.type)) {
        return event.charCode != null ? event.charCode : event.keyCode;
      } // Add which for click: 1 === left; 2 === middle; 3 === right


      if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
        if (button & 1) {
          return 1;
        }

        if (button & 2) {
          return 3;
        }

        if (button & 4) {
          return 2;
        }

        return 0;
      }

      return event.which;
    }
  }, jQuery.event.addProp); // Create mouseenter/leave events using mouseover/out and event-time checks
  // so that event delegation works in jQuery.
  // Do the same for pointerenter/pointerleave and pointerover/pointerout
  //
  // Support: Safari 7 only
  // Safari sends mouseenter too often; see:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
  // for the description of the bug (it existed in older Chrome versions as well).

  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function (orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function handle(event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.
        // NB: No relatedTarget if the mouse left/entered the browser window

        if (!related || related !== target && !jQuery.contains(target, related)) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }

        return ret;
      }
    };
  });
  jQuery.fn.extend({
    on: function on(types, selector, data, fn) {
      return _on(this, types, selector, data, fn);
    },
    one: function one(types, selector, data, fn) {
      return _on(this, types, selector, data, fn, 1);
    },
    off: function off(types, selector, fn) {
      var handleObj, type;

      if (types && types.preventDefault && types.handleObj) {
        // ( event )  dispatched jQuery.Event
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }

      if (_typeof(types) === "object") {
        // ( types-object [, selector] )
        for (type in types) {
          this.off(type, selector, types[type]);
        }

        return this;
      }

      if (selector === false || typeof selector === "function") {
        // ( types [, fn] )
        fn = selector;
        selector = undefined;
      }

      if (fn === false) {
        fn = returnFalse;
      }

      return this.each(function () {
        jQuery.event.remove(this, types, fn, selector);
      });
    }
  });
  var
  /* eslint-disable max-len */
  // See https://github.com/eslint/eslint/issues/3229
  rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

  /* eslint-enable */
  // Support: IE <=10 - 11, Edge 12 - 13 only
  // In IE/Edge using regex groups here causes severe slowdowns.
  // See https://connect.microsoft.com/IE/feedback/details/1736512/
  rnoInnerhtml = /<script|<style|<link/i,
      // checked="checked" or checked
  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; // Prefer a tbody over its parent table for containing new rows

  function manipulationTarget(elem, content) {
    if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
      return jQuery(elem).children("tbody")[0] || elem;
    }

    return elem;
  } // Replace/restore the type attribute of script elements for safe DOM manipulation


  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }

  function restoreScript(elem) {
    if ((elem.type || "").slice(0, 5) === "true/") {
      elem.type = elem.type.slice(5);
    } else {
      elem.removeAttribute("type");
    }

    return elem;
  }

  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

    if (dest.nodeType !== 1) {
      return;
    } // 1. Copy private data: events, handlers, etc.


    if (dataPriv.hasData(src)) {
      pdataOld = dataPriv.access(src);
      pdataCur = dataPriv.set(dest, pdataOld);
      events = pdataOld.events;

      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};

        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    } // 2. Copy user data


    if (dataUser.hasData(src)) {
      udataOld = dataUser.access(src);
      udataCur = jQuery.extend({}, udataOld);
      dataUser.set(dest, udataCur);
    }
  } // Fix IE bugs, see support tests


  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.

    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }

  function domManip(collection, args, callback, ignored) {
    // Flatten any nested arrays
    args = concat.apply([], args);
    var fragment,
        first,
        scripts,
        hasScripts,
        node,
        doc,
        i = 0,
        l = collection.length,
        iNoClone = l - 1,
        value = args[0],
        valueIsFunction = isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit

    if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
      return collection.each(function (index) {
        var self = collection.eq(index);

        if (valueIsFunction) {
          args[0] = value.call(this, index, self.html());
        }

        domManip(self, args, callback, ignored);
      });
    }

    if (l) {
      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
      first = fragment.firstChild;

      if (fragment.childNodes.length === 1) {
        fragment = first;
      } // Require either new content or an interest in ignored elements to invoke the callback


      if (first || ignored) {
        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
        hasScripts = scripts.length; // Use the original fragment for the last item
        // instead of the first because it can end up
        // being emptied incorrectly in certain situations (#8070).

        for (; i < l; i++) {
          node = fragment;

          if (i !== iNoClone) {
            node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration

            if (hasScripts) {
              // Support: Android <=4.0 only, PhantomJS 1 only
              // push.apply(_, arraylike) throws on ancient WebKit
              jQuery.merge(scripts, getAll(node, "script"));
            }
          }

          callback.call(collection[i], node, i);
        }

        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts

          jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion

          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];

            if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
              if (node.src && (node.type || "").toLowerCase() !== "module") {
                // Optional AJAX dependency, but won't run scripts if not present
                if (jQuery._evalUrl) {
                  jQuery._evalUrl(node.src);
                }
              } else {
                DOMEval(node.textContent.replace(rcleanScript, ""), doc, node);
              }
            }
          }
        }
      }
    }

    return collection;
  }

  function _remove(elem, selector, keepData) {
    var node,
        nodes = selector ? jQuery.filter(selector, elem) : elem,
        i = 0;

    for (; (node = nodes[i]) != null; i++) {
      if (!keepData && node.nodeType === 1) {
        jQuery.cleanData(getAll(node));
      }

      if (node.parentNode) {
        if (keepData && jQuery.contains(node.ownerDocument, node)) {
          setGlobalEval(getAll(node, "script"));
        }

        node.parentNode.removeChild(node);
      }
    }

    return elem;
  }

  jQuery.extend({
    htmlPrefilter: function htmlPrefilter(html) {
      return html.replace(rxhtmlTag, "<$1></$2>");
    },
    clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
      var i,
          l,
          srcElements,
          destElements,
          clone = elem.cloneNode(true),
          inPage = jQuery.contains(elem.ownerDocument, elem); // Fix IE cloning issues

      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
        destElements = getAll(clone);
        srcElements = getAll(elem);

        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      } // Copy the events from the original to the clone


      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);

          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      } // Preserve script evaluation history


      destElements = getAll(clone, "script");

      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      } // Return the cloned set


      return clone;
    },
    cleanData: function cleanData(elems) {
      var data,
          elem,
          type,
          special = jQuery.event.special,
          i = 0;

      for (; (elem = elems[i]) !== undefined; i++) {
        if (acceptData(elem)) {
          if (data = elem[dataPriv.expando]) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            } // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove


            elem[dataPriv.expando] = undefined;
          }

          if (elem[dataUser.expando]) {
            // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove
            elem[dataUser.expando] = undefined;
          }
        }
      }
    }
  });
  jQuery.fn.extend({
    detach: function detach(selector) {
      return _remove(this, selector, true);
    },
    remove: function remove(selector) {
      return _remove(this, selector);
    },
    text: function text(value) {
      return access(this, function (value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function () {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function append() {
      return domManip(this, arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function prepend() {
      return domManip(this, arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function before() {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function after() {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    empty: function empty() {
      var elem,
          i = 0;

      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          // Prevent memory leaks
          jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes

          elem.textContent = "";
        }
      }

      return this;
    },
    clone: function clone(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function () {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function html(value) {
      return access(this, function (value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;

        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        } // See if we can take a shortcut and just use innerHTML


        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = jQuery.htmlPrefilter(value);

          try {
            for (; i < l; i++) {
              elem = this[i] || {}; // Remove element nodes and prevent memory leaks

              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }

            elem = 0; // If using innerHTML throws an exception, use the fallback method
          } catch (e) {}
        }

        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function replaceWith() {
      var ignored = []; // Make the changes, replacing each non-ignored context element with the new content

      return domManip(this, arguments, function (elem) {
        var parent = this.parentNode;

        if (jQuery.inArray(this, ignored) < 0) {
          jQuery.cleanData(getAll(this));

          if (parent) {
            parent.replaceChild(elem, this);
          }
        } // Force callback invocation

      }, ignored);
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function (name, original) {
    jQuery.fn[name] = function (selector) {
      var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;

      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only
        // .get() because push.apply(_, arraylike) throws on ancient WebKit

        push.apply(ret, elems.get());
      }

      return this.pushStack(ret);
    };
  });
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

  var getStyles = function getStyles(elem) {
    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
    // IE throws on elements created in popups
    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
    var view = elem.ownerDocument.defaultView;

    if (!view || !view.opener) {
      view = window;
    }

    return view.getComputedStyle(elem);
  };

  var rboxStyle = new RegExp(cssExpand.join("|"), "i");

  (function () {
    // Executing both pixelPosition & boxSizingReliable tests require only one layout
    // so they're executed at the same time to save the second computation.
    function computeStyleTests() {
      // This is a singleton, we need to execute it only once
      if (!div) {
        return;
      }

      container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
      div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
      documentElement.appendChild(container).appendChild(div);
      var divStyle = window.getComputedStyle(div);
      pixelPositionVal = divStyle.top !== "1%"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44

      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12; // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
      // Some styles come back with percentage values, even though they shouldn't

      div.style.right = "60%";
      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36; // Support: IE 9 - 11 only
      // Detect misreporting of content dimensions for box-sizing:border-box elements

      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36; // Support: IE 9 only
      // Detect overflow:scroll screwiness (gh-3699)

      div.style.position = "absolute";
      scrollboxSizeVal = div.offsetWidth === 36 || "absolute";
      documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and
      // it will also be a sign that checks already performed

      div = null;
    }

    function roundPixelMeasures(measure) {
      return Math.round(parseFloat(measure));
    }

    var pixelPositionVal,
        boxSizingReliableVal,
        scrollboxSizeVal,
        pixelBoxStylesVal,
        reliableMarginLeftVal,
        container = document.createElement("div"),
        div = document.createElement("div"); // Finish early in limited (non-browser) environments

    if (!div.style) {
      return;
    } // Support: IE <=9 - 11 only
    // Style of cloned element affects source element cloned (#8908)


    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    jQuery.extend(support, {
      boxSizingReliable: function boxSizingReliable() {
        computeStyleTests();
        return boxSizingReliableVal;
      },
      pixelBoxStyles: function pixelBoxStyles() {
        computeStyleTests();
        return pixelBoxStylesVal;
      },
      pixelPosition: function pixelPosition() {
        computeStyleTests();
        return pixelPositionVal;
      },
      reliableMarginLeft: function reliableMarginLeft() {
        computeStyleTests();
        return reliableMarginLeftVal;
      },
      scrollboxSize: function scrollboxSize() {
        computeStyleTests();
        return scrollboxSizeVal;
      }
    });
  })();

  function curCSS(elem, name, computed) {
    var width,
        minWidth,
        maxWidth,
        ret,
        // Support: Firefox 51+
    // Retrieving style before computed somehow
    // fixes an issue with getting wrong values
    // on detached elements
    style = elem.style;
    computed = computed || getStyles(elem); // getPropertyValue is needed for:
    //   .css('filter') (IE 9 only, #12537)
    //   .css('--customProperty) (#3144)

    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];

      if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      } // A tribute to the "awesome hack by Dean Edwards"
      // Android Browser returns percentage for some values,
      // but width seems to be reliably pixels.
      // This is against the CSSOM draft spec:
      // https://drafts.csswg.org/cssom/#resolved-values


      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
        // Remember the original values
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth; // Put in the new values to get a computed value out

        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width; // Revert the changed values

        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }

    return ret !== undefined ? // Support: IE <=9 - 11 only
    // IE returns zIndex value as an integer.
    ret + "" : ret;
  }

  function addGetHookIf(conditionFn, hookFn) {
    // Define the hook, we'll check on the first run if it's really needed.
    return {
      get: function get() {
        if (conditionFn()) {
          // Hook not needed (or it's not possible to use it due
          // to missing dependency), remove it.
          delete this.get;
          return;
        } // Hook needed; redefine it so that the support test is not executed again.


        return (this.get = hookFn).apply(this, arguments);
      }
    };
  }

  var // Swappable if display is none or starts with table
  // except "table", "table-cell", or "table-caption"
  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      rcustomProp = /^--/,
      cssShow = {
    position: "absolute",
    visibility: "hidden",
    display: "block"
  },
      cssNormalTransform = {
    letterSpacing: "0",
    fontWeight: "400"
  },
      cssPrefixes = ["Webkit", "Moz", "ms"],
      emptyStyle = document.createElement("div").style; // Return a css property mapped to a potentially vendor prefixed property

  function vendorPropName(name) {
    // Shortcut for names that are not vendor prefixed
    if (name in emptyStyle) {
      return name;
    } // Check for vendor prefixed names


    var capName = name[0].toUpperCase() + name.slice(1),
        i = cssPrefixes.length;

    while (i--) {
      name = cssPrefixes[i] + capName;

      if (name in emptyStyle) {
        return name;
      }
    }
  } // Return a property mapped along what jQuery.cssProps suggests or to
  // a vendor prefixed property.


  function finalPropName(name) {
    var ret = jQuery.cssProps[name];

    if (!ret) {
      ret = jQuery.cssProps[name] = vendorPropName(name) || name;
    }

    return ret;
  }

  function setPositiveNumber(elem, value, subtract) {
    // Any relative (+/-) values have already been
    // normalized at this point
    var matches = rcssNum.exec(value);
    return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
  }

  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
    var i = dimension === "width" ? 1 : 0,
        extra = 0,
        delta = 0; // Adjustment may not be necessary

    if (box === (isBorderBox ? "border" : "content")) {
      return 0;
    }

    for (; i < 4; i += 2) {
      // Both box models exclude margin
      if (box === "margin") {
        delta += jQuery.css(elem, box + cssExpand[i], true, styles);
      } // If we get here with a content-box, we're seeking "padding" or "border" or "margin"


      if (!isBorderBox) {
        // Add padding
        delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles); // For "border" or "margin", add border

        if (box !== "padding") {
          delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles); // But still keep track of it otherwise
        } else {
          extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        } // If we get here with a border-box (content + padding + border), we're seeking "content" or
        // "padding" or "margin"

      } else {
        // For "content", subtract padding
        if (box === "content") {
          delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        } // For "content" or "padding", subtract border


        if (box !== "margin") {
          delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    } // Account for positive content-box scroll gutter when requested by providing computedVal


    if (!isBorderBox && computedVal >= 0) {
      // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
      // Assuming integer scroll gutter, subtract the rest and round down
      delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5));
    }

    return delta;
  }

  function getWidthOrHeight(elem, dimension, extra) {
    // Start with computed style
    var styles = getStyles(elem),
        val = curCSS(elem, dimension, styles),
        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
        valueIsBorderBox = isBorderBox; // Support: Firefox <=54
    // Return a confounding non-pixel value or feign ignorance, as appropriate.

    if (rnumnonpx.test(val)) {
      if (!extra) {
        return val;
      }

      val = "auto";
    } // Check for style in case a browser which returns unreliable values
    // for getComputedStyle silently falls back to the reliable elem.style


    valueIsBorderBox = valueIsBorderBox && (support.boxSizingReliable() || val === elem.style[dimension]); // Fall back to offsetWidth/offsetHeight when value is "auto"
    // This happens for inline elements with no explicit setting (gh-3571)
    // Support: Android <=4.1 - 4.3 only
    // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)

    if (val === "auto" || !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") {
      val = elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)]; // offsetWidth/offsetHeight provide border-box values

      valueIsBorderBox = true;
    } // Normalize "" and auto


    val = parseFloat(val) || 0; // Adjust for the element's box model

    return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)
    val) + "px";
  }

  jQuery.extend({
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
      opacity: {
        get: function get(elem, computed) {
          if (computed) {
            // We should always get a number back from opacity
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }
      }
    },
    // Don't automatically add "px" to these possibly-unitless properties
    cssNumber: {
      "animationIterationCount": true,
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {},
    // Get and set the style property on a DOM Node
    style: function style(elem, name, value, extra) {
      // Don't set styles on text and comment nodes
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      } // Make sure that we're working with the right name


      var ret,
          type,
          hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name),
          style = elem.style; // Make sure that we're working with the right name. We don't
      // want to query the value if it is a CSS custom property
      // since they are user-defined.

      if (!isCustomProp) {
        name = finalPropName(origName);
      } // Gets hook for the prefixed version, then unprefixed version


      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value

      if (value !== undefined) {
        type = _typeof(value); // Convert "+=" or "-=" to relative numbers (#7345)

        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
          value = adjustCSS(elem, name, ret); // Fixes bug #9237

          type = "number";
        } // Make sure that null and NaN values aren't set (#7116)


        if (value == null || value !== value) {
          return;
        } // If a number was passed in, add the unit (except for certain CSS properties)


        if (type === "number") {
          value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
        } // background-* props affect original clone's values


        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        } // If a hook was provided, use that value, otherwise just set the specified value


        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          if (isCustomProp) {
            style.setProperty(name, value);
          } else {
            style[name] = value;
          }
        }
      } else {
        // If a hook was provided get the non-computed value from there
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        } // Otherwise just get the value from the style object


        return style[name];
      }
    },
    css: function css(elem, name, extra, styles) {
      var val,
          num,
          hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name); // Make sure that we're working with the right name. We don't
      // want to modify the value if it is a CSS custom property
      // since they are user-defined.

      if (!isCustomProp) {
        name = finalPropName(origName);
      } // Try prefixed name followed by the unprefixed name


      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there

      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      } // Otherwise, if a way to get the computed value exists, use that


      if (val === undefined) {
        val = curCSS(elem, name, styles);
      } // Convert "normal" to computed value


      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      } // Make numeric if forced or a qualifier was provided and val looks numeric


      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || isFinite(num) ? num || 0 : val;
      }

      return val;
    }
  });
  jQuery.each(["height", "width"], function (i, dimension) {
    jQuery.cssHooks[dimension] = {
      get: function get(elem, computed, extra) {
        if (computed) {
          // Certain elements can have dimension info if we invisibly show them
          // but it must have a current display style that would benefit
          return rdisplayswap.test(jQuery.css(elem, "display")) && ( // Support: Safari 8+
          // Table columns in Safari have non-zero offsetWidth & zero
          // getBoundingClientRect().width unless display is changed.
          // Support: IE <=11 only
          // Running getBoundingClientRect on a disconnected node
          // in IE throws an error.
          !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
            return getWidthOrHeight(elem, dimension, extra);
          }) : getWidthOrHeight(elem, dimension, extra);
        }
      },
      set: function set(elem, value, extra) {
        var matches,
            styles = getStyles(elem),
            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
            subtract = extra && boxModelAdjustment(elem, dimension, extra, isBorderBox, styles); // Account for unreliable border-box dimensions by comparing offset* to computed and
        // faking a content-box to get border and padding (gh-3699)

        if (isBorderBox && support.scrollboxSize() === styles.position) {
          subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
        } // Convert to pixels if value adjustment is needed


        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
          elem.style[dimension] = value;
          value = jQuery.css(elem, dimension);
        }

        return setPositiveNumber(elem, value, subtract);
      }
    };
  });
  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
    if (computed) {
      return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
        marginLeft: 0
      }, function () {
        return elem.getBoundingClientRect().left;
      })) + "px";
    }
  }); // These hooks are used by animate to expand properties

  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function (prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function expand(value) {
        var i = 0,
            expanded = {},
            // Assumes a single number if not a string
        parts = typeof value === "string" ? value.split(" ") : [value];

        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }

        return expanded;
      }
    };

    if (prefix !== "margin") {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function css(name, value) {
      return access(this, function (elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;

        if (Array.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;

          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }

          return map;
        }

        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    }
  });

  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }

  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function init(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || jQuery.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function cur() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function run(percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];

      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }

      this.now = (this.end - this.start) * eased + this.start;

      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }

      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }

      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function get(tween) {
        var result; // Use a property on the element directly when it is not a DOM element,
        // or when there is no matching style property that exists.

        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
          return tween.elem[tween.prop];
        } // Passing an empty string as a 3rd parameter to .css will automatically
        // attempt a parseFloat and fallback to a string if the parse fails.
        // Simple values such as "10px" are parsed to Float;
        // complex values such as "rotate(1rad)" are returned as-is.


        result = jQuery.css(tween.elem, tween.prop, ""); // Empty strings, null, undefined and "auto" are converted to 0.

        return !result || result === "auto" ? 0 : result;
      },
      set: function set(tween) {
        // Use step hook for back compat.
        // Use cssHook if its there.
        // Use .style if available and use plain properties where available.
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  }; // Support: IE <=9 only
  // Panic based approach to setting things on disconnected nodes

  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function set(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  jQuery.easing = {
    linear: function linear(p) {
      return p;
    },
    swing: function swing(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
    _default: "swing"
  };
  jQuery.fx = Tween.prototype.init; // Back compat <1.8 extension point

  jQuery.fx.step = {};
  var fxNow,
      inProgress,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rrun = /queueHooks$/;

  function schedule() {
    if (inProgress) {
      if (document.hidden === false && window.requestAnimationFrame) {
        window.requestAnimationFrame(schedule);
      } else {
        window.setTimeout(schedule, jQuery.fx.interval);
      }

      jQuery.fx.tick();
    }
  } // Animations created synchronously will run synchronously


  function createFxNow() {
    window.setTimeout(function () {
      fxNow = undefined;
    });
    return fxNow = Date.now();
  } // Generate parameters to create a standard animation


  function genFx(type, includeWidth) {
    var which,
        i = 0,
        attrs = {
      height: type
    }; // If we include width, step value is 1 to do all cssExpand values,
    // otherwise step value is 2 to skip over Left and Right

    includeWidth = includeWidth ? 1 : 0;

    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }

    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }

    return attrs;
  }

  function createTween(value, prop, animation) {
    var tween,
        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
        index = 0,
        length = collection.length;

    for (; index < length; index++) {
      if (tween = collection[index].call(animation, prop, value)) {
        // We're done with this property
        return tween;
      }
    }
  }

  function defaultPrefilter(elem, props, opts) {
    var prop,
        value,
        toggle,
        hooks,
        oldfire,
        propTween,
        restoreDisplay,
        display,
        isBox = "width" in props || "height" in props,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHiddenWithinTree(elem),
        dataShow = dataPriv.get(elem, "fxshow"); // Queue-skipping animations hijack the fx hooks

    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");

      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;

        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }

      hooks.unqueued++;
      anim.always(function () {
        // Ensure the complete handler is called before this completes
        anim.always(function () {
          hooks.unqueued--;

          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    } // Detect show/hide animations


    for (prop in props) {
      value = props[prop];

      if (rfxtypes.test(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";

        if (value === (hidden ? "hide" : "show")) {
          // Pretend to be hidden if this is a "show" and
          // there is still data from a stopped show/hide
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true; // Ignore all other no-op show/hide data
          } else {
            continue;
          }
        }

        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      }
    } // Bail out if this is a no-op like .hide().hide()


    propTween = !jQuery.isEmptyObject(props);

    if (!propTween && jQuery.isEmptyObject(orig)) {
      return;
    } // Restrict "overflow" and "display" styles during box animations


    if (isBox && elem.nodeType === 1) {
      // Support: IE <=9 - 11, Edge 12 - 15
      // Record all 3 overflow attributes because IE does not infer the shorthand
      // from identically-valued overflowX and overflowY and Edge just mirrors
      // the overflowX value there.
      opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Identify a display type, preferring old show/hide data over the CSS cascade

      restoreDisplay = dataShow && dataShow.display;

      if (restoreDisplay == null) {
        restoreDisplay = dataPriv.get(elem, "display");
      }

      display = jQuery.css(elem, "display");

      if (display === "none") {
        if (restoreDisplay) {
          display = restoreDisplay;
        } else {
          // Get nonempty value(s) by temporarily forcing visibility
          showHide([elem], true);
          restoreDisplay = elem.style.display || restoreDisplay;
          display = jQuery.css(elem, "display");
          showHide([elem]);
        }
      } // Animate inline elements as inline-block


      if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
        if (jQuery.css(elem, "float") === "none") {
          // Restore the original display value at the end of pure show/hide animations
          if (!propTween) {
            anim.done(function () {
              style.display = restoreDisplay;
            });

            if (restoreDisplay == null) {
              display = style.display;
              restoreDisplay = display === "none" ? "" : display;
            }
          }

          style.display = "inline-block";
        }
      }
    }

    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function () {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    } // Implement show/hide animations


    propTween = false;

    for (prop in orig) {
      // General show/hide setup for this element animation
      if (!propTween) {
        if (dataShow) {
          if ("hidden" in dataShow) {
            hidden = dataShow.hidden;
          }
        } else {
          dataShow = dataPriv.access(elem, "fxshow", {
            display: restoreDisplay
          });
        } // Store hidden/visible for toggle so `.stop().toggle()` "reverses"


        if (toggle) {
          dataShow.hidden = !hidden;
        } // Show elements before animating them


        if (hidden) {
          showHide([elem], true);
        }
        /* eslint-disable no-loop-func */


        anim.done(function () {
          /* eslint-enable no-loop-func */
          // The final step of a "hide" animation is actually hiding the element
          if (!hidden) {
            showHide([elem]);
          }

          dataPriv.remove(elem, "fxshow");

          for (prop in orig) {
            jQuery.style(elem, prop, orig[prop]);
          }
        });
      } // Per-property setup


      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

      if (!(prop in dataShow)) {
        dataShow[prop] = propTween.start;

        if (hidden) {
          propTween.end = propTween.start;
          propTween.start = 0;
        }
      }
    }
  }

  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass

    for (index in props) {
      name = camelCase(index);
      easing = specialEasing[name];
      value = props[index];

      if (Array.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }

      if (index !== name) {
        props[name] = value;
        delete props[index];
      }

      hooks = jQuery.cssHooks[name];

      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name]; // Not quite $.extend, this won't overwrite existing keys.
        // Reusing 'index' because we have the correct "name"

        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }

  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = Animation.prefilters.length,
        deferred = jQuery.Deferred().always(function () {
      // Don't match elem in the :animated selector
      delete tick.elem;
    }),
        tick = function tick() {
      if (stopped) {
        return false;
      }

      var currentTime = fxNow || createFxNow(),
          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
          // Support: Android 2.3 only
      // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
      temp = remaining / animation.duration || 0,
          percent = 1 - temp,
          index = 0,
          length = animation.tweens.length;

      for (; index < length; index++) {
        animation.tweens[index].run(percent);
      }

      deferred.notifyWith(elem, [animation, percent, remaining]); // If there's more to do, yield

      if (percent < 1 && length) {
        return remaining;
      } // If this was an empty animation, synthesize a final progress notification


      if (!length) {
        deferred.notifyWith(elem, [animation, 1, 0]);
      } // Resolve the animation and report its conclusion


      deferred.resolveWith(elem, [animation]);
      return false;
    },
        animation = deferred.promise({
      elem: elem,
      props: jQuery.extend({}, properties),
      opts: jQuery.extend(true, {
        specialEasing: {},
        easing: jQuery.easing._default
      }, options),
      originalProperties: properties,
      originalOptions: options,
      startTime: fxNow || createFxNow(),
      duration: options.duration,
      tweens: [],
      createTween: function createTween(prop, end) {
        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
        animation.tweens.push(tween);
        return tween;
      },
      stop: function stop(gotoEnd) {
        var index = 0,
            // If we are going to the end, we want to run all the tweens
        // otherwise we skip this part
        length = gotoEnd ? animation.tweens.length : 0;

        if (stopped) {
          return this;
        }

        stopped = true;

        for (; index < length; index++) {
          animation.tweens[index].run(1);
        } // Resolve when we played the last frame; otherwise, reject


        if (gotoEnd) {
          deferred.notifyWith(elem, [animation, 1, 0]);
          deferred.resolveWith(elem, [animation, gotoEnd]);
        } else {
          deferred.rejectWith(elem, [animation, gotoEnd]);
        }

        return this;
      }
    }),
        props = animation.props;

    propFilter(props, animation.opts.specialEasing);

    for (; index < length; index++) {
      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);

      if (result) {
        if (isFunction(result.stop)) {
          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
        }

        return result;
      }
    }

    jQuery.map(props, createTween, animation);

    if (isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    } // Attach callbacks from options


    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation;
  }

  jQuery.Animation = jQuery.extend(Animation, {
    tweeners: {
      "*": [function (prop, value) {
        var tween = this.createTween(prop, value);
        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
        return tween;
      }]
    },
    tweener: function tweener(props, callback) {
      if (isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.match(rnothtmlwhite);
      }

      var prop,
          index = 0,
          length = props.length;

      for (; index < length; index++) {
        prop = props[index];
        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
        Animation.tweeners[prop].unshift(callback);
      }
    },
    prefilters: [defaultPrefilter],
    prefilter: function prefilter(callback, prepend) {
      if (prepend) {
        Animation.prefilters.unshift(callback);
      } else {
        Animation.prefilters.push(callback);
      }
    }
  });

  jQuery.speed = function (speed, easing, fn) {
    var opt = speed && _typeof(speed) === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !isFunction(easing) && easing
    }; // Go to the end state if fx are off

    if (jQuery.fx.off) {
      opt.duration = 0;
    } else {
      if (typeof opt.duration !== "number") {
        if (opt.duration in jQuery.fx.speeds) {
          opt.duration = jQuery.fx.speeds[opt.duration];
        } else {
          opt.duration = jQuery.fx.speeds._default;
        }
      }
    } // Normalize opt.queue - true/undefined/null -> "fx"


    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    } // Queueing


    opt.old = opt.complete;

    opt.complete = function () {
      if (isFunction(opt.old)) {
        opt.old.call(this);
      }

      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };

    return opt;
  };

  jQuery.fn.extend({
    fadeTo: function fadeTo(speed, to, easing, callback) {
      // Show any hidden elements after setting opacity to 0
      return this.filter(isHiddenWithinTree).css("opacity", 0).show() // Animate to the value specified
      .end().animate({
        opacity: to
      }, speed, easing, callback);
    },
    animate: function animate(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function doAnimation() {
        // Operate on a copy of prop so per-property easing won't be lost
        var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately

        if (empty || dataPriv.get(this, "finish")) {
          anim.stop(true);
        }
      };

      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function stop(type, clearQueue, gotoEnd) {
      var stopQueue = function stopQueue(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };

      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }

      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }

      return this.each(function () {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = dataPriv.get(this);

        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }

        for (index = timers.length; index--;) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        } // Start the next in the queue if the last step wasn't forced.
        // Timers currently will call their complete callbacks, which
        // will dequeue but only if they were gotoEnd.


        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function finish(type) {
      if (type !== false) {
        type = type || "fx";
      }

      return this.each(function () {
        var index,
            data = dataPriv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0; // Enable finishing flag on private data

        data.finish = true; // Empty the queue first

        jQuery.queue(this, type, []);

        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        } // Look for any active animations, and finish them


        for (index = timers.length; index--;) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        } // Look for any animations in the old queue and finish them


        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        } // Turn off finishing flag


        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function (i, name) {
    var cssFn = jQuery.fn[name];

    jQuery.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  }); // Generate shortcuts for custom animations

  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {
      opacity: "show"
    },
    fadeOut: {
      opacity: "hide"
    },
    fadeToggle: {
      opacity: "toggle"
    }
  }, function (name, props) {
    jQuery.fn[name] = function (speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];

  jQuery.fx.tick = function () {
    var timer,
        i = 0,
        timers = jQuery.timers;
    fxNow = Date.now();

    for (; i < timers.length; i++) {
      timer = timers[i]; // Run the timer and safely remove it when done (allowing for external removal)

      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }

    if (!timers.length) {
      jQuery.fx.stop();
    }

    fxNow = undefined;
  };

  jQuery.fx.timer = function (timer) {
    jQuery.timers.push(timer);
    jQuery.fx.start();
  };

  jQuery.fx.interval = 13;

  jQuery.fx.start = function () {
    if (inProgress) {
      return;
    }

    inProgress = true;
    schedule();
  };

  jQuery.fx.stop = function () {
    inProgress = null;
  };

  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    // Default speed
    _default: 400
  }; // Based off of the plugin by Clint Helfers, with permission.
  // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/

  jQuery.fn.delay = function (time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function (next, hooks) {
      var timeout = window.setTimeout(next, time);

      hooks.stop = function () {
        window.clearTimeout(timeout);
      };
    });
  };

  (function () {
    var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox"; // Support: Android <=4.3 only
    // Default value for a checkbox should be "on"

    support.checkOn = input.value !== ""; // Support: IE <=11 only
    // Must access selectedIndex to make default options select

    support.optSelected = opt.selected; // Support: IE <=11 only
    // An input loses its value after becoming a radio

    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();

  var boolHook,
      attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function attr(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function removeAttr(name) {
      return this.each(function () {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function attr(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes

      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      } // Fallback to prop when attributes are not supported


      if (typeof elem.getAttribute === "undefined") {
        return jQuery.prop(elem, name, value);
      } // Attribute hooks are determined by the lowercase version
      // Grab necessary hook if one is defined


      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
      }

      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
          return;
        }

        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }

        elem.setAttribute(name, value + "");
        return value;
      }

      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }

      ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined

      return ret == null ? undefined : ret;
    },
    attrHooks: {
      type: {
        set: function set(elem, value) {
          if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);

            if (val) {
              elem.value = val;
            }

            return value;
          }
        }
      }
    },
    removeAttr: function removeAttr(elem, value) {
      var name,
          i = 0,
          // Attribute names can contain non-HTML whitespace characters
      // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
      attrNames = value && value.match(rnothtmlwhite);

      if (attrNames && elem.nodeType === 1) {
        while (name = attrNames[i++]) {
          elem.removeAttribute(name);
        }
      }
    }
  }); // Hooks for boolean attributes

  boolHook = {
    set: function set(elem, value, name) {
      if (value === false) {
        // Remove boolean attributes when set to false
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }

      return name;
    }
  };
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;

    attrHandle[name] = function (elem, name, isXML) {
      var ret,
          handle,
          lowercaseName = name.toLowerCase();

      if (!isXML) {
        // Avoid an infinite loop by temporarily removing this function from the getter
        handle = attrHandle[lowercaseName];
        attrHandle[lowercaseName] = ret;
        ret = getter(elem, name, isXML) != null ? lowercaseName : null;
        attrHandle[lowercaseName] = handle;
      }

      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i,
      rclickable = /^(?:a|area)$/i;
  jQuery.fn.extend({
    prop: function prop(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function removeProp(name) {
      return this.each(function () {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    prop: function prop(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes

      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }

      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        // Fix name and attach hooks
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }

      if (value !== undefined) {
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }

        return elem[name] = value;
      }

      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }

      return elem[name];
    },
    propHooks: {
      tabIndex: {
        get: function get(elem) {
          // Support: IE <=9 - 11 only
          // elem.tabIndex doesn't always return the
          // correct value when it hasn't been explicitly set
          // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
          // Use proper attribute retrieval(#12072)
          var tabindex = jQuery.find.attr(elem, "tabindex");

          if (tabindex) {
            return parseInt(tabindex, 10);
          }

          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
            return 0;
          }

          return -1;
        }
      }
    },
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  }); // Support: IE <=11 only
  // Accessing the selectedIndex property
  // forces the browser to respect setting selected
  // on the option
  // The getter ensures a default option is selected
  // when in an optgroup
  // eslint rule "no-unused-expressions" is disabled for this code
  // since it considers such accessions noop

  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function get(elem) {
        /* eslint no-unused-expressions: "off" */
        var parent = elem.parentNode;

        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }

        return null;
      },
      set: function set(elem) {
        /* eslint no-unused-expressions: "off" */
        var parent = elem.parentNode;

        if (parent) {
          parent.selectedIndex;

          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
      }
    };
  }

  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
    jQuery.propFix[this.toLowerCase()] = this;
  }); // Strip and collapse whitespace according to HTML spec
  // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace

  function stripAndCollapse(value) {
    var tokens = value.match(rnothtmlwhite) || [];
    return tokens.join(" ");
  }

  function getClass(elem) {
    return elem.getAttribute && elem.getAttribute("class") || "";
  }

  function classesToArray(value) {
    if (Array.isArray(value)) {
      return value;
    }

    if (typeof value === "string") {
      return value.match(rnothtmlwhite) || [];
    }

    return [];
  }

  jQuery.fn.extend({
    addClass: function addClass(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;

      if (isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).addClass(value.call(this, j, getClass(this)));
        });
      }

      classes = classesToArray(value);

      if (classes.length) {
        while (elem = this[i++]) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

          if (cur) {
            j = 0;

            while (clazz = classes[j++]) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            } // Only assign if different to avoid unneeded rendering.


            finalValue = stripAndCollapse(cur);

            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }

      return this;
    },
    removeClass: function removeClass(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;

      if (isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).removeClass(value.call(this, j, getClass(this)));
        });
      }

      if (!arguments.length) {
        return this.attr("class", "");
      }

      classes = classesToArray(value);

      if (classes.length) {
        while (elem = this[i++]) {
          curValue = getClass(elem); // This expression is here for better compressibility (see addClass)

          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

          if (cur) {
            j = 0;

            while (clazz = classes[j++]) {
              // Remove *all* instances
              while (cur.indexOf(" " + clazz + " ") > -1) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            } // Only assign if different to avoid unneeded rendering.


            finalValue = stripAndCollapse(cur);

            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }

      return this;
    },
    toggleClass: function toggleClass(value, stateVal) {
      var type = _typeof(value),
          isValidValue = type === "string" || Array.isArray(value);

      if (typeof stateVal === "boolean" && isValidValue) {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }

      if (isFunction(value)) {
        return this.each(function (i) {
          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
        });
      }

      return this.each(function () {
        var className, i, self, classNames;

        if (isValidValue) {
          // Toggle individual class names
          i = 0;
          self = jQuery(this);
          classNames = classesToArray(value);

          while (className = classNames[i++]) {
            // Check each className given, space separated list
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          } // Toggle whole class name

        } else if (value === undefined || type === "boolean") {
          className = getClass(this);

          if (className) {
            // Store className if set
            dataPriv.set(this, "__className__", className);
          } // If the element has a class name or if we're passed `false`,
          // then remove the whole classname (if there was one, the above saved it).
          // Otherwise bring back whatever was previously saved (if anything),
          // falling back to the empty string if nothing was stored.


          if (this.setAttribute) {
            this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
          }
        }
      });
    },
    hasClass: function hasClass(selector) {
      var className,
          elem,
          i = 0;
      className = " " + selector + " ";

      while (elem = this[i++]) {
        if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
          return true;
        }
      }

      return false;
    }
  });
  var rreturn = /\r/g;
  jQuery.fn.extend({
    val: function val(value) {
      var hooks,
          ret,
          valueIsFunction,
          elem = this[0];

      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }

          ret = elem.value; // Handle most common string cases

          if (typeof ret === "string") {
            return ret.replace(rreturn, "");
          } // Handle cases where value is null/undef or number


          return ret == null ? "" : ret;
        }

        return;
      }

      valueIsFunction = isFunction(value);
      return this.each(function (i) {
        var val;

        if (this.nodeType !== 1) {
          return;
        }

        if (valueIsFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        } // Treat null/undefined as ""; convert numbers to string


        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (Array.isArray(val)) {
          val = jQuery.map(val, function (value) {
            return value == null ? "" : value + "";
          });
        }

        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting

        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function get(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : // Support: IE <=10 - 11 only
          // option.text throws exceptions (#14686, #14858)
          // Strip and collapse whitespace
          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
          stripAndCollapse(jQuery.text(elem));
        }
      },
      select: {
        get: function get(elem) {
          var value,
              option,
              i,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one",
              values = one ? null : [],
              max = one ? index + 1 : options.length;

          if (index < 0) {
            i = max;
          } else {
            i = one ? index : 0;
          } // Loop through all the selected options


          for (; i < max; i++) {
            option = options[i]; // Support: IE <=9 only
            // IE8-9 doesn't update selected after form reset (#2551)

            if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
            !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
              // Get the specific value for the option
              value = jQuery(option).val(); // We don't need an array for one selects

              if (one) {
                return value;
              } // Multi-Selects return an array


              values.push(value);
            }
          }

          return values;
        },
        set: function set(elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;

          while (i--) {
            option = options[i];
            /* eslint-disable no-cond-assign */

            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
              optionSet = true;
            }
            /* eslint-enable no-cond-assign */

          } // Force browsers to behave consistently when non-matching value is set


          if (!optionSet) {
            elem.selectedIndex = -1;
          }

          return values;
        }
      }
    }
  }); // Radios and checkboxes getter/setter

  jQuery.each(["radio", "checkbox"], function () {
    jQuery.valHooks[this] = {
      set: function set(elem, value) {
        if (Array.isArray(value)) {
          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
        }
      }
    };

    if (!support.checkOn) {
      jQuery.valHooks[this].get = function (elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  }); // Return jQuery for attributes-only inclusion

  support.focusin = "onfocusin" in window;

  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
      stopPropagationCallback = function stopPropagationCallback(e) {
    e.stopPropagation();
  };

  jQuery.extend(jQuery.event, {
    trigger: function trigger(event, data, elem, onlyHandlers) {
      var i,
          cur,
          tmp,
          bubbleType,
          ontype,
          handle,
          special,
          lastElement,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = lastElement = tmp = elem = elem || document; // Don't do events on text and comment nodes

      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      } // focus/blur morphs to focusin/out; ensure we're not firing them right now


      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }

      if (type.indexOf(".") > -1) {
        // Namespaced trigger; create a regexp to match event type in handle()
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }

      ontype = type.indexOf(":") < 0 && "on" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string

      event = event[jQuery.expando] ? event : new jQuery.Event(type, _typeof(event) === "object" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)

      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null; // Clean up the event in case it is being reused

      event.result = undefined;

      if (!event.target) {
        event.target = elem;
      } // Clone any incoming data and prepend the event, creating the handler arg list


      data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines

      special = jQuery.event.special[type] || {};

      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      } // Determine event propagation path in advance, per W3C events spec (#9951)
      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)


      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
        bubbleType = special.delegateType || type;

        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }

        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        } // Only add window if we got to document (e.g., not plain obj or detached DOM)


        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      } // Fire handlers on the event path


      i = 0;

      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        lastElement = cur;
        event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler

        handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");

        if (handle) {
          handle.apply(cur, data);
        } // Native handler


        handle = ontype && cur[ontype];

        if (handle && handle.apply && acceptData(cur)) {
          event.result = handle.apply(cur, data);

          if (event.result === false) {
            event.preventDefault();
          }
        }
      }

      event.type = type; // If nobody prevented the default action, do it now

      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
          // Call a native DOM method on the target with the same name as the event.
          // Don't do default actions on window, that's where global variables be (#6170)
          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
            // Don't re-trigger an onFOO event when we call its FOO() method
            tmp = elem[ontype];

            if (tmp) {
              elem[ontype] = null;
            } // Prevent re-triggering of the same event, since we already bubbled it above


            jQuery.event.triggered = type;

            if (event.isPropagationStopped()) {
              lastElement.addEventListener(type, stopPropagationCallback);
            }

            elem[type]();

            if (event.isPropagationStopped()) {
              lastElement.removeEventListener(type, stopPropagationCallback);
            }

            jQuery.event.triggered = undefined;

            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }

      return event.result;
    },
    // Piggyback on a donor event to simulate a different one
    // Used only for `focus(in | out)` events
    simulate: function simulate(type, elem, event) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true
      });
      jQuery.event.trigger(e, null, elem);
    }
  });
  jQuery.fn.extend({
    trigger: function trigger(type, data) {
      return this.each(function () {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function triggerHandler(type, data) {
      var elem = this[0];

      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  }); // Support: Firefox <=44
  // Firefox doesn't have focus(in | out) events
  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
  //
  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
  // focus(in | out) events fire after focus & blur events,
  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857

  if (!support.focusin) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function (orig, fix) {
      // Attach a single capturing handler on the document while someone wants focusin/focusout
      var handler = function handler(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
      };

      jQuery.event.special[fix] = {
        setup: function setup() {
          var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix);

          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }

          dataPriv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function teardown() {
          var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix) - 1;

          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            dataPriv.remove(doc, fix);
          } else {
            dataPriv.access(doc, fix, attaches);
          }
        }
      };
    });
  }

  var location = window.location;
  var nonce = Date.now();
  var rquery = /\?/; // Cross-browser xml parsing

  jQuery.parseXML = function (data) {
    var xml;

    if (!data || typeof data !== "string") {
      return null;
    } // Support: IE 9 - 11 only
    // IE throws on parseFromString with invalid input.


    try {
      xml = new window.DOMParser().parseFromString(data, "text/xml");
    } catch (e) {
      xml = undefined;
    }

    if (!xml || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }

    return xml;
  };

  var rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;

  function buildParams(prefix, obj, traditional, add) {
    var name;

    if (Array.isArray(obj)) {
      // Serialize array item.
      jQuery.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v);
        } else {
          // Item is non-scalar (array or object), encode its numeric index.
          buildParams(prefix + "[" + (_typeof(v) === "object" && v != null ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && toType(obj) === "object") {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      // Serialize scalar item.
      add(prefix, obj);
    }
  } // Serialize an array of form elements or a set of
  // key/values into a query string


  jQuery.param = function (a, traditional) {
    var prefix,
        s = [],
        add = function add(key, valueOrFunction) {
      // If value is a function, invoke it and use its return value
      var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
      s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
    }; // If an array was passed in, assume that it is an array of form elements.


    if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
      // Serialize the form elements
      jQuery.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    } // Return the resulting serialization


    return s.join("&");
  };

  jQuery.fn.extend({
    serialize: function serialize() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function serializeArray() {
      return this.map(function () {
        // Can add propHook for "elements" to filter or add form elements
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function () {
        var type = this.type; // Use .is( ":disabled" ) so that fieldset[disabled] works

        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function (i, elem) {
        var val = jQuery(this).val();

        if (val == null) {
          return null;
        }

        if (Array.isArray(val)) {
          return jQuery.map(val, function (val) {
            return {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            };
          });
        }

        return {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  var r20 = /%20/g,
      rhash = /#.*$/,
      rantiCache = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
      // #7653, #8125, #8152: local protocol detection
  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,

  /* Prefilters
   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
   * 2) These are called:
   *    - BEFORE asking for a transport
   *    - AFTER param serialization (s.data is a string if s.processData is true)
   * 3) key is the dataType
   * 4) the catchall symbol "*" can be used
   * 5) execution will start with transport dataType and THEN continue down to "*" if needed
   */
  prefilters = {},

  /* Transports bindings
   * 1) key is the dataType
   * 2) the catchall symbol "*" can be used
   * 3) selection will start with transport dataType and THEN go to "*" if needed
   */
  transports = {},
      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
  allTypes = "*/".concat("*"),
      // Anchor tag for parsing the document origin
  originAnchor = document.createElement("a");
  originAnchor.href = location.href; // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport

  function addToPrefiltersOrTransports(structure) {
    // dataTypeExpression is optional and defaults to "*"
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }

      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

      if (isFunction(func)) {
        // For each dataType in the dataTypeExpression
        while (dataType = dataTypes[i++]) {
          // Prepend if requested
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  } // Base inspection function for prefilters and transports


  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = structure === transports;

    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);

        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }

    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  } // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes #9887


  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};

    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }

    if (deep) {
      jQuery.extend(true, target, deep);
    }

    return target;
  }
  /* Handles responses to an ajax request:
   * - finds the right dataType (mediates between content-type and expected dataType)
   * - returns the corresponding response
   */


  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process

    while (dataTypes[0] === "*") {
      dataTypes.shift();

      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    } // Check if we're dealing with a known content-type


    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    } // Check to see if we have a response for the expected dataType


    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      // Try convertible dataTypes
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }

        if (!firstDataType) {
          firstDataType = type;
        }
      } // Or just use first one


      finalDataType = finalDataType || firstDataType;
    } // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response


    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }

      return responses[finalDataType];
    }
  }
  /* Chain conversions given the request and the original response
   * Also sets the responseXXX fields on the jqXHR instance
   */


  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        // Work with a copy of dataTypes in case we need to modify it for conversion
    dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys

    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }

    current = dataTypes.shift(); // Convert to each sequential dataType

    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      } // Apply the dataFilter if provided


      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }

      prev = current;
      current = dataTypes.shift();

      if (current) {
        // There's only work to do if current dataType is non-auto
        if (current === "*") {
          current = prev; // Convert response if prev dataType is non-auto and differs from current
        } else if (prev !== "*" && prev !== current) {
          // Seek a direct converter
          conv = converters[prev + " " + current] || converters["* " + current]; // If none found, seek a pair

          if (!conv) {
            for (conv2 in converters) {
              // If conv2 outputs current
              tmp = conv2.split(" ");

              if (tmp[1] === current) {
                // If prev can be converted to accepted input
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];

                if (conv) {
                  // Condense equivalence converters
                  if (conv === true) {
                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }

                  break;
                }
              }
            }
          } // Apply converter (if not an equivalence)


          if (conv !== true) {
            // Unless errors are allowed to bubble, catch and return them
            if (conv && s.throws) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }

    return {
      state: "success",
      data: response
    };
  }

  jQuery.extend({
    // Counter for holding the number of active queries
    active: 0,
    // Last-Modified header cache for next request
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: location.href,
      type: "GET",
      isLocal: rlocalProtocol.test(location.protocol),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",

      /*
      timeout: 0,
      data: null,
      dataType: null,
      username: null,
      password: null,
      cache: null,
      throws: false,
      traditional: false,
      headers: {},
      */
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      // Data converters
      // Keys separate source (or catchall "*") and destination types with a single space
      converters: {
        // Convert anything to text
        "* text": String,
        // Text to html (true = no transformation)
        "text html": true,
        // Evaluate text as a json expression
        "text json": JSON.parse,
        // Parse text as xml
        "text xml": jQuery.parseXML
      },
      // For options that shouldn't be deep extended:
      // you can add your own custom options here if
      // and when you create one that shouldn't be
      // deep extended (see ajaxExtend)
      flatOptions: {
        url: true,
        context: true
      }
    },
    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function ajaxSetup(target, settings) {
      return settings ? // Building a settings object
      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings
      ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    // Main method
    ajax: function ajax(url, options) {
      // If url is an object, simulate pre-1.5 signature
      if (_typeof(url) === "object") {
        options = url;
        url = undefined;
      } // Force options to be an object


      options = options || {};

      var transport,
          // URL without anti-cache param
      cacheURL,
          // Response headers
      responseHeadersString,
          responseHeaders,
          // timeout handle
      timeoutTimer,
          // Url cleanup var
      urlAnchor,
          // Request state (becomes false upon send and true upon completion)
      completed,
          // To know if global events are to be dispatched
      fireGlobals,
          // Loop variable
      i,
          // uncached part of the url
      uncached,
          // Create the final options object
      s = jQuery.ajaxSetup({}, options),
          // Callbacks context
      callbackContext = s.context || s,
          // Context for global events is callbackContext if it is a DOM node or jQuery collection
      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          // Deferreds
      deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          // Status-dependent callbacks
      _statusCode = s.statusCode || {},
          // Headers (they are sent all at once)
      requestHeaders = {},
          requestHeadersNames = {},
          // Default abort message
      strAbort = "canceled",
          // Fake xhr
      jqXHR = {
        readyState: 0,
        // Builds headers hashtable if needed
        getResponseHeader: function getResponseHeader(key) {
          var match;

          if (completed) {
            if (!responseHeaders) {
              responseHeaders = {};

              while (match = rheaders.exec(responseHeadersString)) {
                responseHeaders[match[1].toLowerCase()] = match[2];
              }
            }

            match = responseHeaders[key.toLowerCase()];
          }

          return match == null ? null : match;
        },
        // Raw string
        getAllResponseHeaders: function getAllResponseHeaders() {
          return completed ? responseHeadersString : null;
        },
        // Caches the header
        setRequestHeader: function setRequestHeader(name, value) {
          if (completed == null) {
            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
            requestHeaders[name] = value;
          }

          return this;
        },
        // Overrides response content-type header
        overrideMimeType: function overrideMimeType(type) {
          if (completed == null) {
            s.mimeType = type;
          }

          return this;
        },
        // Status-dependent callbacks
        statusCode: function statusCode(map) {
          var code;

          if (map) {
            if (completed) {
              // Execute the appropriate callbacks
              jqXHR.always(map[jqXHR.status]);
            } else {
              // Lazy-add the new callbacks in a way that preserves old ones
              for (code in map) {
                _statusCode[code] = [_statusCode[code], map[code]];
              }
            }
          }

          return this;
        },
        // Cancel the request
        abort: function abort(statusText) {
          var finalText = statusText || strAbort;

          if (transport) {
            transport.abort(finalText);
          }

          done(0, finalText);
          return this;
        }
      }; // Attach deferreds


      deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)
      // Handle falsy url in the settings object (#10093: consistency with old signature)
      // We also use the url parameter if available

      s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"); // Alias method option to type as per ticket #12004

      s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list

      s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""]; // A cross-domain request is in order when the origin doesn't match the current origin.

      if (s.crossDomain == null) {
        urlAnchor = document.createElement("a"); // Support: IE <=8 - 11, Edge 12 - 15
        // IE throws exception on accessing the href property if url is malformed,
        // e.g. http://example.com:80x/

        try {
          urlAnchor.href = s.url; // Support: IE <=8 - 11 only
          // Anchor's host property isn't correctly set when s.url is relative

          urlAnchor.href = urlAnchor.href;
          s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
        } catch (e) {
          // If there is an error parsing the URL, assume it is crossDomain,
          // it can be rejected by the transport if it is invalid
          s.crossDomain = true;
        }
      } // Convert data if not already a string


      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      } // Apply prefilters


      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there

      if (completed) {
        return jqXHR;
      } // We can fire global events as of now if asked to
      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)


      fireGlobals = jQuery.event && s.global; // Watch for a new set of requests

      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      } // Uppercase the type


      s.type = s.type.toUpperCase(); // Determine if request has content

      s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since
      // and/or If-None-Match header later on
      // Remove hash to simplify url manipulation

      cacheURL = s.url.replace(rhash, ""); // More options handling for requests with no content

      if (!s.hasContent) {
        // Remember the hash so we can put it back
        uncached = s.url.slice(cacheURL.length); // If data is available and should be processed, append data to url

        if (s.data && (s.processData || typeof s.data === "string")) {
          cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data; // #9682: remove data so that it's not used in an eventual retry

          delete s.data;
        } // Add or update anti-cache param if needed


        if (s.cache === false) {
          cacheURL = cacheURL.replace(rantiCache, "$1");
          uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached;
        } // Put hash and anti-cache on the URL that will be requested (gh-1732)


        s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)
      } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
        s.data = s.data.replace(r20, "+");
      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.


      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }

        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      } // Set the correct header, if data is being sent


      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      } // Set the Accepts header for the server, depending on the dataType


      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]); // Check for headers option

      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      } // Allow custom headers/mimetypes and early abort


      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
        // Abort if not done already and return
        return jqXHR.abort();
      } // Aborting is no longer a cancellation


      strAbort = "abort"; // Install callbacks on deferreds

      completeDeferred.add(s.complete);
      jqXHR.done(s.success);
      jqXHR.fail(s.error); // Get transport

      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort

      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1; // Send global event

        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        } // If request was aborted inside ajaxSend, stop there


        if (completed) {
          return jqXHR;
        } // Timeout


        if (s.async && s.timeout > 0) {
          timeoutTimer = window.setTimeout(function () {
            jqXHR.abort("timeout");
          }, s.timeout);
        }

        try {
          completed = false;
          transport.send(requestHeaders, done);
        } catch (e) {
          // Rethrow post-completion exceptions
          if (completed) {
            throw e;
          } // Propagate others as results


          done(-1, e);
        }
      } // Callback for when everything is done


      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText; // Ignore repeat invocations

        if (completed) {
          return;
        }

        completed = true; // Clear timeout if it exists

        if (timeoutTimer) {
          window.clearTimeout(timeoutTimer);
        } // Dereference transport for early garbage collection
        // (no matter how long the jqXHR object will be used)


        transport = undefined; // Cache response headers

        responseHeadersString = headers || ""; // Set readyState

        jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful

        isSuccess = status >= 200 && status < 300 || status === 304; // Get response data

        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        } // Convert no matter what (that way responseXXX fields are always set)


        response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining

        if (isSuccess) {
          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");

            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }

            modified = jqXHR.getResponseHeader("etag");

            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          } // if no content


          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent"; // if not modified
          } else if (status === 304) {
            statusText = "notmodified"; // If we have data, let's convert it
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          // Extract error from statusText and normalize for non-aborts
          error = statusText;

          if (status || !statusText) {
            statusText = "error";

            if (status < 0) {
              status = 0;
            }
          }
        } // Set data for the fake xhr object


        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + ""; // Success/Error

        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        } // Status-dependent callbacks


        jqXHR.statusCode(_statusCode);
        _statusCode = undefined;

        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        } // Complete


        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]); // Handle the global AJAX counter

          if (! --jQuery.active) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }

      return jqXHR;
    },
    getJSON: function getJSON(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function getScript(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function (i, method) {
    jQuery[method] = function (url, data, callback, type) {
      // Shift arguments if data argument was omitted
      if (isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      } // The url can be an options object (which then must have .url)


      return jQuery.ajax(jQuery.extend({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      }, jQuery.isPlainObject(url) && url));
    };
  });

  jQuery._evalUrl = function (url) {
    return jQuery.ajax({
      url: url,
      // Make this explicit, since user can override this through ajaxSetup (#11264)
      type: "GET",
      dataType: "script",
      cache: true,
      async: false,
      global: false,
      "throws": true
    });
  };

  jQuery.fn.extend({
    wrapAll: function wrapAll(html) {
      var wrap;

      if (this[0]) {
        if (isFunction(html)) {
          html = html.call(this[0]);
        } // The elements to wrap the target around


        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }

        wrap.map(function () {
          var elem = this;

          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }

          return elem;
        }).append(this);
      }

      return this;
    },
    wrapInner: function wrapInner(html) {
      if (isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }

      return this.each(function () {
        var self = jQuery(this),
            contents = self.contents();

        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function wrap(html) {
      var htmlIsFunction = isFunction(html);
      return this.each(function (i) {
        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function unwrap(selector) {
      this.parent(selector).not("body").each(function () {
        jQuery(this).replaceWith(this.childNodes);
      });
      return this;
    }
  });

  jQuery.expr.pseudos.hidden = function (elem) {
    return !jQuery.expr.pseudos.visible(elem);
  };

  jQuery.expr.pseudos.visible = function (elem) {
    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
  };

  jQuery.ajaxSettings.xhr = function () {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  };

  var xhrSuccessStatus = {
    // File protocol always yields status code 0, assume 200
    0: 200,
    // Support: IE <=9 only
    // #1450: sometimes IE returns 1223 when it should be 204
    1223: 204
  },
      xhrSupported = jQuery.ajaxSettings.xhr();
  support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function (options) {
    var _callback, errorCallback; // Cross domain only allowed if supported through XMLHttpRequest


    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function send(headers, complete) {
          var i,
              xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided

          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          } // Override mime type if needed


          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          } // X-Requested-With header
          // For cross-domain requests, seeing as conditions for a preflight are
          // akin to a jigsaw puzzle, we simply never set it to be sure.
          // (it can always be set on a per-request basis or even using ajaxSetup)
          // For same-domain requests, won't change header if already provided.


          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          } // Set headers


          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          } // Callback


          _callback = function callback(type) {
            return function () {
              if (_callback) {
                _callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;

                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  // Support: IE <=9 only
                  // On a manual native abort, IE9 throws
                  // errors on any property access that is not readyState
                  if (typeof xhr.status !== "number") {
                    complete(0, "error");
                  } else {
                    complete( // File: protocol always yields status 0; see #8605, #14207
                    xhr.status, xhr.statusText);
                  }
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only
                  // IE9 has no XHR2 but throws on binary (trac-11426)
                  // For XHR2 non-text, let the caller handle it (gh-2498)
                  (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                    binary: xhr.response
                  } : {
                    text: xhr.responseText
                  }, xhr.getAllResponseHeaders());
                }
              }
            };
          }; // Listen to events


          xhr.onload = _callback();
          errorCallback = xhr.onerror = xhr.ontimeout = _callback("error"); // Support: IE 9 only
          // Use onreadystatechange to replace onabort
          // to handle uncaught aborts

          if (xhr.onabort !== undefined) {
            xhr.onabort = errorCallback;
          } else {
            xhr.onreadystatechange = function () {
              // Check readyState before timeout as it changes
              if (xhr.readyState === 4) {
                // Allow onerror to be called first,
                // but that will not handle a native abort
                // Also, save errorCallback to a variable
                // as xhr.onerror cannot be accessed
                window.setTimeout(function () {
                  if (_callback) {
                    errorCallback();
                  }
                });
              }
            };
          } // Create the abort callback


          _callback = _callback("abort");

          try {
            // Do send the request (this may raise an exception)
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            // #14683: Only rethrow if this hasn't been notified as an error yet
            if (_callback) {
              throw e;
            }
          }
        },
        abort: function abort() {
          if (_callback) {
            _callback();
          }
        }
      };
    }
  }); // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)

  jQuery.ajaxPrefilter(function (s) {
    if (s.crossDomain) {
      s.contents.script = false;
    }
  }); // Install script dataType

  jQuery.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /\b(?:java|ecma)script\b/
    },
    converters: {
      "text script": function textScript(text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  }); // Handle cache's special case and crossDomain

  jQuery.ajaxPrefilter("script", function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }

    if (s.crossDomain) {
      s.type = "GET";
    }
  }); // Bind script tag hack transport

  jQuery.ajaxTransport("script", function (s) {
    // This transport only deals with cross domain requests
    if (s.crossDomain) {
      var script, _callback2;

      return {
        send: function send(_, complete) {
          script = jQuery("<script>").prop({
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", _callback2 = function callback(evt) {
            script.remove();
            _callback2 = null;

            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          }); // Use native DOM manipulation to avoid our domManip AJAX trickery

          document.head.appendChild(script[0]);
        },
        abort: function abort() {
          if (_callback2) {
            _callback2();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/; // Default jsonp settings

  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function jsonpCallback() {
      var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
      this[callback] = true;
      return callback;
    }
  }); // Detect, normalize options and install callbacks for jsonp requests

  jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data"); // Handle iff the expected data type is "jsonp" or we have a parameter to set

    if (jsonProp || s.dataTypes[0] === "jsonp") {
      // Get callback name, remembering preexisting value associated with it
      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data

      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      } // Use data converter to retrieve json after script execution


      s.converters["script json"] = function () {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }

        return responseContainer[0];
      }; // Force json dataType


      s.dataTypes[0] = "json"; // Install callback

      overwritten = window[callbackName];

      window[callbackName] = function () {
        responseContainer = arguments;
      }; // Clean-up function (fires after converters)


      jqXHR.always(function () {
        // If previous value didn't exist - remove it
        if (overwritten === undefined) {
          jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value
        } else {
          window[callbackName] = overwritten;
        } // Save back as free


        if (s[callbackName]) {
          // Make sure that re-using the options doesn't screw things around
          s.jsonpCallback = originalSettings.jsonpCallback; // Save the callback name for future use

          oldCallbacks.push(callbackName);
        } // Call if it was a function and we have a response


        if (responseContainer && isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }

        responseContainer = overwritten = undefined;
      }); // Delegate to script

      return "script";
    }
  }); // Support: Safari 8 only
  // In Safari 8 documents created via document.implementation.createHTMLDocument
  // collapse sibling forms: the second one becomes a child of the first one.
  // Because of that, this security measure has to be disabled in Safari 8.
  // https://bugs.webkit.org/show_bug.cgi?id=137337

  support.createHTMLDocument = function () {
    var body = document.implementation.createHTMLDocument("").body;
    body.innerHTML = "<form></form><form></form>";
    return body.childNodes.length === 2;
  }(); // Argument "data" should be string of html
  // context (optional): If specified, the fragment will be created in this context,
  // defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string


  jQuery.parseHTML = function (data, context, keepScripts) {
    if (typeof data !== "string") {
      return [];
    }

    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }

    var base, parsed, scripts;

    if (!context) {
      // Stop scripts or inline event handlers from being executed immediately
      // by using document.implementation
      if (support.createHTMLDocument) {
        context = document.implementation.createHTMLDocument(""); // Set the base href for the created document
        // so any parsed elements with URLs
        // are based on the document's URL (gh-2965)

        base = context.createElement("base");
        base.href = document.location.href;
        context.head.appendChild(base);
      } else {
        context = document;
      }
    }

    parsed = rsingleTag.exec(data);
    scripts = !keepScripts && []; // Single tag

    if (parsed) {
      return [context.createElement(parsed[1])];
    }

    parsed = buildFragment([data], context, scripts);

    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }

    return jQuery.merge([], parsed.childNodes);
  };
  /**
   * Load a url into a page
   */


  jQuery.fn.load = function (url, params, callback) {
    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");

    if (off > -1) {
      selector = stripAndCollapse(url.slice(off));
      url = url.slice(0, off);
    } // If it's a function


    if (isFunction(params)) {
      // We assume that it's the callback
      callback = params;
      params = undefined; // Otherwise, build a param string
    } else if (params && _typeof(params) === "object") {
      type = "POST";
    } // If we have elements to modify, make the request


    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        // If "type" variable is undefined, then "GET" method will be used.
        // Make value of this field explicit since
        // user can override it through ajaxSetup method
        type: type || "GET",
        dataType: "html",
        data: params
      }).done(function (responseText) {
        // Save response for use in complete callback
        response = arguments;
        self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
        // Exclude scripts to avoid IE 'Permission Denied' errors
        jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
        responseText); // If the request succeeds, this function gets "data", "status", "jqXHR"
        // but they are ignored because response was set above.
        // If it fails, this function gets "jqXHR", "status", "error"
      }).always(callback && function (jqXHR, status) {
        self.each(function () {
          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
        });
      });
    }

    return this;
  }; // Attach a bunch of functions for handling common AJAX events


  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
    jQuery.fn[type] = function (fn) {
      return this.on(type, fn);
    };
  });

  jQuery.expr.pseudos.animated = function (elem) {
    return jQuery.grep(jQuery.timers, function (fn) {
      return elem === fn.elem;
    }).length;
  };

  jQuery.offset = {
    setOffset: function setOffset(elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {}; // Set position first, in-case top/left are set even on static elem

      if (position === "static") {
        elem.style.position = "relative";
      }

      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1; // Need to be able to calculate position if either
      // top or left is auto and position is either absolute or fixed

      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }

      if (isFunction(options)) {
        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
        options = options.call(elem, i, jQuery.extend({}, curOffset));
      }

      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }

      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }

      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  jQuery.fn.extend({
    // offset() relates an element's border box to the document origin
    offset: function offset(options) {
      // Preserve chaining for setter
      if (arguments.length) {
        return options === undefined ? this : this.each(function (i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }

      var rect,
          win,
          elem = this[0];

      if (!elem) {
        return;
      } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
      // Support: IE <=11 only
      // Running getBoundingClientRect on a
      // disconnected node in IE throws an error


      if (!elem.getClientRects().length) {
        return {
          top: 0,
          left: 0
        };
      } // Get document-relative position by adding viewport scroll to viewport-relative gBCR


      rect = elem.getBoundingClientRect();
      win = elem.ownerDocument.defaultView;
      return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset
      };
    },
    // position() relates an element's margin box to its offset parent's padding box
    // This corresponds to the behavior of CSS absolute positioning
    position: function position() {
      if (!this[0]) {
        return;
      }

      var offsetParent,
          offset,
          doc,
          elem = this[0],
          parentOffset = {
        top: 0,
        left: 0
      }; // position:fixed elements are offset from the viewport, which itself always has zero offset

      if (jQuery.css(elem, "position") === "fixed") {
        // Assume position:fixed implies availability of getBoundingClientRect
        offset = elem.getBoundingClientRect();
      } else {
        offset = this.offset(); // Account for the *real* offset parent, which can be the document or its root element
        // when a statically positioned element is identified

        doc = elem.ownerDocument;
        offsetParent = elem.offsetParent || doc.documentElement;

        while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.parentNode;
        }

        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
          // Incorporate borders into its offset, since they are outside its content origin
          parentOffset = jQuery(offsetParent).offset();
          parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
          parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
        }
      } // Subtract parent offsets and element margins


      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    // This method will return documentElement in the following cases:
    // 1) For the element inside the iframe without offsetParent, this method will return
    //    documentElement of the parent window
    // 2) For the hidden or detached element
    // 3) For body or html element, i.e. in case of the html node - it will return itself
    //
    // but those exceptions were never presented as a real life use-cases
    // and might be considered as more preferable results.
    //
    // This logic, however, is not guaranteed and can change at any point in the future
    offsetParent: function offsetParent() {
      return this.map(function () {
        var offsetParent = this.offsetParent;

        while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.offsetParent;
        }

        return offsetParent || documentElement;
      });
    }
  }); // Create scrollLeft and scrollTop methods

  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function (method, prop) {
    var top = "pageYOffset" === prop;

    jQuery.fn[method] = function (val) {
      return access(this, function (elem, method, val) {
        // Coalesce documents and windows
        var win;

        if (isWindow(elem)) {
          win = elem;
        } else if (elem.nodeType === 9) {
          win = elem.defaultView;
        }

        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }

        if (win) {
          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length);
    };
  }); // Support: Safari <=7 - 9.1, Chrome <=37 - 49
  // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
  // getComputedStyle returns percent when specified for top/left/bottom/right;
  // rather than make the css module depend on the offset module, just check for it here

  jQuery.each(["top", "left"], function (i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset

        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods

  jQuery.each({
    Height: "height",
    Width: "width"
  }, function (name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function (defaultExtra, funcName) {
      // Margin is only for outerHeight, outerWidth
      jQuery.fn[funcName] = function (margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function (elem, type, value) {
          var doc;

          if (isWindow(elem)) {
            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
            return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
          } // Get document width or height


          if (elem.nodeType === 9) {
            doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
            // whichever is greatest

            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }

          return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
          jQuery.css(elem, type, extra) : // Set width or height on the element
          jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable);
      };
    });
  });
  jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (i, name) {
    // Handle event binding
    jQuery.fn[name] = function (data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({
    hover: function hover(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }
  });
  jQuery.fn.extend({
    bind: function bind(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function unbind(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function delegate(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function undelegate(selector, types, fn) {
      // ( namespace ) or ( selector, types [, fn] )
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    }
  }); // Bind a function to a context, optionally partially applying any
  // arguments.
  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
  // However, it is not slated for removal any time soon

  jQuery.proxy = function (fn, context) {
    var tmp, args, proxy;

    if (typeof context === "string") {
      tmp = fn[context];
      context = fn;
      fn = tmp;
    } // Quick check to determine if target is callable, in the spec
    // this throws a TypeError, but we will just return undefined.


    if (!isFunction(fn)) {
      return undefined;
    } // Simulated bind


    args = _slice.call(arguments, 2);

    proxy = function proxy() {
      return fn.apply(context || this, args.concat(_slice.call(arguments)));
    }; // Set the guid of unique handler to the same of original handler, so it can be removed


    proxy.guid = fn.guid = fn.guid || jQuery.guid++;
    return proxy;
  };

  jQuery.holdReady = function (hold) {
    if (hold) {
      jQuery.readyWait++;
    } else {
      jQuery.ready(true);
    }
  };

  jQuery.isArray = Array.isArray;
  jQuery.parseJSON = JSON.parse;
  jQuery.nodeName = nodeName;
  jQuery.isFunction = isFunction;
  jQuery.isWindow = isWindow;
  jQuery.camelCase = camelCase;
  jQuery.type = toType;
  jQuery.now = Date.now;

  jQuery.isNumeric = function (obj) {
    // As of jQuery 3.0, isNumeric is limited to
    // strings and numbers (primitives or objects)
    // that can be coerced to finite numbers (gh-2662)
    var type = jQuery.type(obj);
    return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    !isNaN(obj - parseFloat(obj));
  }; // Register as a named AMD module, since jQuery can be concatenated with other
  // files that may use define, but not via a proper concatenation script that
  // understands anonymous AMD modules. A named AMD is safest and most robust
  // way to register. Lowercase jquery is used because AMD module names are
  // derived from file names, and jQuery is normally delivered in a lowercase
  // file name. Do this after creating the global so that if an AMD module wants
  // to call noConflict to hide this version of jQuery, it will work.
  // Note that for maximum portability, libraries that are not jQuery should
  // declare themselves as anonymous modules, and avoid setting a global if an
  // AMD loader is present. jQuery is a special case. For more information, see
  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon


  if (typeof define === "function" && define.amd) {
    define("jquery", [], function () {
      return jQuery;
    });
  }

  var // Map over jQuery in case of overwrite
  _jQuery = window.jQuery,
      // Map over the $ in case of overwrite
  _$ = window.$;

  jQuery.noConflict = function (deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }

    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }

    return jQuery;
  }; // Expose jQuery and $ identifiers, even in AMD
  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (#13566)


  if (!noGlobal) {
    window.jQuery = window.$ = jQuery;
  }

  return jQuery;
});
},{"process":"../../.nvm/versions/node/v11.10.1/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"_lodash.min.js":[function(require,module,exports) {
var global = arguments[3];
var define;
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function () {
  function n(n, t) {
    return n.set(t[0], t[1]), n;
  }

  function t(n, t) {
    return n.add(t), n;
  }

  function r(n, t, r) {
    switch (r.length) {
      case 0:
        return n.call(t);

      case 1:
        return n.call(t, r[0]);

      case 2:
        return n.call(t, r[0], r[1]);

      case 3:
        return n.call(t, r[0], r[1], r[2]);
    }

    return n.apply(t, r);
  }

  function e(n, t, r, e) {
    for (var u = -1, i = null == n ? 0 : n.length; ++u < i;) {
      var o = n[u];
      t(e, o, r(o), n);
    }

    return e;
  }

  function u(n, t) {
    for (var r = -1, e = null == n ? 0 : n.length; ++r < e && t(n[r], r, n) !== !1;) {
      ;
    }

    return n;
  }

  function i(n, t) {
    for (var r = null == n ? 0 : n.length; r-- && t(n[r], r, n) !== !1;) {
      ;
    }

    return n;
  }

  function o(n, t) {
    for (var r = -1, e = null == n ? 0 : n.length; ++r < e;) {
      if (!t(n[r], r, n)) return !1;
    }

    return !0;
  }

  function f(n, t) {
    for (var r = -1, e = null == n ? 0 : n.length, u = 0, i = []; ++r < e;) {
      var o = n[r];
      t(o, r, n) && (i[u++] = o);
    }

    return i;
  }

  function a(n, t) {
    var r = null == n ? 0 : n.length;
    return !!r && b(n, t, 0) > -1;
  }

  function c(n, t, r) {
    for (var e = -1, u = null == n ? 0 : n.length; ++e < u;) {
      if (r(t, n[e])) return !0;
    }

    return !1;
  }

  function l(n, t) {
    for (var r = -1, e = null == n ? 0 : n.length, u = Array(e); ++r < e;) {
      u[r] = t(n[r], r, n);
    }

    return u;
  }

  function s(n, t) {
    for (var r = -1, e = t.length, u = n.length; ++r < e;) {
      n[u + r] = t[r];
    }

    return n;
  }

  function h(n, t, r, e) {
    var u = -1,
        i = null == n ? 0 : n.length;

    for (e && i && (r = n[++u]); ++u < i;) {
      r = t(r, n[u], u, n);
    }

    return r;
  }

  function p(n, t, r, e) {
    var u = null == n ? 0 : n.length;

    for (e && u && (r = n[--u]); u--;) {
      r = t(r, n[u], u, n);
    }

    return r;
  }

  function v(n, t) {
    for (var r = -1, e = null == n ? 0 : n.length; ++r < e;) {
      if (t(n[r], r, n)) return !0;
    }

    return !1;
  }

  function _(n) {
    return n.split("");
  }

  function g(n) {
    return n.match(Dt) || [];
  }

  function y(n, t, r) {
    var e;
    return r(n, function (n, r, u) {
      if (t(n, r, u)) return e = r, !1;
    }), e;
  }

  function d(n, t, r, e) {
    for (var u = n.length, i = r + (e ? 1 : -1); e ? i-- : ++i < u;) {
      if (t(n[i], i, n)) return i;
    }

    return -1;
  }

  function b(n, t, r) {
    return t === t ? K(n, t, r) : d(n, m, r);
  }

  function w(n, t, r, e) {
    for (var u = r - 1, i = n.length; ++u < i;) {
      if (e(n[u], t)) return u;
    }

    return -1;
  }

  function m(n) {
    return n !== n;
  }

  function x(n, t) {
    var r = null == n ? 0 : n.length;
    return r ? I(n, t) / r : Ln;
  }

  function j(n) {
    return function (t) {
      return null == t ? X : t[n];
    };
  }

  function A(n) {
    return function (t) {
      return null == n ? X : n[t];
    };
  }

  function k(n, t, r, e, u) {
    return u(n, function (n, u, i) {
      r = e ? (e = !1, n) : t(r, n, u, i);
    }), r;
  }

  function O(n, t) {
    var r = n.length;

    for (n.sort(t); r--;) {
      n[r] = n[r].value;
    }

    return n;
  }

  function I(n, t) {
    for (var r, e = -1, u = n.length; ++e < u;) {
      var i = t(n[e]);
      i !== X && (r = r === X ? i : r + i);
    }

    return r;
  }

  function R(n, t) {
    for (var r = -1, e = Array(n); ++r < n;) {
      e[r] = t(r);
    }

    return e;
  }

  function z(n, t) {
    return l(t, function (t) {
      return [t, n[t]];
    });
  }

  function E(n) {
    return function (t) {
      return n(t);
    };
  }

  function S(n, t) {
    return l(t, function (t) {
      return n[t];
    });
  }

  function W(n, t) {
    return n.has(t);
  }

  function L(n, t) {
    for (var r = -1, e = n.length; ++r < e && b(t, n[r], 0) > -1;) {
      ;
    }

    return r;
  }

  function C(n, t) {
    for (var r = n.length; r-- && b(t, n[r], 0) > -1;) {
      ;
    }

    return r;
  }

  function U(n, t) {
    for (var r = n.length, e = 0; r--;) {
      n[r] === t && ++e;
    }

    return e;
  }

  function B(n) {
    return "\\" + Yr[n];
  }

  function T(n, t) {
    return null == n ? X : n[t];
  }

  function $(n) {
    return Nr.test(n);
  }

  function D(n) {
    return Pr.test(n);
  }

  function M(n) {
    for (var t, r = []; !(t = n.next()).done;) {
      r.push(t.value);
    }

    return r;
  }

  function F(n) {
    var t = -1,
        r = Array(n.size);
    return n.forEach(function (n, e) {
      r[++t] = [e, n];
    }), r;
  }

  function N(n, t) {
    return function (r) {
      return n(t(r));
    };
  }

  function P(n, t) {
    for (var r = -1, e = n.length, u = 0, i = []; ++r < e;) {
      var o = n[r];
      o !== t && o !== fn || (n[r] = fn, i[u++] = r);
    }

    return i;
  }

  function q(n) {
    var t = -1,
        r = Array(n.size);
    return n.forEach(function (n) {
      r[++t] = n;
    }), r;
  }

  function Z(n) {
    var t = -1,
        r = Array(n.size);
    return n.forEach(function (n) {
      r[++t] = [n, n];
    }), r;
  }

  function K(n, t, r) {
    for (var e = r - 1, u = n.length; ++e < u;) {
      if (n[e] === t) return e;
    }

    return -1;
  }

  function V(n, t, r) {
    for (var e = r + 1; e--;) {
      if (n[e] === t) return e;
    }

    return e;
  }

  function G(n) {
    return $(n) ? J(n) : ve(n);
  }

  function H(n) {
    return $(n) ? Y(n) : _(n);
  }

  function J(n) {
    for (var t = Mr.lastIndex = 0; Mr.test(n);) {
      ++t;
    }

    return t;
  }

  function Y(n) {
    return n.match(Mr) || [];
  }

  function Q(n) {
    return n.match(Fr) || [];
  }

  var X,
      nn = "4.17.4",
      tn = 200,
      rn = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
      en = "Expected a function",
      un = "__lodash_hash_undefined__",
      on = 500,
      fn = "__lodash_placeholder__",
      an = 1,
      cn = 2,
      ln = 4,
      sn = 1,
      hn = 2,
      pn = 1,
      vn = 2,
      _n = 4,
      gn = 8,
      yn = 16,
      dn = 32,
      bn = 64,
      wn = 128,
      mn = 256,
      xn = 512,
      jn = 30,
      An = "...",
      kn = 800,
      On = 16,
      In = 1,
      Rn = 2,
      zn = 3,
      En = 1 / 0,
      Sn = 9007199254740991,
      Wn = 1.7976931348623157e308,
      Ln = NaN,
      Cn = 4294967295,
      Un = Cn - 1,
      Bn = Cn >>> 1,
      Tn = [["ary", wn], ["bind", pn], ["bindKey", vn], ["curry", gn], ["curryRight", yn], ["flip", xn], ["partial", dn], ["partialRight", bn], ["rearg", mn]],
      $n = "[object Arguments]",
      Dn = "[object Array]",
      Mn = "[object AsyncFunction]",
      Fn = "[object Boolean]",
      Nn = "[object Date]",
      Pn = "[object DOMException]",
      qn = "[object Error]",
      Zn = "[object Function]",
      Kn = "[object GeneratorFunction]",
      Vn = "[object Map]",
      Gn = "[object Number]",
      Hn = "[object Null]",
      Jn = "[object Object]",
      Yn = "[object Promise]",
      Qn = "[object Proxy]",
      Xn = "[object RegExp]",
      nt = "[object Set]",
      tt = "[object String]",
      rt = "[object Symbol]",
      et = "[object Undefined]",
      ut = "[object WeakMap]",
      it = "[object WeakSet]",
      ot = "[object ArrayBuffer]",
      ft = "[object DataView]",
      at = "[object Float32Array]",
      ct = "[object Float64Array]",
      lt = "[object Int8Array]",
      st = "[object Int16Array]",
      ht = "[object Int32Array]",
      pt = "[object Uint8Array]",
      vt = "[object Uint8ClampedArray]",
      _t = "[object Uint16Array]",
      gt = "[object Uint32Array]",
      yt = /\b__p \+= '';/g,
      dt = /\b(__p \+=) '' \+/g,
      bt = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
      wt = /&(?:amp|lt|gt|quot|#39);/g,
      mt = /[&<>"']/g,
      xt = RegExp(wt.source),
      jt = RegExp(mt.source),
      At = /<%-([\s\S]+?)%>/g,
      kt = /<%([\s\S]+?)%>/g,
      Ot = /<%=([\s\S]+?)%>/g,
      It = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      Rt = /^\w*$/,
      zt = /^\./,
      Et = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
      St = /[\\^$.*+?()[\]{}|]/g,
      Wt = RegExp(St.source),
      Lt = /^\s+|\s+$/g,
      Ct = /^\s+/,
      Ut = /\s+$/,
      Bt = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      Tt = /\{\n\/\* \[wrapped with (.+)\] \*/,
      $t = /,? & /,
      Dt = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
      Mt = /\\(\\)?/g,
      Ft = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
      Nt = /\w*$/,
      Pt = /^[-+]0x[0-9a-f]+$/i,
      qt = /^0b[01]+$/i,
      Zt = /^\[object .+?Constructor\]$/,
      Kt = /^0o[0-7]+$/i,
      Vt = /^(?:0|[1-9]\d*)$/,
      Gt = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
      Ht = /($^)/,
      Jt = /['\n\r\u2028\u2029\\]/g,
      Yt = "\\ud800-\\udfff",
      Qt = "\\u0300-\\u036f",
      Xt = "\\ufe20-\\ufe2f",
      nr = "\\u20d0-\\u20ff",
      tr = Qt + Xt + nr,
      rr = "\\u2700-\\u27bf",
      er = "a-z\\xdf-\\xf6\\xf8-\\xff",
      ur = "\\xac\\xb1\\xd7\\xf7",
      ir = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
      or = "\\u2000-\\u206f",
      fr = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
      ar = "A-Z\\xc0-\\xd6\\xd8-\\xde",
      cr = "\\ufe0e\\ufe0f",
      lr = ur + ir + or + fr,
      sr = "[']",
      hr = "[" + Yt + "]",
      pr = "[" + lr + "]",
      vr = "[" + tr + "]",
      _r = "\\d+",
      gr = "[" + rr + "]",
      yr = "[" + er + "]",
      dr = "[^" + Yt + lr + _r + rr + er + ar + "]",
      br = "\\ud83c[\\udffb-\\udfff]",
      wr = "(?:" + vr + "|" + br + ")",
      mr = "[^" + Yt + "]",
      xr = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      jr = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      Ar = "[" + ar + "]",
      kr = "\\u200d",
      Or = "(?:" + yr + "|" + dr + ")",
      Ir = "(?:" + Ar + "|" + dr + ")",
      Rr = "(?:" + sr + "(?:d|ll|m|re|s|t|ve))?",
      zr = "(?:" + sr + "(?:D|LL|M|RE|S|T|VE))?",
      Er = wr + "?",
      Sr = "[" + cr + "]?",
      Wr = "(?:" + kr + "(?:" + [mr, xr, jr].join("|") + ")" + Sr + Er + ")*",
      Lr = "\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)",
      Cr = "\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)",
      Ur = Sr + Er + Wr,
      Br = "(?:" + [gr, xr, jr].join("|") + ")" + Ur,
      Tr = "(?:" + [mr + vr + "?", vr, xr, jr, hr].join("|") + ")",
      $r = RegExp(sr, "g"),
      Dr = RegExp(vr, "g"),
      Mr = RegExp(br + "(?=" + br + ")|" + Tr + Ur, "g"),
      Fr = RegExp([Ar + "?" + yr + "+" + Rr + "(?=" + [pr, Ar, "$"].join("|") + ")", Ir + "+" + zr + "(?=" + [pr, Ar + Or, "$"].join("|") + ")", Ar + "?" + Or + "+" + Rr, Ar + "+" + zr, Cr, Lr, _r, Br].join("|"), "g"),
      Nr = RegExp("[" + kr + Yt + tr + cr + "]"),
      Pr = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
      qr = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"],
      Zr = -1,
      Kr = {};
  Kr[at] = Kr[ct] = Kr[lt] = Kr[st] = Kr[ht] = Kr[pt] = Kr[vt] = Kr[_t] = Kr[gt] = !0, Kr[$n] = Kr[Dn] = Kr[ot] = Kr[Fn] = Kr[ft] = Kr[Nn] = Kr[qn] = Kr[Zn] = Kr[Vn] = Kr[Gn] = Kr[Jn] = Kr[Xn] = Kr[nt] = Kr[tt] = Kr[ut] = !1;
  var Vr = {};
  Vr[$n] = Vr[Dn] = Vr[ot] = Vr[ft] = Vr[Fn] = Vr[Nn] = Vr[at] = Vr[ct] = Vr[lt] = Vr[st] = Vr[ht] = Vr[Vn] = Vr[Gn] = Vr[Jn] = Vr[Xn] = Vr[nt] = Vr[tt] = Vr[rt] = Vr[pt] = Vr[vt] = Vr[_t] = Vr[gt] = !0, Vr[qn] = Vr[Zn] = Vr[ut] = !1;

  var Gr = {
    "": "A",
    "": "A",
    "": "A",
    "": "A",
    "": "A",
    "": "A",
    "": "a",
    "": "a",
    "": "a",
    "": "a",
    "": "a",
    "": "a",
    "": "C",
    "": "c",
    "": "D",
    "": "d",
    "": "E",
    "": "E",
    "": "E",
    "": "E",
    "": "e",
    "": "e",
    "": "e",
    "": "e",
    "": "I",
    "": "I",
    "": "I",
    "": "I",
    "": "i",
    "": "i",
    "": "i",
    "": "i",
    "": "N",
    "": "n",
    "": "O",
    "": "O",
    "": "O",
    "": "O",
    "": "O",
    "": "O",
    "": "o",
    "": "o",
    "": "o",
    "": "o",
    "": "o",
    "": "o",
    "": "U",
    "": "U",
    "": "U",
    "": "U",
    "": "u",
    "": "u",
    "": "u",
    "": "u",
    "": "Y",
    "": "y",
    "": "y",
    "": "Ae",
    "": "ae",
    "": "Th",
    "": "th",
    "": "ss",
    "": "A",
    "": "A",
    "": "A",
    "": "a",
    "": "a",
    "": "a",
    "": "C",
    "": "C",
    "": "C",
    "": "C",
    "": "c",
    "": "c",
    "": "c",
    "": "c",
    "": "D",
    "": "D",
    "": "d",
    "": "d",
    "": "E",
    "": "E",
    "": "E",
    "": "E",
    "": "E",
    "": "e",
    "": "e",
    "": "e",
    "": "e",
    "": "e",
    "": "G",
    "": "G",
    "": "G",
    "": "G",
    "": "g",
    "": "g",
    "": "g",
    "": "g",
    "": "H",
    "": "H",
    "": "h",
    "": "h",
    "": "I",
    "": "I",
    "": "I",
    "": "I",
    "": "I",
    "": "i",
    "": "i",
    "": "i",
    "": "i",
    "": "i",
    "": "J",
    "": "j",
    "": "K",
    "": "k",
    "": "k",
    "": "L",
    "": "L",
    "": "L",
    "": "L",
    "": "L",
    "": "l",
    "": "l",
    "": "l",
    "": "l",
    "": "l",
    "": "N",
    "": "N",
    "": "N",
    "": "N",
    "": "n",
    "": "n",
    "": "n",
    "": "n",
    "": "O",
    "": "O",
    "": "O",
    "": "o",
    "": "o",
    "": "o",
    "": "R",
    "": "R",
    "": "R",
    "": "r",
    "": "r",
    "": "r",
    "": "S",
    "": "S",
    "": "S",
    "": "S",
    "": "s",
    "": "s",
    "": "s",
    "": "s",
    "": "T",
    "": "T",
    "": "T",
    "": "t",
    "": "t",
    "": "t",
    "": "U",
    "": "U",
    "": "U",
    "": "U",
    "": "U",
    "": "U",
    "": "u",
    "": "u",
    "": "u",
    "": "u",
    "": "u",
    "": "u",
    "": "W",
    "": "w",
    "": "Y",
    "": "y",
    "": "Y",
    "": "Z",
    "": "Z",
    "": "Z",
    "": "z",
    "": "z",
    "": "z",
    "": "IJ",
    "": "ij",
    "": "Oe",
    "": "oe",
    "": "'n",
    "": "s"
  },
      Hr = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  },
      Jr = {
    "&amp;": "&",
    "&lt;": "<",
    "&gt;": ">",
    "&quot;": '"',
    "&#39;": "'"
  },
      Yr = {
    "\\": "\\",
    "'": "'",
    "\n": "n",
    "\r": "r",
    "\u2028": "u2028",
    "\u2029": "u2029"
  },
      Qr = parseFloat,
      Xr = parseInt,
      ne = "object" == (typeof global === "undefined" ? "undefined" : _typeof(global)) && global && global.Object === Object && global,
      te = "object" == (typeof self === "undefined" ? "undefined" : _typeof(self)) && self && self.Object === Object && self,
      re = ne || te || Function("return this")(),
      ee = "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && exports && !exports.nodeType && exports,
      ue = ee && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module && !module.nodeType && module,
      ie = ue && ue.exports === ee,
      oe = ie && ne.process,
      fe = function () {
    try {
      return oe && oe.binding && oe.binding("util");
    } catch (n) {}
  }(),
      ae = fe && fe.isArrayBuffer,
      ce = fe && fe.isDate,
      le = fe && fe.isMap,
      se = fe && fe.isRegExp,
      he = fe && fe.isSet,
      pe = fe && fe.isTypedArray,
      ve = j("length"),
      _e = A(Gr),
      ge = A(Hr),
      ye = A(Jr),
      de = function _(A) {
    function K(n) {
      if (la(n) && !mh(n) && !(n instanceof Dt)) {
        if (n instanceof Y) return n;
        if (ml.call(n, "__wrapped__")) return io(n);
      }

      return new Y(n);
    }

    function J() {}

    function Y(n, t) {
      this.__wrapped__ = n, this.__actions__ = [], this.__chain__ = !!t, this.__index__ = 0, this.__values__ = X;
    }

    function Dt(n) {
      this.__wrapped__ = n, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = Cn, this.__views__ = [];
    }

    function Yt() {
      var n = new Dt(this.__wrapped__);
      return n.__actions__ = Mu(this.__actions__), n.__dir__ = this.__dir__, n.__filtered__ = this.__filtered__, n.__iteratees__ = Mu(this.__iteratees__), n.__takeCount__ = this.__takeCount__, n.__views__ = Mu(this.__views__), n;
    }

    function Qt() {
      if (this.__filtered__) {
        var n = new Dt(this);
        n.__dir__ = -1, n.__filtered__ = !0;
      } else n = this.clone(), n.__dir__ *= -1;

      return n;
    }

    function Xt() {
      var n = this.__wrapped__.value(),
          t = this.__dir__,
          r = mh(n),
          e = t < 0,
          u = r ? n.length : 0,
          i = zi(0, u, this.__views__),
          o = i.start,
          f = i.end,
          a = f - o,
          c = e ? f : o - 1,
          l = this.__iteratees__,
          s = l.length,
          h = 0,
          p = Yl(a, this.__takeCount__);

      if (!r || !e && u == a && p == a) return mu(n, this.__actions__);
      var v = [];

      n: for (; a-- && h < p;) {
        c += t;

        for (var _ = -1, g = n[c]; ++_ < s;) {
          var y = l[_],
              d = y.iteratee,
              b = y.type,
              w = d(g);
          if (b == Rn) g = w;else if (!w) {
            if (b == In) continue n;
            break n;
          }
        }

        v[h++] = g;
      }

      return v;
    }

    function nr(n) {
      var t = -1,
          r = null == n ? 0 : n.length;

      for (this.clear(); ++t < r;) {
        var e = n[t];
        this.set(e[0], e[1]);
      }
    }

    function tr() {
      this.__data__ = fs ? fs(null) : {}, this.size = 0;
    }

    function rr(n) {
      var t = this.has(n) && delete this.__data__[n];
      return this.size -= t ? 1 : 0, t;
    }

    function er(n) {
      var t = this.__data__;

      if (fs) {
        var r = t[n];
        return r === un ? X : r;
      }

      return ml.call(t, n) ? t[n] : X;
    }

    function ur(n) {
      var t = this.__data__;
      return fs ? t[n] !== X : ml.call(t, n);
    }

    function ir(n, t) {
      var r = this.__data__;
      return this.size += this.has(n) ? 0 : 1, r[n] = fs && t === X ? un : t, this;
    }

    function or(n) {
      var t = -1,
          r = null == n ? 0 : n.length;

      for (this.clear(); ++t < r;) {
        var e = n[t];
        this.set(e[0], e[1]);
      }
    }

    function fr() {
      this.__data__ = [], this.size = 0;
    }

    function ar(n) {
      var t = this.__data__,
          r = Lr(t, n);
      if (r < 0) return !1;
      var e = t.length - 1;
      return r == e ? t.pop() : Ul.call(t, r, 1), --this.size, !0;
    }

    function cr(n) {
      var t = this.__data__,
          r = Lr(t, n);
      return r < 0 ? X : t[r][1];
    }

    function lr(n) {
      return Lr(this.__data__, n) > -1;
    }

    function sr(n, t) {
      var r = this.__data__,
          e = Lr(r, n);
      return e < 0 ? (++this.size, r.push([n, t])) : r[e][1] = t, this;
    }

    function hr(n) {
      var t = -1,
          r = null == n ? 0 : n.length;

      for (this.clear(); ++t < r;) {
        var e = n[t];
        this.set(e[0], e[1]);
      }
    }

    function pr() {
      this.size = 0, this.__data__ = {
        hash: new nr(),
        map: new (es || or)(),
        string: new nr()
      };
    }

    function vr(n) {
      var t = ki(this, n).delete(n);
      return this.size -= t ? 1 : 0, t;
    }

    function _r(n) {
      return ki(this, n).get(n);
    }

    function gr(n) {
      return ki(this, n).has(n);
    }

    function yr(n, t) {
      var r = ki(this, n),
          e = r.size;
      return r.set(n, t), this.size += r.size == e ? 0 : 1, this;
    }

    function dr(n) {
      var t = -1,
          r = null == n ? 0 : n.length;

      for (this.__data__ = new hr(); ++t < r;) {
        this.add(n[t]);
      }
    }

    function br(n) {
      return this.__data__.set(n, un), this;
    }

    function wr(n) {
      return this.__data__.has(n);
    }

    function mr(n) {
      var t = this.__data__ = new or(n);
      this.size = t.size;
    }

    function xr() {
      this.__data__ = new or(), this.size = 0;
    }

    function jr(n) {
      var t = this.__data__,
          r = t.delete(n);
      return this.size = t.size, r;
    }

    function Ar(n) {
      return this.__data__.get(n);
    }

    function kr(n) {
      return this.__data__.has(n);
    }

    function Or(n, t) {
      var r = this.__data__;

      if (r instanceof or) {
        var e = r.__data__;
        if (!es || e.length < tn - 1) return e.push([n, t]), this.size = ++r.size, this;
        r = this.__data__ = new hr(e);
      }

      return r.set(n, t), this.size = r.size, this;
    }

    function Ir(n, t) {
      var r = mh(n),
          e = !r && wh(n),
          u = !r && !e && jh(n),
          i = !r && !e && !u && Rh(n),
          o = r || e || u || i,
          f = o ? R(n.length, vl) : [],
          a = f.length;

      for (var c in n) {
        !t && !ml.call(n, c) || o && ("length" == c || u && ("offset" == c || "parent" == c) || i && ("buffer" == c || "byteLength" == c || "byteOffset" == c) || Ti(c, a)) || f.push(c);
      }

      return f;
    }

    function Rr(n) {
      var t = n.length;
      return t ? n[ru(0, t - 1)] : X;
    }

    function zr(n, t) {
      return to(Mu(n), Fr(t, 0, n.length));
    }

    function Er(n) {
      return to(Mu(n));
    }

    function Sr(n, t, r) {
      (r === X || Jf(n[t], r)) && (r !== X || t in n) || Tr(n, t, r);
    }

    function Wr(n, t, r) {
      var e = n[t];
      ml.call(n, t) && Jf(e, r) && (r !== X || t in n) || Tr(n, t, r);
    }

    function Lr(n, t) {
      for (var r = n.length; r--;) {
        if (Jf(n[r][0], t)) return r;
      }

      return -1;
    }

    function Cr(n, t, r, e) {
      return bs(n, function (n, u, i) {
        t(e, n, r(n), i);
      }), e;
    }

    function Ur(n, t) {
      return n && Fu(t, Za(t), n);
    }

    function Br(n, t) {
      return n && Fu(t, Ka(t), n);
    }

    function Tr(n, t, r) {
      "__proto__" == t && Dl ? Dl(n, t, {
        configurable: !0,
        enumerable: !0,
        value: r,
        writable: !0
      }) : n[t] = r;
    }

    function Mr(n, t) {
      for (var r = -1, e = t.length, u = fl(e), i = null == n; ++r < e;) {
        u[r] = i ? X : Na(n, t[r]);
      }

      return u;
    }

    function Fr(n, t, r) {
      return n === n && (r !== X && (n = n <= r ? n : r), t !== X && (n = n >= t ? n : t)), n;
    }

    function Nr(n, t, r, e, i, o) {
      var f,
          a = t & an,
          c = t & cn,
          l = t & ln;
      if (r && (f = i ? r(n, e, i, o) : r(n)), f !== X) return f;
      if (!ca(n)) return n;
      var s = mh(n);

      if (s) {
        if (f = Wi(n), !a) return Mu(n, f);
      } else {
        var h = Ss(n),
            p = h == Zn || h == Kn;
        if (jh(n)) return Ru(n, a);

        if (h == Jn || h == $n || p && !i) {
          if (f = c || p ? {} : Li(n), !a) return c ? Pu(n, Br(f, n)) : Nu(n, Ur(f, n));
        } else {
          if (!Vr[h]) return i ? n : {};
          f = Ci(n, h, Nr, a);
        }
      }

      o || (o = new mr());
      var v = o.get(n);
      if (v) return v;
      o.set(n, f);

      var _ = l ? c ? mi : wi : c ? Ka : Za,
          g = s ? X : _(n);

      return u(g || n, function (e, u) {
        g && (u = e, e = n[u]), Wr(f, u, Nr(e, t, r, u, n, o));
      }), f;
    }

    function Pr(n) {
      var t = Za(n);
      return function (r) {
        return Gr(r, n, t);
      };
    }

    function Gr(n, t, r) {
      var e = r.length;
      if (null == n) return !e;

      for (n = hl(n); e--;) {
        var u = r[e],
            i = t[u],
            o = n[u];
        if (o === X && !(u in n) || !i(o)) return !1;
      }

      return !0;
    }

    function Hr(n, t, r) {
      if ("function" != typeof n) throw new _l(en);
      return Cs(function () {
        n.apply(X, r);
      }, t);
    }

    function Jr(n, t, r, e) {
      var u = -1,
          i = a,
          o = !0,
          f = n.length,
          s = [],
          h = t.length;
      if (!f) return s;
      r && (t = l(t, E(r))), e ? (i = c, o = !1) : t.length >= tn && (i = W, o = !1, t = new dr(t));

      n: for (; ++u < f;) {
        var p = n[u],
            v = null == r ? p : r(p);

        if (p = e || 0 !== p ? p : 0, o && v === v) {
          for (var _ = h; _--;) {
            if (t[_] === v) continue n;
          }

          s.push(p);
        } else i(t, v, e) || s.push(p);
      }

      return s;
    }

    function Yr(n, t) {
      var r = !0;
      return bs(n, function (n, e, u) {
        return r = !!t(n, e, u);
      }), r;
    }

    function ne(n, t, r) {
      for (var e = -1, u = n.length; ++e < u;) {
        var i = n[e],
            o = t(i);
        if (null != o && (f === X ? o === o && !ma(o) : r(o, f))) var f = o,
            a = i;
      }

      return a;
    }

    function te(n, t, r, e) {
      var u = n.length;

      for (r = Ia(r), r < 0 && (r = -r > u ? 0 : u + r), e = e === X || e > u ? u : Ia(e), e < 0 && (e += u), e = r > e ? 0 : Ra(e); r < e;) {
        n[r++] = t;
      }

      return n;
    }

    function ee(n, t) {
      var r = [];
      return bs(n, function (n, e, u) {
        t(n, e, u) && r.push(n);
      }), r;
    }

    function ue(n, t, r, e, u) {
      var i = -1,
          o = n.length;

      for (r || (r = Bi), u || (u = []); ++i < o;) {
        var f = n[i];
        t > 0 && r(f) ? t > 1 ? ue(f, t - 1, r, e, u) : s(u, f) : e || (u[u.length] = f);
      }

      return u;
    }

    function oe(n, t) {
      return n && ms(n, t, Za);
    }

    function fe(n, t) {
      return n && xs(n, t, Za);
    }

    function ve(n, t) {
      return f(t, function (t) {
        return oa(n[t]);
      });
    }

    function de(n, t) {
      t = Ou(t, n);

      for (var r = 0, e = t.length; null != n && r < e;) {
        n = n[ro(t[r++])];
      }

      return r && r == e ? n : X;
    }

    function we(n, t, r) {
      var e = t(n);
      return mh(n) ? e : s(e, r(n));
    }

    function me(n) {
      return null == n ? n === X ? et : Hn : $l && $l in hl(n) ? Ri(n) : Hi(n);
    }

    function xe(n, t) {
      return n > t;
    }

    function je(n, t) {
      return null != n && ml.call(n, t);
    }

    function Ae(n, t) {
      return null != n && t in hl(n);
    }

    function ke(n, t, r) {
      return n >= Yl(t, r) && n < Jl(t, r);
    }

    function Oe(n, t, r) {
      for (var e = r ? c : a, u = n[0].length, i = n.length, o = i, f = fl(i), s = 1 / 0, h = []; o--;) {
        var p = n[o];
        o && t && (p = l(p, E(t))), s = Yl(p.length, s), f[o] = !r && (t || u >= 120 && p.length >= 120) ? new dr(o && p) : X;
      }

      p = n[0];
      var v = -1,
          _ = f[0];

      n: for (; ++v < u && h.length < s;) {
        var g = p[v],
            y = t ? t(g) : g;

        if (g = r || 0 !== g ? g : 0, !(_ ? W(_, y) : e(h, y, r))) {
          for (o = i; --o;) {
            var d = f[o];
            if (!(d ? W(d, y) : e(n[o], y, r))) continue n;
          }

          _ && _.push(y), h.push(g);
        }
      }

      return h;
    }

    function Ie(n, t, r, e) {
      return oe(n, function (n, u, i) {
        t(e, r(n), u, i);
      }), e;
    }

    function Re(n, t, e) {
      t = Ou(t, n), n = Yi(n, t);
      var u = null == n ? n : n[ro(ko(t))];
      return null == u ? X : r(u, n, e);
    }

    function ze(n) {
      return la(n) && me(n) == $n;
    }

    function Ee(n) {
      return la(n) && me(n) == ot;
    }

    function Se(n) {
      return la(n) && me(n) == Nn;
    }

    function We(n, t, r, e, u) {
      return n === t || (null == n || null == t || !la(n) && !la(t) ? n !== n && t !== t : Le(n, t, r, e, We, u));
    }

    function Le(n, t, r, e, u, i) {
      var o = mh(n),
          f = mh(t),
          a = o ? Dn : Ss(n),
          c = f ? Dn : Ss(t);
      a = a == $n ? Jn : a, c = c == $n ? Jn : c;
      var l = a == Jn,
          s = c == Jn,
          h = a == c;

      if (h && jh(n)) {
        if (!jh(t)) return !1;
        o = !0, l = !1;
      }

      if (h && !l) return i || (i = new mr()), o || Rh(n) ? gi(n, t, r, e, u, i) : yi(n, t, a, r, e, u, i);

      if (!(r & sn)) {
        var p = l && ml.call(n, "__wrapped__"),
            v = s && ml.call(t, "__wrapped__");

        if (p || v) {
          var _ = p ? n.value() : n,
              g = v ? t.value() : t;

          return i || (i = new mr()), u(_, g, r, e, i);
        }
      }

      return !!h && (i || (i = new mr()), di(n, t, r, e, u, i));
    }

    function Ce(n) {
      return la(n) && Ss(n) == Vn;
    }

    function Ue(n, t, r, e) {
      var u = r.length,
          i = u,
          o = !e;
      if (null == n) return !i;

      for (n = hl(n); u--;) {
        var f = r[u];
        if (o && f[2] ? f[1] !== n[f[0]] : !(f[0] in n)) return !1;
      }

      for (; ++u < i;) {
        f = r[u];
        var a = f[0],
            c = n[a],
            l = f[1];

        if (o && f[2]) {
          if (c === X && !(a in n)) return !1;
        } else {
          var s = new mr();
          if (e) var h = e(c, l, a, n, t, s);
          if (!(h === X ? We(l, c, sn | hn, e, s) : h)) return !1;
        }
      }

      return !0;
    }

    function Be(n) {
      if (!ca(n) || Ni(n)) return !1;
      var t = oa(n) ? Il : Zt;
      return t.test(eo(n));
    }

    function Te(n) {
      return la(n) && me(n) == Xn;
    }

    function $e(n) {
      return la(n) && Ss(n) == nt;
    }

    function De(n) {
      return la(n) && aa(n.length) && !!Kr[me(n)];
    }

    function Me(n) {
      return "function" == typeof n ? n : null == n ? Uc : "object" == _typeof(n) ? mh(n) ? Ke(n[0], n[1]) : Ze(n) : Pc(n);
    }

    function Fe(n) {
      if (!Pi(n)) return Hl(n);
      var t = [];

      for (var r in hl(n)) {
        ml.call(n, r) && "constructor" != r && t.push(r);
      }

      return t;
    }

    function Ne(n) {
      if (!ca(n)) return Gi(n);
      var t = Pi(n),
          r = [];

      for (var e in n) {
        ("constructor" != e || !t && ml.call(n, e)) && r.push(e);
      }

      return r;
    }

    function Pe(n, t) {
      return n < t;
    }

    function qe(n, t) {
      var r = -1,
          e = Yf(n) ? fl(n.length) : [];
      return bs(n, function (n, u, i) {
        e[++r] = t(n, u, i);
      }), e;
    }

    function Ze(n) {
      var t = Oi(n);
      return 1 == t.length && t[0][2] ? Zi(t[0][0], t[0][1]) : function (r) {
        return r === n || Ue(r, n, t);
      };
    }

    function Ke(n, t) {
      return Di(n) && qi(t) ? Zi(ro(n), t) : function (r) {
        var e = Na(r, n);
        return e === X && e === t ? qa(r, n) : We(t, e, sn | hn);
      };
    }

    function Ve(n, t, r, e, u) {
      n !== t && ms(t, function (i, o) {
        if (ca(i)) u || (u = new mr()), Ge(n, t, o, r, Ve, e, u);else {
          var f = e ? e(n[o], i, o + "", n, t, u) : X;
          f === X && (f = i), Sr(n, o, f);
        }
      }, Ka);
    }

    function Ge(n, t, r, e, u, i, o) {
      var f = n[r],
          a = t[r],
          c = o.get(a);
      if (c) return void Sr(n, r, c);
      var l = i ? i(f, a, r + "", n, t, o) : X,
          s = l === X;

      if (s) {
        var h = mh(a),
            p = !h && jh(a),
            v = !h && !p && Rh(a);
        l = a, h || p || v ? mh(f) ? l = f : Qf(f) ? l = Mu(f) : p ? (s = !1, l = Ru(a, !0)) : v ? (s = !1, l = Uu(a, !0)) : l = [] : da(a) || wh(a) ? (l = f, wh(f) ? l = Ea(f) : (!ca(f) || e && oa(f)) && (l = Li(a))) : s = !1;
      }

      s && (o.set(a, l), u(l, a, e, i, o), o.delete(a)), Sr(n, r, l);
    }

    function He(n, t) {
      var r = n.length;
      if (r) return t += t < 0 ? r : 0, Ti(t, r) ? n[t] : X;
    }

    function Je(n, t, r) {
      var e = -1;
      t = l(t.length ? t : [Uc], E(Ai()));
      var u = qe(n, function (n, r, u) {
        var i = l(t, function (t) {
          return t(n);
        });
        return {
          criteria: i,
          index: ++e,
          value: n
        };
      });
      return O(u, function (n, t) {
        return Tu(n, t, r);
      });
    }

    function Ye(n, t) {
      return Qe(n, t, function (t, r) {
        return qa(n, r);
      });
    }

    function Qe(n, t, r) {
      for (var e = -1, u = t.length, i = {}; ++e < u;) {
        var o = t[e],
            f = de(n, o);
        r(f, o) && au(i, Ou(o, n), f);
      }

      return i;
    }

    function Xe(n) {
      return function (t) {
        return de(t, n);
      };
    }

    function nu(n, t, r, e) {
      var u = e ? w : b,
          i = -1,
          o = t.length,
          f = n;

      for (n === t && (t = Mu(t)), r && (f = l(n, E(r))); ++i < o;) {
        for (var a = 0, c = t[i], s = r ? r(c) : c; (a = u(f, s, a, e)) > -1;) {
          f !== n && Ul.call(f, a, 1), Ul.call(n, a, 1);
        }
      }

      return n;
    }

    function tu(n, t) {
      for (var r = n ? t.length : 0, e = r - 1; r--;) {
        var u = t[r];

        if (r == e || u !== i) {
          var i = u;
          Ti(u) ? Ul.call(n, u, 1) : du(n, u);
        }
      }

      return n;
    }

    function ru(n, t) {
      return n + ql(ns() * (t - n + 1));
    }

    function eu(n, t, r, e) {
      for (var u = -1, i = Jl(Pl((t - n) / (r || 1)), 0), o = fl(i); i--;) {
        o[e ? i : ++u] = n, n += r;
      }

      return o;
    }

    function uu(n, t) {
      var r = "";
      if (!n || t < 1 || t > Sn) return r;

      do {
        t % 2 && (r += n), t = ql(t / 2), t && (n += n);
      } while (t);

      return r;
    }

    function iu(n, t) {
      return Us(Ji(n, t, Uc), n + "");
    }

    function ou(n) {
      return Rr(uc(n));
    }

    function fu(n, t) {
      var r = uc(n);
      return to(r, Fr(t, 0, r.length));
    }

    function au(n, t, r, e) {
      if (!ca(n)) return n;
      t = Ou(t, n);

      for (var u = -1, i = t.length, o = i - 1, f = n; null != f && ++u < i;) {
        var a = ro(t[u]),
            c = r;

        if (u != o) {
          var l = f[a];
          c = e ? e(l, a, f) : X, c === X && (c = ca(l) ? l : Ti(t[u + 1]) ? [] : {});
        }

        Wr(f, a, c), f = f[a];
      }

      return n;
    }

    function cu(n) {
      return to(uc(n));
    }

    function lu(n, t, r) {
      var e = -1,
          u = n.length;
      t < 0 && (t = -t > u ? 0 : u + t), r = r > u ? u : r, r < 0 && (r += u), u = t > r ? 0 : r - t >>> 0, t >>>= 0;

      for (var i = fl(u); ++e < u;) {
        i[e] = n[e + t];
      }

      return i;
    }

    function su(n, t) {
      var r;
      return bs(n, function (n, e, u) {
        return r = t(n, e, u), !r;
      }), !!r;
    }

    function hu(n, t, r) {
      var e = 0,
          u = null == n ? e : n.length;

      if ("number" == typeof t && t === t && u <= Bn) {
        for (; e < u;) {
          var i = e + u >>> 1,
              o = n[i];
          null !== o && !ma(o) && (r ? o <= t : o < t) ? e = i + 1 : u = i;
        }

        return u;
      }

      return pu(n, t, Uc, r);
    }

    function pu(n, t, r, e) {
      t = r(t);

      for (var u = 0, i = null == n ? 0 : n.length, o = t !== t, f = null === t, a = ma(t), c = t === X; u < i;) {
        var l = ql((u + i) / 2),
            s = r(n[l]),
            h = s !== X,
            p = null === s,
            v = s === s,
            _ = ma(s);

        if (o) var g = e || v;else g = c ? v && (e || h) : f ? v && h && (e || !p) : a ? v && h && !p && (e || !_) : !p && !_ && (e ? s <= t : s < t);
        g ? u = l + 1 : i = l;
      }

      return Yl(i, Un);
    }

    function vu(n, t) {
      for (var r = -1, e = n.length, u = 0, i = []; ++r < e;) {
        var o = n[r],
            f = t ? t(o) : o;

        if (!r || !Jf(f, a)) {
          var a = f;
          i[u++] = 0 === o ? 0 : o;
        }
      }

      return i;
    }

    function _u(n) {
      return "number" == typeof n ? n : ma(n) ? Ln : +n;
    }

    function gu(n) {
      if ("string" == typeof n) return n;
      if (mh(n)) return l(n, gu) + "";
      if (ma(n)) return ys ? ys.call(n) : "";
      var t = n + "";
      return "0" == t && 1 / n == -En ? "-0" : t;
    }

    function yu(n, t, r) {
      var e = -1,
          u = a,
          i = n.length,
          o = !0,
          f = [],
          l = f;
      if (r) o = !1, u = c;else if (i >= tn) {
        var s = t ? null : Is(n);
        if (s) return q(s);
        o = !1, u = W, l = new dr();
      } else l = t ? [] : f;

      n: for (; ++e < i;) {
        var h = n[e],
            p = t ? t(h) : h;

        if (h = r || 0 !== h ? h : 0, o && p === p) {
          for (var v = l.length; v--;) {
            if (l[v] === p) continue n;
          }

          t && l.push(p), f.push(h);
        } else u(l, p, r) || (l !== f && l.push(p), f.push(h));
      }

      return f;
    }

    function du(n, t) {
      return t = Ou(t, n), n = Yi(n, t), null == n || delete n[ro(ko(t))];
    }

    function bu(n, t, r, e) {
      return au(n, t, r(de(n, t)), e);
    }

    function wu(n, t, r, e) {
      for (var u = n.length, i = e ? u : -1; (e ? i-- : ++i < u) && t(n[i], i, n);) {
        ;
      }

      return r ? lu(n, e ? 0 : i, e ? i + 1 : u) : lu(n, e ? i + 1 : 0, e ? u : i);
    }

    function mu(n, t) {
      var r = n;
      return r instanceof Dt && (r = r.value()), h(t, function (n, t) {
        return t.func.apply(t.thisArg, s([n], t.args));
      }, r);
    }

    function xu(n, t, r) {
      var e = n.length;
      if (e < 2) return e ? yu(n[0]) : [];

      for (var u = -1, i = fl(e); ++u < e;) {
        for (var o = n[u], f = -1; ++f < e;) {
          f != u && (i[u] = Jr(i[u] || o, n[f], t, r));
        }
      }

      return yu(ue(i, 1), t, r);
    }

    function ju(n, t, r) {
      for (var e = -1, u = n.length, i = t.length, o = {}; ++e < u;) {
        var f = e < i ? t[e] : X;
        r(o, n[e], f);
      }

      return o;
    }

    function Au(n) {
      return Qf(n) ? n : [];
    }

    function ku(n) {
      return "function" == typeof n ? n : Uc;
    }

    function Ou(n, t) {
      return mh(n) ? n : Di(n, t) ? [n] : Bs(Wa(n));
    }

    function Iu(n, t, r) {
      var e = n.length;
      return r = r === X ? e : r, !t && r >= e ? n : lu(n, t, r);
    }

    function Ru(n, t) {
      if (t) return n.slice();
      var r = n.length,
          e = Sl ? Sl(r) : new n.constructor(r);
      return n.copy(e), e;
    }

    function zu(n) {
      var t = new n.constructor(n.byteLength);
      return new El(t).set(new El(n)), t;
    }

    function Eu(n, t) {
      var r = t ? zu(n.buffer) : n.buffer;
      return new n.constructor(r, n.byteOffset, n.byteLength);
    }

    function Su(t, r, e) {
      var u = r ? e(F(t), an) : F(t);
      return h(u, n, new t.constructor());
    }

    function Wu(n) {
      var t = new n.constructor(n.source, Nt.exec(n));
      return t.lastIndex = n.lastIndex, t;
    }

    function Lu(n, r, e) {
      var u = r ? e(q(n), an) : q(n);
      return h(u, t, new n.constructor());
    }

    function Cu(n) {
      return gs ? hl(gs.call(n)) : {};
    }

    function Uu(n, t) {
      var r = t ? zu(n.buffer) : n.buffer;
      return new n.constructor(r, n.byteOffset, n.length);
    }

    function Bu(n, t) {
      if (n !== t) {
        var r = n !== X,
            e = null === n,
            u = n === n,
            i = ma(n),
            o = t !== X,
            f = null === t,
            a = t === t,
            c = ma(t);
        if (!f && !c && !i && n > t || i && o && a && !f && !c || e && o && a || !r && a || !u) return 1;
        if (!e && !i && !c && n < t || c && r && u && !e && !i || f && r && u || !o && u || !a) return -1;
      }

      return 0;
    }

    function Tu(n, t, r) {
      for (var e = -1, u = n.criteria, i = t.criteria, o = u.length, f = r.length; ++e < o;) {
        var a = Bu(u[e], i[e]);

        if (a) {
          if (e >= f) return a;
          var c = r[e];
          return a * ("desc" == c ? -1 : 1);
        }
      }

      return n.index - t.index;
    }

    function $u(n, t, r, e) {
      for (var u = -1, i = n.length, o = r.length, f = -1, a = t.length, c = Jl(i - o, 0), l = fl(a + c), s = !e; ++f < a;) {
        l[f] = t[f];
      }

      for (; ++u < o;) {
        (s || u < i) && (l[r[u]] = n[u]);
      }

      for (; c--;) {
        l[f++] = n[u++];
      }

      return l;
    }

    function Du(n, t, r, e) {
      for (var u = -1, i = n.length, o = -1, f = r.length, a = -1, c = t.length, l = Jl(i - f, 0), s = fl(l + c), h = !e; ++u < l;) {
        s[u] = n[u];
      }

      for (var p = u; ++a < c;) {
        s[p + a] = t[a];
      }

      for (; ++o < f;) {
        (h || u < i) && (s[p + r[o]] = n[u++]);
      }

      return s;
    }

    function Mu(n, t) {
      var r = -1,
          e = n.length;

      for (t || (t = fl(e)); ++r < e;) {
        t[r] = n[r];
      }

      return t;
    }

    function Fu(n, t, r, e) {
      var u = !r;
      r || (r = {});

      for (var i = -1, o = t.length; ++i < o;) {
        var f = t[i],
            a = e ? e(r[f], n[f], f, r, n) : X;
        a === X && (a = n[f]), u ? Tr(r, f, a) : Wr(r, f, a);
      }

      return r;
    }

    function Nu(n, t) {
      return Fu(n, zs(n), t);
    }

    function Pu(n, t) {
      return Fu(n, Es(n), t);
    }

    function qu(n, t) {
      return function (r, u) {
        var i = mh(r) ? e : Cr,
            o = t ? t() : {};
        return i(r, n, Ai(u, 2), o);
      };
    }

    function Zu(n) {
      return iu(function (t, r) {
        var e = -1,
            u = r.length,
            i = u > 1 ? r[u - 1] : X,
            o = u > 2 ? r[2] : X;

        for (i = n.length > 3 && "function" == typeof i ? (u--, i) : X, o && $i(r[0], r[1], o) && (i = u < 3 ? X : i, u = 1), t = hl(t); ++e < u;) {
          var f = r[e];
          f && n(t, f, e, i);
        }

        return t;
      });
    }

    function Ku(n, t) {
      return function (r, e) {
        if (null == r) return r;
        if (!Yf(r)) return n(r, e);

        for (var u = r.length, i = t ? u : -1, o = hl(r); (t ? i-- : ++i < u) && e(o[i], i, o) !== !1;) {
          ;
        }

        return r;
      };
    }

    function Vu(n) {
      return function (t, r, e) {
        for (var u = -1, i = hl(t), o = e(t), f = o.length; f--;) {
          var a = o[n ? f : ++u];
          if (r(i[a], a, i) === !1) break;
        }

        return t;
      };
    }

    function Gu(n, t, r) {
      function e() {
        var t = this && this !== re && this instanceof e ? i : n;
        return t.apply(u ? r : this, arguments);
      }

      var u = t & pn,
          i = Yu(n);
      return e;
    }

    function Hu(n) {
      return function (t) {
        t = Wa(t);
        var r = $(t) ? H(t) : X,
            e = r ? r[0] : t.charAt(0),
            u = r ? Iu(r, 1).join("") : t.slice(1);
        return e[n]() + u;
      };
    }

    function Ju(n) {
      return function (t) {
        return h(Ec(lc(t).replace($r, "")), n, "");
      };
    }

    function Yu(n) {
      return function () {
        var t = arguments;

        switch (t.length) {
          case 0:
            return new n();

          case 1:
            return new n(t[0]);

          case 2:
            return new n(t[0], t[1]);

          case 3:
            return new n(t[0], t[1], t[2]);

          case 4:
            return new n(t[0], t[1], t[2], t[3]);

          case 5:
            return new n(t[0], t[1], t[2], t[3], t[4]);

          case 6:
            return new n(t[0], t[1], t[2], t[3], t[4], t[5]);

          case 7:
            return new n(t[0], t[1], t[2], t[3], t[4], t[5], t[6]);
        }

        var r = ds(n.prototype),
            e = n.apply(r, t);
        return ca(e) ? e : r;
      };
    }

    function Qu(n, t, e) {
      function u() {
        for (var o = arguments.length, f = fl(o), a = o, c = ji(u); a--;) {
          f[a] = arguments[a];
        }

        var l = o < 3 && f[0] !== c && f[o - 1] !== c ? [] : P(f, c);
        if (o -= l.length, o < e) return ci(n, t, ti, u.placeholder, X, f, l, X, X, e - o);
        var s = this && this !== re && this instanceof u ? i : n;
        return r(s, this, f);
      }

      var i = Yu(n);
      return u;
    }

    function Xu(n) {
      return function (t, r, e) {
        var u = hl(t);

        if (!Yf(t)) {
          var i = Ai(r, 3);
          t = Za(t), r = function r(n) {
            return i(u[n], n, u);
          };
        }

        var o = n(t, r, e);
        return o > -1 ? u[i ? t[o] : o] : X;
      };
    }

    function ni(n) {
      return bi(function (t) {
        var r = t.length,
            e = r,
            u = Y.prototype.thru;

        for (n && t.reverse(); e--;) {
          var i = t[e];
          if ("function" != typeof i) throw new _l(en);
          if (u && !o && "wrapper" == xi(i)) var o = new Y([], !0);
        }

        for (e = o ? e : r; ++e < r;) {
          i = t[e];
          var f = xi(i),
              a = "wrapper" == f ? Rs(i) : X;
          o = a && Fi(a[0]) && a[1] == (wn | gn | dn | mn) && !a[4].length && 1 == a[9] ? o[xi(a[0])].apply(o, a[3]) : 1 == i.length && Fi(i) ? o[f]() : o.thru(i);
        }

        return function () {
          var n = arguments,
              e = n[0];
          if (o && 1 == n.length && mh(e)) return o.plant(e).value();

          for (var u = 0, i = r ? t[u].apply(this, n) : e; ++u < r;) {
            i = t[u].call(this, i);
          }

          return i;
        };
      });
    }

    function ti(n, t, r, e, u, i, o, f, a, c) {
      function l() {
        for (var y = arguments.length, d = fl(y), b = y; b--;) {
          d[b] = arguments[b];
        }

        if (v) var w = ji(l),
            m = U(d, w);

        if (e && (d = $u(d, e, u, v)), i && (d = Du(d, i, o, v)), y -= m, v && y < c) {
          var x = P(d, w);
          return ci(n, t, ti, l.placeholder, r, d, x, f, a, c - y);
        }

        var j = h ? r : this,
            A = p ? j[n] : n;
        return y = d.length, f ? d = Qi(d, f) : _ && y > 1 && d.reverse(), s && a < y && (d.length = a), this && this !== re && this instanceof l && (A = g || Yu(A)), A.apply(j, d);
      }

      var s = t & wn,
          h = t & pn,
          p = t & vn,
          v = t & (gn | yn),
          _ = t & xn,
          g = p ? X : Yu(n);

      return l;
    }

    function ri(n, t) {
      return function (r, e) {
        return Ie(r, n, t(e), {});
      };
    }

    function ei(n, t) {
      return function (r, e) {
        var u;
        if (r === X && e === X) return t;

        if (r !== X && (u = r), e !== X) {
          if (u === X) return e;
          "string" == typeof r || "string" == typeof e ? (r = gu(r), e = gu(e)) : (r = _u(r), e = _u(e)), u = n(r, e);
        }

        return u;
      };
    }

    function ui(n) {
      return bi(function (t) {
        return t = l(t, E(Ai())), iu(function (e) {
          var u = this;
          return n(t, function (n) {
            return r(n, u, e);
          });
        });
      });
    }

    function ii(n, t) {
      t = t === X ? " " : gu(t);
      var r = t.length;
      if (r < 2) return r ? uu(t, n) : t;
      var e = uu(t, Pl(n / G(t)));
      return $(t) ? Iu(H(e), 0, n).join("") : e.slice(0, n);
    }

    function oi(n, t, e, u) {
      function i() {
        for (var t = -1, a = arguments.length, c = -1, l = u.length, s = fl(l + a), h = this && this !== re && this instanceof i ? f : n; ++c < l;) {
          s[c] = u[c];
        }

        for (; a--;) {
          s[c++] = arguments[++t];
        }

        return r(h, o ? e : this, s);
      }

      var o = t & pn,
          f = Yu(n);
      return i;
    }

    function fi(n) {
      return function (t, r, e) {
        return e && "number" != typeof e && $i(t, r, e) && (r = e = X), t = Oa(t), r === X ? (r = t, t = 0) : r = Oa(r), e = e === X ? t < r ? 1 : -1 : Oa(e), eu(t, r, e, n);
      };
    }

    function ai(n) {
      return function (t, r) {
        return "string" == typeof t && "string" == typeof r || (t = za(t), r = za(r)), n(t, r);
      };
    }

    function ci(n, t, r, e, u, i, o, f, a, c) {
      var l = t & gn,
          s = l ? o : X,
          h = l ? X : o,
          p = l ? i : X,
          v = l ? X : i;
      t |= l ? dn : bn, t &= ~(l ? bn : dn), t & _n || (t &= ~(pn | vn));
      var _ = [n, t, u, p, s, v, h, f, a, c],
          g = r.apply(X, _);
      return Fi(n) && Ls(g, _), g.placeholder = e, Xi(g, n, t);
    }

    function li(n) {
      var t = sl[n];
      return function (n, r) {
        if (n = za(n), r = null == r ? 0 : Yl(Ia(r), 292)) {
          var e = (Wa(n) + "e").split("e"),
              u = t(e[0] + "e" + (+e[1] + r));
          return e = (Wa(u) + "e").split("e"), +(e[0] + "e" + (+e[1] - r));
        }

        return t(n);
      };
    }

    function si(n) {
      return function (t) {
        var r = Ss(t);
        return r == Vn ? F(t) : r == nt ? Z(t) : z(t, n(t));
      };
    }

    function hi(n, t, r, e, u, i, o, f) {
      var a = t & vn;
      if (!a && "function" != typeof n) throw new _l(en);
      var c = e ? e.length : 0;

      if (c || (t &= ~(dn | bn), e = u = X), o = o === X ? o : Jl(Ia(o), 0), f = f === X ? f : Ia(f), c -= u ? u.length : 0, t & bn) {
        var l = e,
            s = u;
        e = u = X;
      }

      var h = a ? X : Rs(n),
          p = [n, t, r, e, u, l, s, i, o, f];
      if (h && Vi(p, h), n = p[0], t = p[1], r = p[2], e = p[3], u = p[4], f = p[9] = p[9] === X ? a ? 0 : n.length : Jl(p[9] - c, 0), !f && t & (gn | yn) && (t &= ~(gn | yn)), t && t != pn) v = t == gn || t == yn ? Qu(n, t, f) : t != dn && t != (pn | dn) || u.length ? ti.apply(X, p) : oi(n, t, r, e);else var v = Gu(n, t, r);

      var _ = h ? js : Ls;

      return Xi(_(v, p), n, t);
    }

    function pi(n, t, r, e) {
      return n === X || Jf(n, dl[r]) && !ml.call(e, r) ? t : n;
    }

    function vi(n, t, r, e, u, i) {
      return ca(n) && ca(t) && (i.set(t, n), Ve(n, t, X, vi, i), i.delete(t)), n;
    }

    function _i(n) {
      return da(n) ? X : n;
    }

    function gi(n, t, r, e, u, i) {
      var o = r & sn,
          f = n.length,
          a = t.length;
      if (f != a && !(o && a > f)) return !1;
      var c = i.get(n);
      if (c && i.get(t)) return c == t;
      var l = -1,
          s = !0,
          h = r & hn ? new dr() : X;

      for (i.set(n, t), i.set(t, n); ++l < f;) {
        var p = n[l],
            _ = t[l];
        if (e) var g = o ? e(_, p, l, t, n, i) : e(p, _, l, n, t, i);

        if (g !== X) {
          if (g) continue;
          s = !1;
          break;
        }

        if (h) {
          if (!v(t, function (n, t) {
            if (!W(h, t) && (p === n || u(p, n, r, e, i))) return h.push(t);
          })) {
            s = !1;
            break;
          }
        } else if (p !== _ && !u(p, _, r, e, i)) {
          s = !1;
          break;
        }
      }

      return i.delete(n), i.delete(t), s;
    }

    function yi(n, t, r, e, u, i, o) {
      switch (r) {
        case ft:
          if (n.byteLength != t.byteLength || n.byteOffset != t.byteOffset) return !1;
          n = n.buffer, t = t.buffer;

        case ot:
          return !(n.byteLength != t.byteLength || !i(new El(n), new El(t)));

        case Fn:
        case Nn:
        case Gn:
          return Jf(+n, +t);

        case qn:
          return n.name == t.name && n.message == t.message;

        case Xn:
        case tt:
          return n == t + "";

        case Vn:
          var f = F;

        case nt:
          var a = e & sn;
          if (f || (f = q), n.size != t.size && !a) return !1;
          var c = o.get(n);
          if (c) return c == t;
          e |= hn, o.set(n, t);
          var l = gi(f(n), f(t), e, u, i, o);
          return o.delete(n), l;

        case rt:
          if (gs) return gs.call(n) == gs.call(t);
      }

      return !1;
    }

    function di(n, t, r, e, u, i) {
      var o = r & sn,
          f = wi(n),
          a = f.length,
          c = wi(t),
          l = c.length;
      if (a != l && !o) return !1;

      for (var s = a; s--;) {
        var h = f[s];
        if (!(o ? h in t : ml.call(t, h))) return !1;
      }

      var p = i.get(n);
      if (p && i.get(t)) return p == t;
      var v = !0;
      i.set(n, t), i.set(t, n);

      for (var _ = o; ++s < a;) {
        h = f[s];
        var g = n[h],
            y = t[h];
        if (e) var d = o ? e(y, g, h, t, n, i) : e(g, y, h, n, t, i);

        if (!(d === X ? g === y || u(g, y, r, e, i) : d)) {
          v = !1;
          break;
        }

        _ || (_ = "constructor" == h);
      }

      if (v && !_) {
        var b = n.constructor,
            w = t.constructor;
        b != w && "constructor" in n && "constructor" in t && !("function" == typeof b && b instanceof b && "function" == typeof w && w instanceof w) && (v = !1);
      }

      return i.delete(n), i.delete(t), v;
    }

    function bi(n) {
      return Us(Ji(n, X, go), n + "");
    }

    function wi(n) {
      return we(n, Za, zs);
    }

    function mi(n) {
      return we(n, Ka, Es);
    }

    function xi(n) {
      for (var t = n.name + "", r = cs[t], e = ml.call(cs, t) ? r.length : 0; e--;) {
        var u = r[e],
            i = u.func;
        if (null == i || i == n) return u.name;
      }

      return t;
    }

    function ji(n) {
      var t = ml.call(K, "placeholder") ? K : n;
      return t.placeholder;
    }

    function Ai() {
      var n = K.iteratee || Bc;
      return n = n === Bc ? Me : n, arguments.length ? n(arguments[0], arguments[1]) : n;
    }

    function ki(n, t) {
      var r = n.__data__;
      return Mi(t) ? r["string" == typeof t ? "string" : "hash"] : r.map;
    }

    function Oi(n) {
      for (var t = Za(n), r = t.length; r--;) {
        var e = t[r],
            u = n[e];
        t[r] = [e, u, qi(u)];
      }

      return t;
    }

    function Ii(n, t) {
      var r = T(n, t);
      return Be(r) ? r : X;
    }

    function Ri(n) {
      var t = ml.call(n, $l),
          r = n[$l];

      try {
        n[$l] = X;
        var e = !0;
      } catch (n) {}

      var u = Al.call(n);
      return e && (t ? n[$l] = r : delete n[$l]), u;
    }

    function zi(n, t, r) {
      for (var e = -1, u = r.length; ++e < u;) {
        var i = r[e],
            o = i.size;

        switch (i.type) {
          case "drop":
            n += o;
            break;

          case "dropRight":
            t -= o;
            break;

          case "take":
            t = Yl(t, n + o);
            break;

          case "takeRight":
            n = Jl(n, t - o);
        }
      }

      return {
        start: n,
        end: t
      };
    }

    function Ei(n) {
      var t = n.match(Tt);
      return t ? t[1].split($t) : [];
    }

    function Si(n, t, r) {
      t = Ou(t, n);

      for (var e = -1, u = t.length, i = !1; ++e < u;) {
        var o = ro(t[e]);
        if (!(i = null != n && r(n, o))) break;
        n = n[o];
      }

      return i || ++e != u ? i : (u = null == n ? 0 : n.length, !!u && aa(u) && Ti(o, u) && (mh(n) || wh(n)));
    }

    function Wi(n) {
      var t = n.length,
          r = n.constructor(t);
      return t && "string" == typeof n[0] && ml.call(n, "index") && (r.index = n.index, r.input = n.input), r;
    }

    function Li(n) {
      return "function" != typeof n.constructor || Pi(n) ? {} : ds(Wl(n));
    }

    function Ci(n, t, r, e) {
      var u = n.constructor;

      switch (t) {
        case ot:
          return zu(n);

        case Fn:
        case Nn:
          return new u(+n);

        case ft:
          return Eu(n, e);

        case at:
        case ct:
        case lt:
        case st:
        case ht:
        case pt:
        case vt:
        case _t:
        case gt:
          return Uu(n, e);

        case Vn:
          return Su(n, e, r);

        case Gn:
        case tt:
          return new u(n);

        case Xn:
          return Wu(n);

        case nt:
          return Lu(n, e, r);

        case rt:
          return Cu(n);
      }
    }

    function Ui(n, t) {
      var r = t.length;
      if (!r) return n;
      var e = r - 1;
      return t[e] = (r > 1 ? "& " : "") + t[e], t = t.join(r > 2 ? ", " : " "), n.replace(Bt, "{\n/* [wrapped with " + t + "] */\n");
    }

    function Bi(n) {
      return mh(n) || wh(n) || !!(Bl && n && n[Bl]);
    }

    function Ti(n, t) {
      return t = null == t ? Sn : t, !!t && ("number" == typeof n || Vt.test(n)) && n > -1 && n % 1 == 0 && n < t;
    }

    function $i(n, t, r) {
      if (!ca(r)) return !1;

      var e = _typeof(t);

      return !!("number" == e ? Yf(r) && Ti(t, r.length) : "string" == e && t in r) && Jf(r[t], n);
    }

    function Di(n, t) {
      if (mh(n)) return !1;

      var r = _typeof(n);

      return !("number" != r && "symbol" != r && "boolean" != r && null != n && !ma(n)) || Rt.test(n) || !It.test(n) || null != t && n in hl(t);
    }

    function Mi(n) {
      var t = _typeof(n);

      return "string" == t || "number" == t || "symbol" == t || "boolean" == t ? "__proto__" !== n : null === n;
    }

    function Fi(n) {
      var t = xi(n),
          r = K[t];
      if ("function" != typeof r || !(t in Dt.prototype)) return !1;
      if (n === r) return !0;
      var e = Rs(r);
      return !!e && n === e[0];
    }

    function Ni(n) {
      return !!jl && jl in n;
    }

    function Pi(n) {
      var t = n && n.constructor,
          r = "function" == typeof t && t.prototype || dl;
      return n === r;
    }

    function qi(n) {
      return n === n && !ca(n);
    }

    function Zi(n, t) {
      return function (r) {
        return null != r && r[n] === t && (t !== X || n in hl(r));
      };
    }

    function Ki(n) {
      var t = Bf(n, function (n) {
        return r.size === on && r.clear(), n;
      }),
          r = t.cache;
      return t;
    }

    function Vi(n, t) {
      var r = n[1],
          e = t[1],
          u = r | e,
          i = u < (pn | vn | wn),
          o = e == wn && r == gn || e == wn && r == mn && n[7].length <= t[8] || e == (wn | mn) && t[7].length <= t[8] && r == gn;
      if (!i && !o) return n;
      e & pn && (n[2] = t[2], u |= r & pn ? 0 : _n);
      var f = t[3];

      if (f) {
        var a = n[3];
        n[3] = a ? $u(a, f, t[4]) : f, n[4] = a ? P(n[3], fn) : t[4];
      }

      return f = t[5], f && (a = n[5], n[5] = a ? Du(a, f, t[6]) : f, n[6] = a ? P(n[5], fn) : t[6]), f = t[7], f && (n[7] = f), e & wn && (n[8] = null == n[8] ? t[8] : Yl(n[8], t[8])), null == n[9] && (n[9] = t[9]), n[0] = t[0], n[1] = u, n;
    }

    function Gi(n) {
      var t = [];
      if (null != n) for (var r in hl(n)) {
        t.push(r);
      }
      return t;
    }

    function Hi(n) {
      return Al.call(n);
    }

    function Ji(n, t, e) {
      return t = Jl(t === X ? n.length - 1 : t, 0), function () {
        for (var u = arguments, i = -1, o = Jl(u.length - t, 0), f = fl(o); ++i < o;) {
          f[i] = u[t + i];
        }

        i = -1;

        for (var a = fl(t + 1); ++i < t;) {
          a[i] = u[i];
        }

        return a[t] = e(f), r(n, this, a);
      };
    }

    function Yi(n, t) {
      return t.length < 2 ? n : de(n, lu(t, 0, -1));
    }

    function Qi(n, t) {
      for (var r = n.length, e = Yl(t.length, r), u = Mu(n); e--;) {
        var i = t[e];
        n[e] = Ti(i, r) ? u[i] : X;
      }

      return n;
    }

    function Xi(n, t, r) {
      var e = t + "";
      return Us(n, Ui(e, uo(Ei(e), r)));
    }

    function no(n) {
      var t = 0,
          r = 0;
      return function () {
        var e = Ql(),
            u = On - (e - r);

        if (r = e, u > 0) {
          if (++t >= kn) return arguments[0];
        } else t = 0;

        return n.apply(X, arguments);
      };
    }

    function to(n, t) {
      var r = -1,
          e = n.length,
          u = e - 1;

      for (t = t === X ? e : t; ++r < t;) {
        var i = ru(r, u),
            o = n[i];
        n[i] = n[r], n[r] = o;
      }

      return n.length = t, n;
    }

    function ro(n) {
      if ("string" == typeof n || ma(n)) return n;
      var t = n + "";
      return "0" == t && 1 / n == -En ? "-0" : t;
    }

    function eo(n) {
      if (null != n) {
        try {
          return wl.call(n);
        } catch (n) {}

        try {
          return n + "";
        } catch (n) {}
      }

      return "";
    }

    function uo(n, t) {
      return u(Tn, function (r) {
        var e = "_." + r[0];
        t & r[1] && !a(n, e) && n.push(e);
      }), n.sort();
    }

    function io(n) {
      if (n instanceof Dt) return n.clone();
      var t = new Y(n.__wrapped__, n.__chain__);
      return t.__actions__ = Mu(n.__actions__), t.__index__ = n.__index__, t.__values__ = n.__values__, t;
    }

    function oo(n, t, r) {
      t = (r ? $i(n, t, r) : t === X) ? 1 : Jl(Ia(t), 0);
      var e = null == n ? 0 : n.length;
      if (!e || t < 1) return [];

      for (var u = 0, i = 0, o = fl(Pl(e / t)); u < e;) {
        o[i++] = lu(n, u, u += t);
      }

      return o;
    }

    function fo(n) {
      for (var t = -1, r = null == n ? 0 : n.length, e = 0, u = []; ++t < r;) {
        var i = n[t];
        i && (u[e++] = i);
      }

      return u;
    }

    function ao() {
      var n = arguments.length;
      if (!n) return [];

      for (var t = fl(n - 1), r = arguments[0], e = n; e--;) {
        t[e - 1] = arguments[e];
      }

      return s(mh(r) ? Mu(r) : [r], ue(t, 1));
    }

    function co(n, t, r) {
      var e = null == n ? 0 : n.length;
      return e ? (t = r || t === X ? 1 : Ia(t), lu(n, t < 0 ? 0 : t, e)) : [];
    }

    function lo(n, t, r) {
      var e = null == n ? 0 : n.length;
      return e ? (t = r || t === X ? 1 : Ia(t), t = e - t, lu(n, 0, t < 0 ? 0 : t)) : [];
    }

    function so(n, t) {
      return n && n.length ? wu(n, Ai(t, 3), !0, !0) : [];
    }

    function ho(n, t) {
      return n && n.length ? wu(n, Ai(t, 3), !0) : [];
    }

    function po(n, t, r, e) {
      var u = null == n ? 0 : n.length;
      return u ? (r && "number" != typeof r && $i(n, t, r) && (r = 0, e = u), te(n, t, r, e)) : [];
    }

    function vo(n, t, r) {
      var e = null == n ? 0 : n.length;
      if (!e) return -1;
      var u = null == r ? 0 : Ia(r);
      return u < 0 && (u = Jl(e + u, 0)), d(n, Ai(t, 3), u);
    }

    function _o(n, t, r) {
      var e = null == n ? 0 : n.length;
      if (!e) return -1;
      var u = e - 1;
      return r !== X && (u = Ia(r), u = r < 0 ? Jl(e + u, 0) : Yl(u, e - 1)), d(n, Ai(t, 3), u, !0);
    }

    function go(n) {
      var t = null == n ? 0 : n.length;
      return t ? ue(n, 1) : [];
    }

    function yo(n) {
      var t = null == n ? 0 : n.length;
      return t ? ue(n, En) : [];
    }

    function bo(n, t) {
      var r = null == n ? 0 : n.length;
      return r ? (t = t === X ? 1 : Ia(t), ue(n, t)) : [];
    }

    function wo(n) {
      for (var t = -1, r = null == n ? 0 : n.length, e = {}; ++t < r;) {
        var u = n[t];
        e[u[0]] = u[1];
      }

      return e;
    }

    function mo(n) {
      return n && n.length ? n[0] : X;
    }

    function xo(n, t, r) {
      var e = null == n ? 0 : n.length;
      if (!e) return -1;
      var u = null == r ? 0 : Ia(r);
      return u < 0 && (u = Jl(e + u, 0)), b(n, t, u);
    }

    function jo(n) {
      var t = null == n ? 0 : n.length;
      return t ? lu(n, 0, -1) : [];
    }

    function Ao(n, t) {
      return null == n ? "" : Gl.call(n, t);
    }

    function ko(n) {
      var t = null == n ? 0 : n.length;
      return t ? n[t - 1] : X;
    }

    function Oo(n, t, r) {
      var e = null == n ? 0 : n.length;
      if (!e) return -1;
      var u = e;
      return r !== X && (u = Ia(r), u = u < 0 ? Jl(e + u, 0) : Yl(u, e - 1)), t === t ? V(n, t, u) : d(n, m, u, !0);
    }

    function Io(n, t) {
      return n && n.length ? He(n, Ia(t)) : X;
    }

    function Ro(n, t) {
      return n && n.length && t && t.length ? nu(n, t) : n;
    }

    function zo(n, t, r) {
      return n && n.length && t && t.length ? nu(n, t, Ai(r, 2)) : n;
    }

    function Eo(n, t, r) {
      return n && n.length && t && t.length ? nu(n, t, X, r) : n;
    }

    function So(n, t) {
      var r = [];
      if (!n || !n.length) return r;
      var e = -1,
          u = [],
          i = n.length;

      for (t = Ai(t, 3); ++e < i;) {
        var o = n[e];
        t(o, e, n) && (r.push(o), u.push(e));
      }

      return tu(n, u), r;
    }

    function Wo(n) {
      return null == n ? n : ts.call(n);
    }

    function Lo(n, t, r) {
      var e = null == n ? 0 : n.length;
      return e ? (r && "number" != typeof r && $i(n, t, r) ? (t = 0, r = e) : (t = null == t ? 0 : Ia(t), r = r === X ? e : Ia(r)), lu(n, t, r)) : [];
    }

    function Co(n, t) {
      return hu(n, t);
    }

    function Uo(n, t, r) {
      return pu(n, t, Ai(r, 2));
    }

    function Bo(n, t) {
      var r = null == n ? 0 : n.length;

      if (r) {
        var e = hu(n, t);
        if (e < r && Jf(n[e], t)) return e;
      }

      return -1;
    }

    function To(n, t) {
      return hu(n, t, !0);
    }

    function $o(n, t, r) {
      return pu(n, t, Ai(r, 2), !0);
    }

    function Do(n, t) {
      var r = null == n ? 0 : n.length;

      if (r) {
        var e = hu(n, t, !0) - 1;
        if (Jf(n[e], t)) return e;
      }

      return -1;
    }

    function Mo(n) {
      return n && n.length ? vu(n) : [];
    }

    function Fo(n, t) {
      return n && n.length ? vu(n, Ai(t, 2)) : [];
    }

    function No(n) {
      var t = null == n ? 0 : n.length;
      return t ? lu(n, 1, t) : [];
    }

    function Po(n, t, r) {
      return n && n.length ? (t = r || t === X ? 1 : Ia(t), lu(n, 0, t < 0 ? 0 : t)) : [];
    }

    function qo(n, t, r) {
      var e = null == n ? 0 : n.length;
      return e ? (t = r || t === X ? 1 : Ia(t), t = e - t, lu(n, t < 0 ? 0 : t, e)) : [];
    }

    function Zo(n, t) {
      return n && n.length ? wu(n, Ai(t, 3), !1, !0) : [];
    }

    function Ko(n, t) {
      return n && n.length ? wu(n, Ai(t, 3)) : [];
    }

    function Vo(n) {
      return n && n.length ? yu(n) : [];
    }

    function Go(n, t) {
      return n && n.length ? yu(n, Ai(t, 2)) : [];
    }

    function Ho(n, t) {
      return t = "function" == typeof t ? t : X, n && n.length ? yu(n, X, t) : [];
    }

    function Jo(n) {
      if (!n || !n.length) return [];
      var t = 0;
      return n = f(n, function (n) {
        if (Qf(n)) return t = Jl(n.length, t), !0;
      }), R(t, function (t) {
        return l(n, j(t));
      });
    }

    function Yo(n, t) {
      if (!n || !n.length) return [];
      var e = Jo(n);
      return null == t ? e : l(e, function (n) {
        return r(t, X, n);
      });
    }

    function Qo(n, t) {
      return ju(n || [], t || [], Wr);
    }

    function Xo(n, t) {
      return ju(n || [], t || [], au);
    }

    function nf(n) {
      var t = K(n);
      return t.__chain__ = !0, t;
    }

    function tf(n, t) {
      return t(n), n;
    }

    function rf(n, t) {
      return t(n);
    }

    function ef() {
      return nf(this);
    }

    function uf() {
      return new Y(this.value(), this.__chain__);
    }

    function of() {
      this.__values__ === X && (this.__values__ = ka(this.value()));
      var n = this.__index__ >= this.__values__.length,
          t = n ? X : this.__values__[this.__index__++];
      return {
        done: n,
        value: t
      };
    }

    function ff() {
      return this;
    }

    function af(n) {
      for (var t, r = this; r instanceof J;) {
        var e = io(r);
        e.__index__ = 0, e.__values__ = X, t ? u.__wrapped__ = e : t = e;
        var u = e;
        r = r.__wrapped__;
      }

      return u.__wrapped__ = n, t;
    }

    function cf() {
      var n = this.__wrapped__;

      if (n instanceof Dt) {
        var t = n;
        return this.__actions__.length && (t = new Dt(this)), t = t.reverse(), t.__actions__.push({
          func: rf,
          args: [Wo],
          thisArg: X
        }), new Y(t, this.__chain__);
      }

      return this.thru(Wo);
    }

    function lf() {
      return mu(this.__wrapped__, this.__actions__);
    }

    function sf(n, t, r) {
      var e = mh(n) ? o : Yr;
      return r && $i(n, t, r) && (t = X), e(n, Ai(t, 3));
    }

    function hf(n, t) {
      var r = mh(n) ? f : ee;
      return r(n, Ai(t, 3));
    }

    function pf(n, t) {
      return ue(bf(n, t), 1);
    }

    function vf(n, t) {
      return ue(bf(n, t), En);
    }

    function _f(n, t, r) {
      return r = r === X ? 1 : Ia(r), ue(bf(n, t), r);
    }

    function gf(n, t) {
      var r = mh(n) ? u : bs;
      return r(n, Ai(t, 3));
    }

    function yf(n, t) {
      var r = mh(n) ? i : ws;
      return r(n, Ai(t, 3));
    }

    function df(n, t, r, e) {
      n = Yf(n) ? n : uc(n), r = r && !e ? Ia(r) : 0;
      var u = n.length;
      return r < 0 && (r = Jl(u + r, 0)), wa(n) ? r <= u && n.indexOf(t, r) > -1 : !!u && b(n, t, r) > -1;
    }

    function bf(n, t) {
      var r = mh(n) ? l : qe;
      return r(n, Ai(t, 3));
    }

    function wf(n, t, r, e) {
      return null == n ? [] : (mh(t) || (t = null == t ? [] : [t]), r = e ? X : r, mh(r) || (r = null == r ? [] : [r]), Je(n, t, r));
    }

    function mf(n, t, r) {
      var e = mh(n) ? h : k,
          u = arguments.length < 3;
      return e(n, Ai(t, 4), r, u, bs);
    }

    function xf(n, t, r) {
      var e = mh(n) ? p : k,
          u = arguments.length < 3;
      return e(n, Ai(t, 4), r, u, ws);
    }

    function jf(n, t) {
      var r = mh(n) ? f : ee;
      return r(n, Tf(Ai(t, 3)));
    }

    function Af(n) {
      var t = mh(n) ? Rr : ou;
      return t(n);
    }

    function kf(n, t, r) {
      t = (r ? $i(n, t, r) : t === X) ? 1 : Ia(t);
      var e = mh(n) ? zr : fu;
      return e(n, t);
    }

    function Of(n) {
      var t = mh(n) ? Er : cu;
      return t(n);
    }

    function If(n) {
      if (null == n) return 0;
      if (Yf(n)) return wa(n) ? G(n) : n.length;
      var t = Ss(n);
      return t == Vn || t == nt ? n.size : Fe(n).length;
    }

    function Rf(n, t, r) {
      var e = mh(n) ? v : su;
      return r && $i(n, t, r) && (t = X), e(n, Ai(t, 3));
    }

    function zf(n, t) {
      if ("function" != typeof t) throw new _l(en);
      return n = Ia(n), function () {
        if (--n < 1) return t.apply(this, arguments);
      };
    }

    function Ef(n, t, r) {
      return t = r ? X : t, t = n && null == t ? n.length : t, hi(n, wn, X, X, X, X, t);
    }

    function Sf(n, t) {
      var r;
      if ("function" != typeof t) throw new _l(en);
      return n = Ia(n), function () {
        return --n > 0 && (r = t.apply(this, arguments)), n <= 1 && (t = X), r;
      };
    }

    function Wf(n, t, r) {
      t = r ? X : t;
      var e = hi(n, gn, X, X, X, X, X, t);
      return e.placeholder = Wf.placeholder, e;
    }

    function Lf(n, t, r) {
      t = r ? X : t;
      var e = hi(n, yn, X, X, X, X, X, t);
      return e.placeholder = Lf.placeholder, e;
    }

    function Cf(n, t, r) {
      function e(t) {
        var r = h,
            e = p;
        return h = p = X, d = t, _ = n.apply(e, r);
      }

      function u(n) {
        return d = n, g = Cs(f, t), b ? e(n) : _;
      }

      function i(n) {
        var r = n - y,
            e = n - d,
            u = t - r;
        return w ? Yl(u, v - e) : u;
      }

      function o(n) {
        var r = n - y,
            e = n - d;
        return y === X || r >= t || r < 0 || w && e >= v;
      }

      function f() {
        var n = ch();
        return o(n) ? a(n) : void (g = Cs(f, i(n)));
      }

      function a(n) {
        return g = X, m && h ? e(n) : (h = p = X, _);
      }

      function c() {
        g !== X && Os(g), d = 0, h = y = p = g = X;
      }

      function l() {
        return g === X ? _ : a(ch());
      }

      function s() {
        var n = ch(),
            r = o(n);

        if (h = arguments, p = this, y = n, r) {
          if (g === X) return u(y);
          if (w) return g = Cs(f, t), e(y);
        }

        return g === X && (g = Cs(f, t)), _;
      }

      var h,
          p,
          v,
          _,
          g,
          y,
          d = 0,
          b = !1,
          w = !1,
          m = !0;

      if ("function" != typeof n) throw new _l(en);
      return t = za(t) || 0, ca(r) && (b = !!r.leading, w = "maxWait" in r, v = w ? Jl(za(r.maxWait) || 0, t) : v, m = "trailing" in r ? !!r.trailing : m), s.cancel = c, s.flush = l, s;
    }

    function Uf(n) {
      return hi(n, xn);
    }

    function Bf(n, t) {
      if ("function" != typeof n || null != t && "function" != typeof t) throw new _l(en);

      var r = function r() {
        var e = arguments,
            u = t ? t.apply(this, e) : e[0],
            i = r.cache;
        if (i.has(u)) return i.get(u);
        var o = n.apply(this, e);
        return r.cache = i.set(u, o) || i, o;
      };

      return r.cache = new (Bf.Cache || hr)(), r;
    }

    function Tf(n) {
      if ("function" != typeof n) throw new _l(en);
      return function () {
        var t = arguments;

        switch (t.length) {
          case 0:
            return !n.call(this);

          case 1:
            return !n.call(this, t[0]);

          case 2:
            return !n.call(this, t[0], t[1]);

          case 3:
            return !n.call(this, t[0], t[1], t[2]);
        }

        return !n.apply(this, t);
      };
    }

    function $f(n) {
      return Sf(2, n);
    }

    function Df(n, t) {
      if ("function" != typeof n) throw new _l(en);
      return t = t === X ? t : Ia(t), iu(n, t);
    }

    function Mf(n, t) {
      if ("function" != typeof n) throw new _l(en);
      return t = null == t ? 0 : Jl(Ia(t), 0), iu(function (e) {
        var u = e[t],
            i = Iu(e, 0, t);
        return u && s(i, u), r(n, this, i);
      });
    }

    function Ff(n, t, r) {
      var e = !0,
          u = !0;
      if ("function" != typeof n) throw new _l(en);
      return ca(r) && (e = "leading" in r ? !!r.leading : e, u = "trailing" in r ? !!r.trailing : u), Cf(n, t, {
        leading: e,
        maxWait: t,
        trailing: u
      });
    }

    function Nf(n) {
      return Ef(n, 1);
    }

    function Pf(n, t) {
      return _h(ku(t), n);
    }

    function qf() {
      if (!arguments.length) return [];
      var n = arguments[0];
      return mh(n) ? n : [n];
    }

    function Zf(n) {
      return Nr(n, ln);
    }

    function Kf(n, t) {
      return t = "function" == typeof t ? t : X, Nr(n, ln, t);
    }

    function Vf(n) {
      return Nr(n, an | ln);
    }

    function Gf(n, t) {
      return t = "function" == typeof t ? t : X, Nr(n, an | ln, t);
    }

    function Hf(n, t) {
      return null == t || Gr(n, t, Za(t));
    }

    function Jf(n, t) {
      return n === t || n !== n && t !== t;
    }

    function Yf(n) {
      return null != n && aa(n.length) && !oa(n);
    }

    function Qf(n) {
      return la(n) && Yf(n);
    }

    function Xf(n) {
      return n === !0 || n === !1 || la(n) && me(n) == Fn;
    }

    function na(n) {
      return la(n) && 1 === n.nodeType && !da(n);
    }

    function ta(n) {
      if (null == n) return !0;
      if (Yf(n) && (mh(n) || "string" == typeof n || "function" == typeof n.splice || jh(n) || Rh(n) || wh(n))) return !n.length;
      var t = Ss(n);
      if (t == Vn || t == nt) return !n.size;
      if (Pi(n)) return !Fe(n).length;

      for (var r in n) {
        if (ml.call(n, r)) return !1;
      }

      return !0;
    }

    function ra(n, t) {
      return We(n, t);
    }

    function ea(n, t, r) {
      r = "function" == typeof r ? r : X;
      var e = r ? r(n, t) : X;
      return e === X ? We(n, t, X, r) : !!e;
    }

    function ua(n) {
      if (!la(n)) return !1;
      var t = me(n);
      return t == qn || t == Pn || "string" == typeof n.message && "string" == typeof n.name && !da(n);
    }

    function ia(n) {
      return "number" == typeof n && Vl(n);
    }

    function oa(n) {
      if (!ca(n)) return !1;
      var t = me(n);
      return t == Zn || t == Kn || t == Mn || t == Qn;
    }

    function fa(n) {
      return "number" == typeof n && n == Ia(n);
    }

    function aa(n) {
      return "number" == typeof n && n > -1 && n % 1 == 0 && n <= Sn;
    }

    function ca(n) {
      var t = _typeof(n);

      return null != n && ("object" == t || "function" == t);
    }

    function la(n) {
      return null != n && "object" == _typeof(n);
    }

    function sa(n, t) {
      return n === t || Ue(n, t, Oi(t));
    }

    function ha(n, t, r) {
      return r = "function" == typeof r ? r : X, Ue(n, t, Oi(t), r);
    }

    function pa(n) {
      return ya(n) && n != +n;
    }

    function va(n) {
      if (Ws(n)) throw new cl(rn);
      return Be(n);
    }

    function _a(n) {
      return null === n;
    }

    function ga(n) {
      return null == n;
    }

    function ya(n) {
      return "number" == typeof n || la(n) && me(n) == Gn;
    }

    function da(n) {
      if (!la(n) || me(n) != Jn) return !1;
      var t = Wl(n);
      if (null === t) return !0;
      var r = ml.call(t, "constructor") && t.constructor;
      return "function" == typeof r && r instanceof r && wl.call(r) == kl;
    }

    function ba(n) {
      return fa(n) && n >= -Sn && n <= Sn;
    }

    function wa(n) {
      return "string" == typeof n || !mh(n) && la(n) && me(n) == tt;
    }

    function ma(n) {
      return "symbol" == _typeof(n) || la(n) && me(n) == rt;
    }

    function xa(n) {
      return n === X;
    }

    function ja(n) {
      return la(n) && Ss(n) == ut;
    }

    function Aa(n) {
      return la(n) && me(n) == it;
    }

    function ka(n) {
      if (!n) return [];
      if (Yf(n)) return wa(n) ? H(n) : Mu(n);
      if (Tl && n[Tl]) return M(n[Tl]());
      var t = Ss(n),
          r = t == Vn ? F : t == nt ? q : uc;
      return r(n);
    }

    function Oa(n) {
      if (!n) return 0 === n ? n : 0;

      if (n = za(n), n === En || n === -En) {
        var t = n < 0 ? -1 : 1;
        return t * Wn;
      }

      return n === n ? n : 0;
    }

    function Ia(n) {
      var t = Oa(n),
          r = t % 1;
      return t === t ? r ? t - r : t : 0;
    }

    function Ra(n) {
      return n ? Fr(Ia(n), 0, Cn) : 0;
    }

    function za(n) {
      if ("number" == typeof n) return n;
      if (ma(n)) return Ln;

      if (ca(n)) {
        var t = "function" == typeof n.valueOf ? n.valueOf() : n;
        n = ca(t) ? t + "" : t;
      }

      if ("string" != typeof n) return 0 === n ? n : +n;
      n = n.replace(Lt, "");
      var r = qt.test(n);
      return r || Kt.test(n) ? Xr(n.slice(2), r ? 2 : 8) : Pt.test(n) ? Ln : +n;
    }

    function Ea(n) {
      return Fu(n, Ka(n));
    }

    function Sa(n) {
      return n ? Fr(Ia(n), -Sn, Sn) : 0 === n ? n : 0;
    }

    function Wa(n) {
      return null == n ? "" : gu(n);
    }

    function La(n, t) {
      var r = ds(n);
      return null == t ? r : Ur(r, t);
    }

    function Ca(n, t) {
      return y(n, Ai(t, 3), oe);
    }

    function Ua(n, t) {
      return y(n, Ai(t, 3), fe);
    }

    function Ba(n, t) {
      return null == n ? n : ms(n, Ai(t, 3), Ka);
    }

    function Ta(n, t) {
      return null == n ? n : xs(n, Ai(t, 3), Ka);
    }

    function $a(n, t) {
      return n && oe(n, Ai(t, 3));
    }

    function Da(n, t) {
      return n && fe(n, Ai(t, 3));
    }

    function Ma(n) {
      return null == n ? [] : ve(n, Za(n));
    }

    function Fa(n) {
      return null == n ? [] : ve(n, Ka(n));
    }

    function Na(n, t, r) {
      var e = null == n ? X : de(n, t);
      return e === X ? r : e;
    }

    function Pa(n, t) {
      return null != n && Si(n, t, je);
    }

    function qa(n, t) {
      return null != n && Si(n, t, Ae);
    }

    function Za(n) {
      return Yf(n) ? Ir(n) : Fe(n);
    }

    function Ka(n) {
      return Yf(n) ? Ir(n, !0) : Ne(n);
    }

    function Va(n, t) {
      var r = {};
      return t = Ai(t, 3), oe(n, function (n, e, u) {
        Tr(r, t(n, e, u), n);
      }), r;
    }

    function Ga(n, t) {
      var r = {};
      return t = Ai(t, 3), oe(n, function (n, e, u) {
        Tr(r, e, t(n, e, u));
      }), r;
    }

    function Ha(n, t) {
      return Ja(n, Tf(Ai(t)));
    }

    function Ja(n, t) {
      if (null == n) return {};
      var r = l(mi(n), function (n) {
        return [n];
      });
      return t = Ai(t), Qe(n, r, function (n, r) {
        return t(n, r[0]);
      });
    }

    function Ya(n, t, r) {
      t = Ou(t, n);
      var e = -1,
          u = t.length;

      for (u || (u = 1, n = X); ++e < u;) {
        var i = null == n ? X : n[ro(t[e])];
        i === X && (e = u, i = r), n = oa(i) ? i.call(n) : i;
      }

      return n;
    }

    function Qa(n, t, r) {
      return null == n ? n : au(n, t, r);
    }

    function Xa(n, t, r, e) {
      return e = "function" == typeof e ? e : X, null == n ? n : au(n, t, r, e);
    }

    function nc(n, t, r) {
      var e = mh(n),
          i = e || jh(n) || Rh(n);

      if (t = Ai(t, 4), null == r) {
        var o = n && n.constructor;
        r = i ? e ? new o() : [] : ca(n) && oa(o) ? ds(Wl(n)) : {};
      }

      return (i ? u : oe)(n, function (n, e, u) {
        return t(r, n, e, u);
      }), r;
    }

    function tc(n, t) {
      return null == n || du(n, t);
    }

    function rc(n, t, r) {
      return null == n ? n : bu(n, t, ku(r));
    }

    function ec(n, t, r, e) {
      return e = "function" == typeof e ? e : X, null == n ? n : bu(n, t, ku(r), e);
    }

    function uc(n) {
      return null == n ? [] : S(n, Za(n));
    }

    function ic(n) {
      return null == n ? [] : S(n, Ka(n));
    }

    function oc(n, t, r) {
      return r === X && (r = t, t = X), r !== X && (r = za(r), r = r === r ? r : 0), t !== X && (t = za(t), t = t === t ? t : 0), Fr(za(n), t, r);
    }

    function fc(n, t, r) {
      return t = Oa(t), r === X ? (r = t, t = 0) : r = Oa(r), n = za(n), ke(n, t, r);
    }

    function ac(n, t, r) {
      if (r && "boolean" != typeof r && $i(n, t, r) && (t = r = X), r === X && ("boolean" == typeof t ? (r = t, t = X) : "boolean" == typeof n && (r = n, n = X)), n === X && t === X ? (n = 0, t = 1) : (n = Oa(n), t === X ? (t = n, n = 0) : t = Oa(t)), n > t) {
        var e = n;
        n = t, t = e;
      }

      if (r || n % 1 || t % 1) {
        var u = ns();
        return Yl(n + u * (t - n + Qr("1e-" + ((u + "").length - 1))), t);
      }

      return ru(n, t);
    }

    function cc(n) {
      return np(Wa(n).toLowerCase());
    }

    function lc(n) {
      return n = Wa(n), n && n.replace(Gt, _e).replace(Dr, "");
    }

    function sc(n, t, r) {
      n = Wa(n), t = gu(t);
      var e = n.length;
      r = r === X ? e : Fr(Ia(r), 0, e);
      var u = r;
      return r -= t.length, r >= 0 && n.slice(r, u) == t;
    }

    function hc(n) {
      return n = Wa(n), n && jt.test(n) ? n.replace(mt, ge) : n;
    }

    function pc(n) {
      return n = Wa(n), n && Wt.test(n) ? n.replace(St, "\\$&") : n;
    }

    function vc(n, t, r) {
      n = Wa(n), t = Ia(t);
      var e = t ? G(n) : 0;
      if (!t || e >= t) return n;
      var u = (t - e) / 2;
      return ii(ql(u), r) + n + ii(Pl(u), r);
    }

    function _c(n, t, r) {
      n = Wa(n), t = Ia(t);
      var e = t ? G(n) : 0;
      return t && e < t ? n + ii(t - e, r) : n;
    }

    function gc(n, t, r) {
      n = Wa(n), t = Ia(t);
      var e = t ? G(n) : 0;
      return t && e < t ? ii(t - e, r) + n : n;
    }

    function yc(n, t, r) {
      return r || null == t ? t = 0 : t && (t = +t), Xl(Wa(n).replace(Ct, ""), t || 0);
    }

    function dc(n, t, r) {
      return t = (r ? $i(n, t, r) : t === X) ? 1 : Ia(t), uu(Wa(n), t);
    }

    function bc() {
      var n = arguments,
          t = Wa(n[0]);
      return n.length < 3 ? t : t.replace(n[1], n[2]);
    }

    function wc(n, t, r) {
      return r && "number" != typeof r && $i(n, t, r) && (t = r = X), (r = r === X ? Cn : r >>> 0) ? (n = Wa(n), n && ("string" == typeof t || null != t && !Oh(t)) && (t = gu(t), !t && $(n)) ? Iu(H(n), 0, r) : n.split(t, r)) : [];
    }

    function mc(n, t, r) {
      return n = Wa(n), r = null == r ? 0 : Fr(Ia(r), 0, n.length), t = gu(t), n.slice(r, r + t.length) == t;
    }

    function xc(n, t, r) {
      var e = K.templateSettings;
      r && $i(n, t, r) && (t = X), n = Wa(n), t = Lh({}, t, e, pi);
      var u,
          i,
          o = Lh({}, t.imports, e.imports, pi),
          f = Za(o),
          a = S(o, f),
          c = 0,
          l = t.interpolate || Ht,
          s = "__p += '",
          h = pl((t.escape || Ht).source + "|" + l.source + "|" + (l === Ot ? Ft : Ht).source + "|" + (t.evaluate || Ht).source + "|$", "g"),
          p = "//# sourceURL=" + ("sourceURL" in t ? t.sourceURL : "lodash.templateSources[" + ++Zr + "]") + "\n";
      n.replace(h, function (t, r, e, o, f, a) {
        return e || (e = o), s += n.slice(c, a).replace(Jt, B), r && (u = !0, s += "' +\n__e(" + r + ") +\n'"), f && (i = !0, s += "';\n" + f + ";\n__p += '"), e && (s += "' +\n((__t = (" + e + ")) == null ? '' : __t) +\n'"), c = a + t.length, t;
      }), s += "';\n";
      var v = t.variable;
      v || (s = "with (obj) {\n" + s + "\n}\n"), s = (i ? s.replace(yt, "") : s).replace(dt, "$1").replace(bt, "$1;"), s = "function(" + (v || "obj") + ") {\n" + (v ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (u ? ", __e = _.escape" : "") + (i ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + s + "return __p\n}";

      var _ = tp(function () {
        return ll(f, p + "return " + s).apply(X, a);
      });

      if (_.source = s, ua(_)) throw _;
      return _;
    }

    function jc(n) {
      return Wa(n).toLowerCase();
    }

    function Ac(n) {
      return Wa(n).toUpperCase();
    }

    function kc(n, t, r) {
      if (n = Wa(n), n && (r || t === X)) return n.replace(Lt, "");
      if (!n || !(t = gu(t))) return n;
      var e = H(n),
          u = H(t),
          i = L(e, u),
          o = C(e, u) + 1;
      return Iu(e, i, o).join("");
    }

    function Oc(n, t, r) {
      if (n = Wa(n), n && (r || t === X)) return n.replace(Ut, "");
      if (!n || !(t = gu(t))) return n;
      var e = H(n),
          u = C(e, H(t)) + 1;
      return Iu(e, 0, u).join("");
    }

    function Ic(n, t, r) {
      if (n = Wa(n), n && (r || t === X)) return n.replace(Ct, "");
      if (!n || !(t = gu(t))) return n;
      var e = H(n),
          u = L(e, H(t));
      return Iu(e, u).join("");
    }

    function Rc(n, t) {
      var r = jn,
          e = An;

      if (ca(t)) {
        var u = "separator" in t ? t.separator : u;
        r = "length" in t ? Ia(t.length) : r, e = "omission" in t ? gu(t.omission) : e;
      }

      n = Wa(n);
      var i = n.length;

      if ($(n)) {
        var o = H(n);
        i = o.length;
      }

      if (r >= i) return n;
      var f = r - G(e);
      if (f < 1) return e;
      var a = o ? Iu(o, 0, f).join("") : n.slice(0, f);
      if (u === X) return a + e;

      if (o && (f += a.length - f), Oh(u)) {
        if (n.slice(f).search(u)) {
          var c,
              l = a;

          for (u.global || (u = pl(u.source, Wa(Nt.exec(u)) + "g")), u.lastIndex = 0; c = u.exec(l);) {
            var s = c.index;
          }

          a = a.slice(0, s === X ? f : s);
        }
      } else if (n.indexOf(gu(u), f) != f) {
        var h = a.lastIndexOf(u);
        h > -1 && (a = a.slice(0, h));
      }

      return a + e;
    }

    function zc(n) {
      return n = Wa(n), n && xt.test(n) ? n.replace(wt, ye) : n;
    }

    function Ec(n, t, r) {
      return n = Wa(n), t = r ? X : t, t === X ? D(n) ? Q(n) : g(n) : n.match(t) || [];
    }

    function Sc(n) {
      var t = null == n ? 0 : n.length,
          e = Ai();
      return n = t ? l(n, function (n) {
        if ("function" != typeof n[1]) throw new _l(en);
        return [e(n[0]), n[1]];
      }) : [], iu(function (e) {
        for (var u = -1; ++u < t;) {
          var i = n[u];
          if (r(i[0], this, e)) return r(i[1], this, e);
        }
      });
    }

    function Wc(n) {
      return Pr(Nr(n, an));
    }

    function Lc(n) {
      return function () {
        return n;
      };
    }

    function Cc(n, t) {
      return null == n || n !== n ? t : n;
    }

    function Uc(n) {
      return n;
    }

    function Bc(n) {
      return Me("function" == typeof n ? n : Nr(n, an));
    }

    function Tc(n) {
      return Ze(Nr(n, an));
    }

    function $c(n, t) {
      return Ke(n, Nr(t, an));
    }

    function Dc(n, t, r) {
      var e = Za(t),
          i = ve(t, e);
      null != r || ca(t) && (i.length || !e.length) || (r = t, t = n, n = this, i = ve(t, Za(t)));
      var o = !(ca(r) && "chain" in r && !r.chain),
          f = oa(n);
      return u(i, function (r) {
        var e = t[r];
        n[r] = e, f && (n.prototype[r] = function () {
          var t = this.__chain__;

          if (o || t) {
            var r = n(this.__wrapped__),
                u = r.__actions__ = Mu(this.__actions__);
            return u.push({
              func: e,
              args: arguments,
              thisArg: n
            }), r.__chain__ = t, r;
          }

          return e.apply(n, s([this.value()], arguments));
        });
      }), n;
    }

    function Mc() {
      return re._ === this && (re._ = Ol), this;
    }

    function Fc() {}

    function Nc(n) {
      return n = Ia(n), iu(function (t) {
        return He(t, n);
      });
    }

    function Pc(n) {
      return Di(n) ? j(ro(n)) : Xe(n);
    }

    function qc(n) {
      return function (t) {
        return null == n ? X : de(n, t);
      };
    }

    function Zc() {
      return [];
    }

    function Kc() {
      return !1;
    }

    function Vc() {
      return {};
    }

    function Gc() {
      return "";
    }

    function Hc() {
      return !0;
    }

    function Jc(n, t) {
      if (n = Ia(n), n < 1 || n > Sn) return [];
      var r = Cn,
          e = Yl(n, Cn);
      t = Ai(t), n -= Cn;

      for (var u = R(e, t); ++r < n;) {
        t(r);
      }

      return u;
    }

    function Yc(n) {
      return mh(n) ? l(n, ro) : ma(n) ? [n] : Mu(Bs(Wa(n)));
    }

    function Qc(n) {
      var t = ++xl;
      return Wa(n) + t;
    }

    function Xc(n) {
      return n && n.length ? ne(n, Uc, xe) : X;
    }

    function nl(n, t) {
      return n && n.length ? ne(n, Ai(t, 2), xe) : X;
    }

    function tl(n) {
      return x(n, Uc);
    }

    function rl(n, t) {
      return x(n, Ai(t, 2));
    }

    function el(n) {
      return n && n.length ? ne(n, Uc, Pe) : X;
    }

    function ul(n, t) {
      return n && n.length ? ne(n, Ai(t, 2), Pe) : X;
    }

    function il(n) {
      return n && n.length ? I(n, Uc) : 0;
    }

    function ol(n, t) {
      return n && n.length ? I(n, Ai(t, 2)) : 0;
    }

    A = null == A ? re : be.defaults(re.Object(), A, be.pick(re, qr));

    var fl = A.Array,
        al = A.Date,
        cl = A.Error,
        ll = A.Function,
        sl = A.Math,
        hl = A.Object,
        pl = A.RegExp,
        vl = A.String,
        _l = A.TypeError,
        gl = fl.prototype,
        yl = ll.prototype,
        dl = hl.prototype,
        bl = A["__core-js_shared__"],
        wl = yl.toString,
        ml = dl.hasOwnProperty,
        xl = 0,
        jl = function () {
      var n = /[^.]+$/.exec(bl && bl.keys && bl.keys.IE_PROTO || "");
      return n ? "Symbol(src)_1." + n : "";
    }(),
        Al = dl.toString,
        kl = wl.call(hl),
        Ol = re._,
        Il = pl("^" + wl.call(ml).replace(St, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
        Rl = ie ? A.Buffer : X,
        zl = A.Symbol,
        El = A.Uint8Array,
        Sl = Rl ? Rl.allocUnsafe : X,
        Wl = N(hl.getPrototypeOf, hl),
        Ll = hl.create,
        Cl = dl.propertyIsEnumerable,
        Ul = gl.splice,
        Bl = zl ? zl.isConcatSpreadable : X,
        Tl = zl ? zl.iterator : X,
        $l = zl ? zl.toStringTag : X,
        Dl = function () {
      try {
        var n = Ii(hl, "defineProperty");
        return n({}, "", {}), n;
      } catch (n) {}
    }(),
        Ml = A.clearTimeout !== re.clearTimeout && A.clearTimeout,
        Fl = al && al.now !== re.Date.now && al.now,
        Nl = A.setTimeout !== re.setTimeout && A.setTimeout,
        Pl = sl.ceil,
        ql = sl.floor,
        Zl = hl.getOwnPropertySymbols,
        Kl = Rl ? Rl.isBuffer : X,
        Vl = A.isFinite,
        Gl = gl.join,
        Hl = N(hl.keys, hl),
        Jl = sl.max,
        Yl = sl.min,
        Ql = al.now,
        Xl = A.parseInt,
        ns = sl.random,
        ts = gl.reverse,
        rs = Ii(A, "DataView"),
        es = Ii(A, "Map"),
        us = Ii(A, "Promise"),
        is = Ii(A, "Set"),
        os = Ii(A, "WeakMap"),
        fs = Ii(hl, "create"),
        as = os && new os(),
        cs = {},
        ls = eo(rs),
        ss = eo(es),
        hs = eo(us),
        ps = eo(is),
        vs = eo(os),
        _s = zl ? zl.prototype : X,
        gs = _s ? _s.valueOf : X,
        ys = _s ? _s.toString : X,
        ds = function () {
      function n() {}

      return function (t) {
        if (!ca(t)) return {};
        if (Ll) return Ll(t);
        n.prototype = t;
        var r = new n();
        return n.prototype = X, r;
      };
    }();

    K.templateSettings = {
      escape: At,
      evaluate: kt,
      interpolate: Ot,
      variable: "",
      imports: {
        _: K
      }
    }, K.prototype = J.prototype, K.prototype.constructor = K, Y.prototype = ds(J.prototype), Y.prototype.constructor = Y, Dt.prototype = ds(J.prototype), Dt.prototype.constructor = Dt, nr.prototype.clear = tr, nr.prototype.delete = rr, nr.prototype.get = er, nr.prototype.has = ur, nr.prototype.set = ir, or.prototype.clear = fr, or.prototype.delete = ar, or.prototype.get = cr, or.prototype.has = lr, or.prototype.set = sr, hr.prototype.clear = pr, hr.prototype.delete = vr, hr.prototype.get = _r, hr.prototype.has = gr, hr.prototype.set = yr, dr.prototype.add = dr.prototype.push = br, dr.prototype.has = wr, mr.prototype.clear = xr, mr.prototype.delete = jr, mr.prototype.get = Ar, mr.prototype.has = kr, mr.prototype.set = Or;

    var bs = Ku(oe),
        ws = Ku(fe, !0),
        ms = Vu(),
        xs = Vu(!0),
        js = as ? function (n, t) {
      return as.set(n, t), n;
    } : Uc,
        As = Dl ? function (n, t) {
      return Dl(n, "toString", {
        configurable: !0,
        enumerable: !1,
        value: Lc(t),
        writable: !0
      });
    } : Uc,
        ks = iu,
        Os = Ml || function (n) {
      return re.clearTimeout(n);
    },
        Is = is && 1 / q(new is([, -0]))[1] == En ? function (n) {
      return new is(n);
    } : Fc,
        Rs = as ? function (n) {
      return as.get(n);
    } : Fc,
        zs = Zl ? function (n) {
      return null == n ? [] : (n = hl(n), f(Zl(n), function (t) {
        return Cl.call(n, t);
      }));
    } : Zc,
        Es = Zl ? function (n) {
      for (var t = []; n;) {
        s(t, zs(n)), n = Wl(n);
      }

      return t;
    } : Zc,
        Ss = me;

    (rs && Ss(new rs(new ArrayBuffer(1))) != ft || es && Ss(new es()) != Vn || us && Ss(us.resolve()) != Yn || is && Ss(new is()) != nt || os && Ss(new os()) != ut) && (Ss = function Ss(n) {
      var t = me(n),
          r = t == Jn ? n.constructor : X,
          e = r ? eo(r) : "";
      if (e) switch (e) {
        case ls:
          return ft;

        case ss:
          return Vn;

        case hs:
          return Yn;

        case ps:
          return nt;

        case vs:
          return ut;
      }
      return t;
    });

    var Ws = bl ? oa : Kc,
        Ls = no(js),
        Cs = Nl || function (n, t) {
      return re.setTimeout(n, t);
    },
        Us = no(As),
        Bs = Ki(function (n) {
      var t = [];
      return zt.test(n) && t.push(""), n.replace(Et, function (n, r, e, u) {
        t.push(e ? u.replace(Mt, "$1") : r || n);
      }), t;
    }),
        Ts = iu(function (n, t) {
      return Qf(n) ? Jr(n, ue(t, 1, Qf, !0)) : [];
    }),
        $s = iu(function (n, t) {
      var r = ko(t);
      return Qf(r) && (r = X), Qf(n) ? Jr(n, ue(t, 1, Qf, !0), Ai(r, 2)) : [];
    }),
        Ds = iu(function (n, t) {
      var r = ko(t);
      return Qf(r) && (r = X), Qf(n) ? Jr(n, ue(t, 1, Qf, !0), X, r) : [];
    }),
        Ms = iu(function (n) {
      var t = l(n, Au);
      return t.length && t[0] === n[0] ? Oe(t) : [];
    }),
        Fs = iu(function (n) {
      var t = ko(n),
          r = l(n, Au);
      return t === ko(r) ? t = X : r.pop(), r.length && r[0] === n[0] ? Oe(r, Ai(t, 2)) : [];
    }),
        Ns = iu(function (n) {
      var t = ko(n),
          r = l(n, Au);
      return t = "function" == typeof t ? t : X, t && r.pop(), r.length && r[0] === n[0] ? Oe(r, X, t) : [];
    }),
        Ps = iu(Ro),
        qs = bi(function (n, t) {
      var r = null == n ? 0 : n.length,
          e = Mr(n, t);
      return tu(n, l(t, function (n) {
        return Ti(n, r) ? +n : n;
      }).sort(Bu)), e;
    }),
        Zs = iu(function (n) {
      return yu(ue(n, 1, Qf, !0));
    }),
        Ks = iu(function (n) {
      var t = ko(n);
      return Qf(t) && (t = X), yu(ue(n, 1, Qf, !0), Ai(t, 2));
    }),
        Vs = iu(function (n) {
      var t = ko(n);
      return t = "function" == typeof t ? t : X, yu(ue(n, 1, Qf, !0), X, t);
    }),
        Gs = iu(function (n, t) {
      return Qf(n) ? Jr(n, t) : [];
    }),
        Hs = iu(function (n) {
      return xu(f(n, Qf));
    }),
        Js = iu(function (n) {
      var t = ko(n);
      return Qf(t) && (t = X), xu(f(n, Qf), Ai(t, 2));
    }),
        Ys = iu(function (n) {
      var t = ko(n);
      return t = "function" == typeof t ? t : X, xu(f(n, Qf), X, t);
    }),
        Qs = iu(Jo),
        Xs = iu(function (n) {
      var t = n.length,
          r = t > 1 ? n[t - 1] : X;
      return r = "function" == typeof r ? (n.pop(), r) : X, Yo(n, r);
    }),
        nh = bi(function (n) {
      var t = n.length,
          r = t ? n[0] : 0,
          e = this.__wrapped__,
          u = function u(t) {
        return Mr(t, n);
      };

      return !(t > 1 || this.__actions__.length) && e instanceof Dt && Ti(r) ? (e = e.slice(r, +r + (t ? 1 : 0)), e.__actions__.push({
        func: rf,
        args: [u],
        thisArg: X
      }), new Y(e, this.__chain__).thru(function (n) {
        return t && !n.length && n.push(X), n;
      })) : this.thru(u);
    }),
        th = qu(function (n, t, r) {
      ml.call(n, r) ? ++n[r] : Tr(n, r, 1);
    }),
        rh = Xu(vo),
        eh = Xu(_o),
        uh = qu(function (n, t, r) {
      ml.call(n, r) ? n[r].push(t) : Tr(n, r, [t]);
    }),
        ih = iu(function (n, t, e) {
      var u = -1,
          i = "function" == typeof t,
          o = Yf(n) ? fl(n.length) : [];
      return bs(n, function (n) {
        o[++u] = i ? r(t, n, e) : Re(n, t, e);
      }), o;
    }),
        oh = qu(function (n, t, r) {
      Tr(n, r, t);
    }),
        fh = qu(function (n, t, r) {
      n[r ? 0 : 1].push(t);
    }, function () {
      return [[], []];
    }),
        ah = iu(function (n, t) {
      if (null == n) return [];
      var r = t.length;
      return r > 1 && $i(n, t[0], t[1]) ? t = [] : r > 2 && $i(t[0], t[1], t[2]) && (t = [t[0]]), Je(n, ue(t, 1), []);
    }),
        ch = Fl || function () {
      return re.Date.now();
    },
        lh = iu(function (n, t, r) {
      var e = pn;

      if (r.length) {
        var u = P(r, ji(lh));
        e |= dn;
      }

      return hi(n, e, t, r, u);
    }),
        sh = iu(function (n, t, r) {
      var e = pn | vn;

      if (r.length) {
        var u = P(r, ji(sh));
        e |= dn;
      }

      return hi(t, e, n, r, u);
    }),
        hh = iu(function (n, t) {
      return Hr(n, 1, t);
    }),
        ph = iu(function (n, t, r) {
      return Hr(n, za(t) || 0, r);
    });

    Bf.Cache = hr;

    var vh = ks(function (n, t) {
      t = 1 == t.length && mh(t[0]) ? l(t[0], E(Ai())) : l(ue(t, 1), E(Ai()));
      var e = t.length;
      return iu(function (u) {
        for (var i = -1, o = Yl(u.length, e); ++i < o;) {
          u[i] = t[i].call(this, u[i]);
        }

        return r(n, this, u);
      });
    }),
        _h = iu(function (n, t) {
      var r = P(t, ji(_h));
      return hi(n, dn, X, t, r);
    }),
        gh = iu(function (n, t) {
      var r = P(t, ji(gh));
      return hi(n, bn, X, t, r);
    }),
        yh = bi(function (n, t) {
      return hi(n, mn, X, X, X, t);
    }),
        dh = ai(xe),
        bh = ai(function (n, t) {
      return n >= t;
    }),
        wh = ze(function () {
      return arguments;
    }()) ? ze : function (n) {
      return la(n) && ml.call(n, "callee") && !Cl.call(n, "callee");
    },
        mh = fl.isArray,
        xh = ae ? E(ae) : Ee,
        jh = Kl || Kc,
        Ah = ce ? E(ce) : Se,
        kh = le ? E(le) : Ce,
        Oh = se ? E(se) : Te,
        Ih = he ? E(he) : $e,
        Rh = pe ? E(pe) : De,
        zh = ai(Pe),
        Eh = ai(function (n, t) {
      return n <= t;
    }),
        Sh = Zu(function (n, t) {
      if (Pi(t) || Yf(t)) return void Fu(t, Za(t), n);

      for (var r in t) {
        ml.call(t, r) && Wr(n, r, t[r]);
      }
    }),
        Wh = Zu(function (n, t) {
      Fu(t, Ka(t), n);
    }),
        Lh = Zu(function (n, t, r, e) {
      Fu(t, Ka(t), n, e);
    }),
        Ch = Zu(function (n, t, r, e) {
      Fu(t, Za(t), n, e);
    }),
        Uh = bi(Mr),
        Bh = iu(function (n) {
      return n.push(X, pi), r(Lh, X, n);
    }),
        Th = iu(function (n) {
      return n.push(X, vi), r(Nh, X, n);
    }),
        $h = ri(function (n, t, r) {
      n[t] = r;
    }, Lc(Uc)),
        Dh = ri(function (n, t, r) {
      ml.call(n, t) ? n[t].push(r) : n[t] = [r];
    }, Ai),
        Mh = iu(Re),
        Fh = Zu(function (n, t, r) {
      Ve(n, t, r);
    }),
        Nh = Zu(function (n, t, r, e) {
      Ve(n, t, r, e);
    }),
        Ph = bi(function (n, t) {
      var r = {};
      if (null == n) return r;
      var e = !1;
      t = l(t, function (t) {
        return t = Ou(t, n), e || (e = t.length > 1), t;
      }), Fu(n, mi(n), r), e && (r = Nr(r, an | cn | ln, _i));

      for (var u = t.length; u--;) {
        du(r, t[u]);
      }

      return r;
    }),
        qh = bi(function (n, t) {
      return null == n ? {} : Ye(n, t);
    }),
        Zh = si(Za),
        Kh = si(Ka),
        Vh = Ju(function (n, t, r) {
      return t = t.toLowerCase(), n + (r ? cc(t) : t);
    }),
        Gh = Ju(function (n, t, r) {
      return n + (r ? "-" : "") + t.toLowerCase();
    }),
        Hh = Ju(function (n, t, r) {
      return n + (r ? " " : "") + t.toLowerCase();
    }),
        Jh = Hu("toLowerCase"),
        Yh = Ju(function (n, t, r) {
      return n + (r ? "_" : "") + t.toLowerCase();
    }),
        Qh = Ju(function (n, t, r) {
      return n + (r ? " " : "") + np(t);
    }),
        Xh = Ju(function (n, t, r) {
      return n + (r ? " " : "") + t.toUpperCase();
    }),
        np = Hu("toUpperCase"),
        tp = iu(function (n, t) {
      try {
        return r(n, X, t);
      } catch (n) {
        return ua(n) ? n : new cl(n);
      }
    }),
        rp = bi(function (n, t) {
      return u(t, function (t) {
        t = ro(t), Tr(n, t, lh(n[t], n));
      }), n;
    }),
        ep = ni(),
        up = ni(!0),
        ip = iu(function (n, t) {
      return function (r) {
        return Re(r, n, t);
      };
    }),
        op = iu(function (n, t) {
      return function (r) {
        return Re(n, r, t);
      };
    }),
        fp = ui(l),
        ap = ui(o),
        cp = ui(v),
        lp = fi(),
        sp = fi(!0),
        hp = ei(function (n, t) {
      return n + t;
    }, 0),
        pp = li("ceil"),
        vp = ei(function (n, t) {
      return n / t;
    }, 1),
        _p = li("floor"),
        gp = ei(function (n, t) {
      return n * t;
    }, 1),
        yp = li("round"),
        dp = ei(function (n, t) {
      return n - t;
    }, 0);

    return K.after = zf, K.ary = Ef, K.assign = Sh, K.assignIn = Wh, K.assignInWith = Lh, K.assignWith = Ch, K.at = Uh, K.before = Sf, K.bind = lh, K.bindAll = rp, K.bindKey = sh, K.castArray = qf, K.chain = nf, K.chunk = oo, K.compact = fo, K.concat = ao, K.cond = Sc, K.conforms = Wc, K.constant = Lc, K.countBy = th, K.create = La, K.curry = Wf, K.curryRight = Lf, K.debounce = Cf, K.defaults = Bh, K.defaultsDeep = Th, K.defer = hh, K.delay = ph, K.difference = Ts, K.differenceBy = $s, K.differenceWith = Ds, K.drop = co, K.dropRight = lo, K.dropRightWhile = so, K.dropWhile = ho, K.fill = po, K.filter = hf, K.flatMap = pf, K.flatMapDeep = vf, K.flatMapDepth = _f, K.flatten = go, K.flattenDeep = yo, K.flattenDepth = bo, K.flip = Uf, K.flow = ep, K.flowRight = up, K.fromPairs = wo, K.functions = Ma, K.functionsIn = Fa, K.groupBy = uh, K.initial = jo, K.intersection = Ms, K.intersectionBy = Fs, K.intersectionWith = Ns, K.invert = $h, K.invertBy = Dh, K.invokeMap = ih, K.iteratee = Bc, K.keyBy = oh, K.keys = Za, K.keysIn = Ka, K.map = bf, K.mapKeys = Va, K.mapValues = Ga, K.matches = Tc, K.matchesProperty = $c, K.memoize = Bf, K.merge = Fh, K.mergeWith = Nh, K.method = ip, K.methodOf = op, K.mixin = Dc, K.negate = Tf, K.nthArg = Nc, K.omit = Ph, K.omitBy = Ha, K.once = $f, K.orderBy = wf, K.over = fp, K.overArgs = vh, K.overEvery = ap, K.overSome = cp, K.partial = _h, K.partialRight = gh, K.partition = fh, K.pick = qh, K.pickBy = Ja, K.property = Pc, K.propertyOf = qc, K.pull = Ps, K.pullAll = Ro, K.pullAllBy = zo, K.pullAllWith = Eo, K.pullAt = qs, K.range = lp, K.rangeRight = sp, K.rearg = yh, K.reject = jf, K.remove = So, K.rest = Df, K.reverse = Wo, K.sampleSize = kf, K.set = Qa, K.setWith = Xa, K.shuffle = Of, K.slice = Lo, K.sortBy = ah, K.sortedUniq = Mo, K.sortedUniqBy = Fo, K.split = wc, K.spread = Mf, K.tail = No, K.take = Po, K.takeRight = qo, K.takeRightWhile = Zo, K.takeWhile = Ko, K.tap = tf, K.throttle = Ff, K.thru = rf, K.toArray = ka, K.toPairs = Zh, K.toPairsIn = Kh, K.toPath = Yc, K.toPlainObject = Ea, K.transform = nc, K.unary = Nf, K.union = Zs, K.unionBy = Ks, K.unionWith = Vs, K.uniq = Vo, K.uniqBy = Go, K.uniqWith = Ho, K.unset = tc, K.unzip = Jo, K.unzipWith = Yo, K.update = rc, K.updateWith = ec, K.values = uc, K.valuesIn = ic, K.without = Gs, K.words = Ec, K.wrap = Pf, K.xor = Hs, K.xorBy = Js, K.xorWith = Ys, K.zip = Qs, K.zipObject = Qo, K.zipObjectDeep = Xo, K.zipWith = Xs, K.entries = Zh, K.entriesIn = Kh, K.extend = Wh, K.extendWith = Lh, Dc(K, K), K.add = hp, K.attempt = tp, K.camelCase = Vh, K.capitalize = cc, K.ceil = pp, K.clamp = oc, K.clone = Zf, K.cloneDeep = Vf, K.cloneDeepWith = Gf, K.cloneWith = Kf, K.conformsTo = Hf, K.deburr = lc, K.defaultTo = Cc, K.divide = vp, K.endsWith = sc, K.eq = Jf, K.escape = hc, K.escapeRegExp = pc, K.every = sf, K.find = rh, K.findIndex = vo, K.findKey = Ca, K.findLast = eh, K.findLastIndex = _o, K.findLastKey = Ua, K.floor = _p, K.forEach = gf, K.forEachRight = yf, K.forIn = Ba, K.forInRight = Ta, K.forOwn = $a, K.forOwnRight = Da, K.get = Na, K.gt = dh, K.gte = bh, K.has = Pa, K.hasIn = qa, K.head = mo, K.identity = Uc, K.includes = df, K.indexOf = xo, K.inRange = fc, K.invoke = Mh, K.isArguments = wh, K.isArray = mh, K.isArrayBuffer = xh, K.isArrayLike = Yf, K.isArrayLikeObject = Qf, K.isBoolean = Xf, K.isBuffer = jh, K.isDate = Ah, K.isElement = na, K.isEmpty = ta, K.isEqual = ra, K.isEqualWith = ea, K.isError = ua, K.isFinite = ia, K.isFunction = oa, K.isInteger = fa, K.isLength = aa, K.isMap = kh, K.isMatch = sa, K.isMatchWith = ha, K.isNaN = pa, K.isNative = va, K.isNil = ga, K.isNull = _a, K.isNumber = ya, K.isObject = ca, K.isObjectLike = la, K.isPlainObject = da, K.isRegExp = Oh, K.isSafeInteger = ba, K.isSet = Ih, K.isString = wa, K.isSymbol = ma, K.isTypedArray = Rh, K.isUndefined = xa, K.isWeakMap = ja, K.isWeakSet = Aa, K.join = Ao, K.kebabCase = Gh, K.last = ko, K.lastIndexOf = Oo, K.lowerCase = Hh, K.lowerFirst = Jh, K.lt = zh, K.lte = Eh, K.max = Xc, K.maxBy = nl, K.mean = tl, K.meanBy = rl, K.min = el, K.minBy = ul, K.stubArray = Zc, K.stubFalse = Kc, K.stubObject = Vc, K.stubString = Gc, K.stubTrue = Hc, K.multiply = gp, K.nth = Io, K.noConflict = Mc, K.noop = Fc, K.now = ch, K.pad = vc, K.padEnd = _c, K.padStart = gc, K.parseInt = yc, K.random = ac, K.reduce = mf, K.reduceRight = xf, K.repeat = dc, K.replace = bc, K.result = Ya, K.round = yp, K.runInContext = _, K.sample = Af, K.size = If, K.snakeCase = Yh, K.some = Rf, K.sortedIndex = Co, K.sortedIndexBy = Uo, K.sortedIndexOf = Bo, K.sortedLastIndex = To, K.sortedLastIndexBy = $o, K.sortedLastIndexOf = Do, K.startCase = Qh, K.startsWith = mc, K.subtract = dp, K.sum = il, K.sumBy = ol, K.template = xc, K.times = Jc, K.toFinite = Oa, K.toInteger = Ia, K.toLength = Ra, K.toLower = jc, K.toNumber = za, K.toSafeInteger = Sa, K.toString = Wa, K.toUpper = Ac, K.trim = kc, K.trimEnd = Oc, K.trimStart = Ic, K.truncate = Rc, K.unescape = zc, K.uniqueId = Qc, K.upperCase = Xh, K.upperFirst = np, K.each = gf, K.eachRight = yf, K.first = mo, Dc(K, function () {
      var n = {};
      return oe(K, function (t, r) {
        ml.call(K.prototype, r) || (n[r] = t);
      }), n;
    }(), {
      chain: !1
    }), K.VERSION = nn, u(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function (n) {
      K[n].placeholder = K;
    }), u(["drop", "take"], function (n, t) {
      Dt.prototype[n] = function (r) {
        r = r === X ? 1 : Jl(Ia(r), 0);
        var e = this.__filtered__ && !t ? new Dt(this) : this.clone();
        return e.__filtered__ ? e.__takeCount__ = Yl(r, e.__takeCount__) : e.__views__.push({
          size: Yl(r, Cn),
          type: n + (e.__dir__ < 0 ? "Right" : "")
        }), e;
      }, Dt.prototype[n + "Right"] = function (t) {
        return this.reverse()[n](t).reverse();
      };
    }), u(["filter", "map", "takeWhile"], function (n, t) {
      var r = t + 1,
          e = r == In || r == zn;

      Dt.prototype[n] = function (n) {
        var t = this.clone();
        return t.__iteratees__.push({
          iteratee: Ai(n, 3),
          type: r
        }), t.__filtered__ = t.__filtered__ || e, t;
      };
    }), u(["head", "last"], function (n, t) {
      var r = "take" + (t ? "Right" : "");

      Dt.prototype[n] = function () {
        return this[r](1).value()[0];
      };
    }), u(["initial", "tail"], function (n, t) {
      var r = "drop" + (t ? "" : "Right");

      Dt.prototype[n] = function () {
        return this.__filtered__ ? new Dt(this) : this[r](1);
      };
    }), Dt.prototype.compact = function () {
      return this.filter(Uc);
    }, Dt.prototype.find = function (n) {
      return this.filter(n).head();
    }, Dt.prototype.findLast = function (n) {
      return this.reverse().find(n);
    }, Dt.prototype.invokeMap = iu(function (n, t) {
      return "function" == typeof n ? new Dt(this) : this.map(function (r) {
        return Re(r, n, t);
      });
    }), Dt.prototype.reject = function (n) {
      return this.filter(Tf(Ai(n)));
    }, Dt.prototype.slice = function (n, t) {
      n = Ia(n);
      var r = this;
      return r.__filtered__ && (n > 0 || t < 0) ? new Dt(r) : (n < 0 ? r = r.takeRight(-n) : n && (r = r.drop(n)), t !== X && (t = Ia(t), r = t < 0 ? r.dropRight(-t) : r.take(t - n)), r);
    }, Dt.prototype.takeRightWhile = function (n) {
      return this.reverse().takeWhile(n).reverse();
    }, Dt.prototype.toArray = function () {
      return this.take(Cn);
    }, oe(Dt.prototype, function (n, t) {
      var r = /^(?:filter|find|map|reject)|While$/.test(t),
          e = /^(?:head|last)$/.test(t),
          u = K[e ? "take" + ("last" == t ? "Right" : "") : t],
          i = e || /^find/.test(t);
      u && (K.prototype[t] = function () {
        var t = this.__wrapped__,
            o = e ? [1] : arguments,
            f = t instanceof Dt,
            a = o[0],
            c = f || mh(t),
            l = function l(n) {
          var t = u.apply(K, s([n], o));
          return e && h ? t[0] : t;
        };

        c && r && "function" == typeof a && 1 != a.length && (f = c = !1);

        var h = this.__chain__,
            p = !!this.__actions__.length,
            v = i && !h,
            _ = f && !p;

        if (!i && c) {
          t = _ ? t : new Dt(this);
          var g = n.apply(t, o);
          return g.__actions__.push({
            func: rf,
            args: [l],
            thisArg: X
          }), new Y(g, h);
        }

        return v && _ ? n.apply(this, o) : (g = this.thru(l), v ? e ? g.value()[0] : g.value() : g);
      });
    }), u(["pop", "push", "shift", "sort", "splice", "unshift"], function (n) {
      var t = gl[n],
          r = /^(?:push|sort|unshift)$/.test(n) ? "tap" : "thru",
          e = /^(?:pop|shift)$/.test(n);

      K.prototype[n] = function () {
        var n = arguments;

        if (e && !this.__chain__) {
          var u = this.value();
          return t.apply(mh(u) ? u : [], n);
        }

        return this[r](function (r) {
          return t.apply(mh(r) ? r : [], n);
        });
      };
    }), oe(Dt.prototype, function (n, t) {
      var r = K[t];

      if (r) {
        var e = r.name + "",
            u = cs[e] || (cs[e] = []);
        u.push({
          name: t,
          func: r
        });
      }
    }), cs[ti(X, vn).name] = [{
      name: "wrapper",
      func: X
    }], Dt.prototype.clone = Yt, Dt.prototype.reverse = Qt, Dt.prototype.value = Xt, K.prototype.at = nh, K.prototype.chain = ef, K.prototype.commit = uf, K.prototype.next = of, K.prototype.plant = af, K.prototype.reverse = cf, K.prototype.toJSON = K.prototype.valueOf = K.prototype.value = lf, K.prototype.first = K.prototype.head, Tl && (K.prototype[Tl] = ff), K;
  },
      be = de();

  "function" == typeof define && "object" == _typeof(define.amd) && define.amd ? (re._ = be, define(function () {
    return be;
  })) : ue ? ((ue.exports = be)._ = be, ee._ = be) : re._ = be;
}).call(this);
},{}],"_countdown.js":[function(require,module,exports) {
var Countdown = function Countdown() {};

Countdown.timer = function (end, onTick, onComplete) {
  var timeLeft = end - new Date();
  var timeAPI = {
    DAYS: 1000 * 60 * 60 * 24,
    HOURS: 1000 * 60 * 60,
    MINUTES: 1000 * 60,
    SECONDS: 1000
  };

  var tick = function tick() {
    if (timeLeft > 0) {
      var time = timeLeft;
      var days = Math.floor(time / timeAPI.DAYS);
      time %= timeAPI.DAYS;
      var hours = Math.floor(time / timeAPI.HOURS);
      time %= timeAPI.HOURS;
      var minutes = Math.floor(time / timeAPI.MINUTES);
      time %= timeAPI.MINUTES;
      var seconds = Math.floor(time / timeAPI.SECONDS);
      var countdown = {
        days: days,
        hours: hours,
        minutes: minutes,
        seconds: seconds
      };
      onTick(countdown);
      timeLeft -= 1000;
    } else {
      timeLeft -= 1000;
      clearInterval(interval), onComplete();
    }
  };

  var interval = setInterval(function (self) {
    return function () {
      tick.call(self);
    };
  }(this), 1000);

  var getTimeRemaining = function getTimeRemaining() {
    var time = timeLeft;
    var days = Math.floor(time / timeAPI.DAYS);
    time %= timeAPI.DAYS;
    var hours = Math.floor(time / timeAPI.HOURS);
    time %= timeAPI.HOURS;
    var minutes = Math.floor(time / timeAPI.MINUTES);
    time %= timeAPI.MINUTES;
    var seconds = Math.floor(time / timeAPI.SECONDS);
    return {
      days: days,
      hours: hours,
      minutes: minutes,
      seconds: seconds
    };
  };

  tick.call(this);
  return {
    abort: function abort() {
      clearInterval(interval);
    },
    getTimeRemaining: getTimeRemaining
  };
};

module.exports = Countdown;
},{}],"index.js":[function(require,module,exports) {
"use strict";

require("./scss/main.scss");

var _medkitProdUmd = _interopRequireDefault(require("./_medkit-prod.umd.js"));

var _jquery = _interopRequireDefault(require("./jquery.js"));

var _lodashMin = _interopRequireDefault(require("./_lodash.min.js"));

var _countdown = _interopRequireDefault(require("./_countdown.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//import Muxy from './_medkit.umd.js'
var appStorage = window.localStorage;
appStorage.setItem('counter', null);
var counterStorage = null;
var opts = new _medkitProdUmd.default.DebuggingOptions();
opts.role('viewer').environment('production').jwt('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjIxNDA1NjYwMTIsInJvbGUiOiJhZG1pbiIsImNoYW5uZWxfaWQiOiIxMjQ0ODMyNTYiLCJ1c2VyX2lkIjoiMTI0NDgzMjU2Iiwib3BhcXVlX3VzZXJfaWQiOiJVMTI0NDgzMjU2IiwiaWF0IjoxNTQwNTY2MDcyfQ.9dlW4B2FGyXurFqwiMwEgjABJYPSWRT1h2LU9blhwmY');

_medkitProdUmd.default.setup({
  extensionID: 'xyphukhqzv4tl044h0vxdrj945zbpr'
});

_medkitProdUmd.default.debug(opts);

var sdk = new _medkitProdUmd.default.default.SDK();
/**
 * [setVote description]
 * @param {[type]} voteid [description]
 * @param {[type]} answer [description]
 */

/**
 * [getVoteData description]
 * @param  {[type]} voteid [description]
 * @return {[type]}        [description]
 */

var getVoteData = function getVoteData(voteid) {
  //console.log(`muxy::getVoteData: ${voteid}`);
  return sdk.getVoteData(voteid);
};
/**
 * [listenVote description]
 * @param  {[type]} voteid [description]
 * @return {[type]}        [description]
 */


var listenVote = function listenVote(voteid, cb) {
  //console.log(`muxy::listen: vote_update:${voteid}`);
  sdk.listen("vote_update:".concat(voteid), cb);
};

var cleanPoll = function cleanPoll(el) {
  // Hide element
  // Empty Title & Answers
  (0, _jquery.default)('#poll-title').html('');
  (0, _jquery.default)('#poll-answers').empty();
};

var setCountdown = function setCountdown(duration) {
  var now = new Date();
  var seconds = 1000 * duration;
  var end = new Date(now.getTime() + seconds);
  counterStorage = _countdown.default.timer(end, function (time) {
    var secs = time.seconds;

    if (secs < 10) {
      secs = '0' + secs;
    }

    if (secs < 0) {
      secs = '00';
    }

    if (time.minutes > 0) {
      (0, _jquery.default)('#duration').html("".concat(time.minutes, ":").concat(secs));
    } else {
      (0, _jquery.default)('#duration').html(secs);
    }
  }, function () {
    (0, _jquery.default)('#duration').html('00:00');
  });
  appStorage.setItem('counter', counterStorage);
  return counterStorage;
};
/**
 * [generatePoll description]
 * @param  {[type]} poll [description]
 * @return {[type]}      [description]
 */


var generatePoll = function generatePoll(poll) {
  //console.log(poll);
  (0, _jquery.default)('#poll-title').html(poll.question);
  (0, _jquery.default)('#duration').html('00:00');
  setCountdown(poll.duration);

  if (poll.type == "img") {
    var wrapper = (0, _jquery.default)('#poll-answers');
    (0, _jquery.default)('.poll-body').addClass('boximg');
    wrapper.removeClass('list');
    Object.keys(poll.answers).forEach(function (i) {
      var divItem = (0, _jquery.default)('<div>', {
        class: 'jquery-poll-answer poll-answer'
      });
      divItem.attr('data-answerid', i);
      var divImg = (0, _jquery.default)('<div>', {
        class: 'poll-answer-image'
      });
      divImg.css('background-image', "url('".concat(poll.answers[i].img, "')"));
      var divAnswer = (0, _jquery.default)('<div>', {
        class: 'poll-answer-label'
      });
      divAnswer.html(poll.answers[i].text);
      var divButton = (0, _jquery.default)('<div>', {
        class: 'poll-answer-button'
      });
      divButton.html('CHOOSE');
      divItem.append(divImg);
      divItem.append(divAnswer);
      divItem.append(divButton); //wrapper.append(divItem);
    });
  } else {
    (0, _jquery.default)('.poll-body').removeClass('boximg');

    var _wrapper = (0, _jquery.default)('<div>', {
      id: 'bloc_question'
    });

    Object.keys(poll.answers).forEach(function (i) {
      var divItem = (0, _jquery.default)('<div>', {
        class: 'jquery-poll-answer poll-answer-list-item'
      });
      divItem.attr('data-answerid', i);
      var divAnswer = (0, _jquery.default)('<div>', {
        class: 'poll-answer-list-item-name'
      });
      divAnswer.html(poll.answers[i]);
      divItem.append(divAnswer);

      _wrapper.append(divItem);
    }); //$('#poll-answers').append(wrapper);

    (0, _jquery.default)('#poll-answers').addClass('list');
  }
  /**
   * [results description]
   * @param  {[type]} answers  [description]
   * @param  {[type]} selected [description]
   * @param  {[type]} result   [description]
   * @return {[type]}          [description]
   *
   * 
   */


  var userAnswerVote = null;
  return poll.duration;
};

var results = function results(poll, answers) {
  var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  var sum = _lodashMin.default.reduce(result.specific, function (memo, num) {
    return memo + num;
  }, 0);

  console.log("sum: ".concat(sum, " "), result);

  if (poll.type == "img") {
    var wrapper = (0, _jquery.default)('#poll-answers');
    wrapper.removeClass('list');
    wrapper.empty();
    Object.keys(answers).forEach(function (i) {
      var divItem = (0, _jquery.default)('<div>', {
        class: 'jquery-poll-answer poll-answer ' + (true ? 'selected' : '')
      });
      divItem.attr('data-answerid', i);
      var divImg = (0, _jquery.default)('<div>', {
        class: 'poll-answer-image'
      });
      divImg.css('background-image', "url('".concat(poll.answers[i].img, "')"));
      var divAnswer = (0, _jquery.default)('<div>', {
        class: 'poll-answer-label'
      });
      divAnswer.html(poll.answers[i].text);
      divItem.append(divImg);
      divItem.append(divAnswer);
      var percentage;

      if (sum == 0) {
        percentage = 0;
      } else {
        percentage = Math.round(result.specific[i] * 100 / sum);
      }

      console.log(percentage);
      var divAnswerPercentContainer = (0, _jquery.default)('<div>', {
        class: 'poll-answer-percent'
      });
      var divAnswerPercentBar = (0, _jquery.default)('<div>', {
        class: 'poll-answer-percent-value'
      });
      divAnswerPercentBar.css({
        width: "".concat(percentage, "%")
      });
      divAnswerPercentContainer.append(divAnswerPercentBar);
      var spanAnswerPercent = (0, _jquery.default)('<span>');
      spanAnswerPercent.html("".concat(percentage, "%"));
      divAnswerPercentContainer.append(spanAnswerPercent);
      divItem.append(divAnswerPercentContainer);
      wrapper.append(divItem);
    });
  } else {
    (0, _jquery.default)('#poll-answers #bloc_answers').empty();

    var _wrapper2 = (0, _jquery.default)('<div>', {
      id: 'bloc_answers'
    });

    Object.keys(answers).forEach(function (i) {
      var divItem = (0, _jquery.default)('<div>', {
        class: 'jquery-poll-answer poll-answer-list-item result ' + (true ? 'selected' : '')
      });
      divItem.attr('data-answerid', i);
      var divAnswer = (0, _jquery.default)('<div>', {
        class: 'poll-answer-list-item-name'
      });
      divAnswer.html(poll.answers[i]);
      divItem.append(divAnswer); // Calculate percentage per answer

      var percentage;

      if (sum == 0) {
        percentage = 0;
      } else {
        percentage = Math.round(result.specific[i] * 100 / sum);
      }

      console.log(percentage);
      var divAnswerValue = (0, _jquery.default)('<div>', {
        class: 'poll-answer-list-item-value ' + (true ? 'selected' : '')
      });
      divAnswerValue.css({
        width: "".concat(percentage, "%")
      });
      divItem.append(divAnswerValue);
      var divAnswerPercent = (0, _jquery.default)('<div>', {
        class: 'poll-answer-list-item-percent'
      }); // divAnswerPercent.html('50%');

      divAnswerPercent.html("".concat(percentage, "%"));
      divItem.append(divAnswerPercent);

      _wrapper2.append(divItem);
    });
    (0, _jquery.default)('#poll-answers').append(_wrapper2);
    (0, _jquery.default)('#poll-answers').addClass('list');
  }
};

var loopFetchResult = function loopFetchResult(resp, key) {
  getVoteData(key).then(function (result) {
    console.log('getVoteData result', key, result);
    (0, _jquery.default)('#poll-answers').empty();
    (0, _jquery.default)('#poll-answers #bloc_question').hide();
    results(resp, resp.answers, result);
    setTimeout(function () {
      //console.log('loopFetch timemoutSET');
      if ((0, _jquery.default)('.box.poll').hasClass('opened')) {
        loopFetchResult(resp, key);
      } else {//console.log('loopFetch timemoutCanceled', $('.box.poll'));
      }
    }, 3000);
  });
};
/**
 * [setListen description]
 * @param {[type]} arr [description]
 */


(0, _jquery.default)(document).ready(function () {
  /**
   * Listening Muxy ...
   */
  sdk.loaded().then(function () {
    console.log("Muxy loaded");
    var lastPoll;
    setInterval(function () {
      sdk.getJSONStore('global-global-lastPoll').then(function (data) {
        console.log("LastPoll is ", lastPoll, "poll fetched is", data.key);

        if (lastPoll != data.key) {
          lastPoll = data.key;
          cleanPoll('.poll', counterStorage);

          if (counterStorage) {
            counterStorage.abort();
            counterStorage = null;
          }

          sdk.getJSONStore(data.key).then(function (resp) {
            var duration = generatePoll(resp); //setCountdown(duration, '.poll');

            console.log(resp);
            getVoteData(data.key).then(function (result) {
              (0, _jquery.default)('#poll-answers').empty();
              (0, _jquery.default)('#poll-answers #bloc_question').hide();
              results(resp, resp.answers, result);
              loopFetchResult(resp, data.key);
            });
          });
        }
      });
    }, 500);
  });
});
},{"./scss/main.scss":"scss/main.scss","./_medkit-prod.umd.js":"_medkit-prod.umd.js","./jquery.js":"jquery.js","./_lodash.min.js":"_lodash.min.js","./_countdown.js":"_countdown.js"}],"../../.nvm/versions/node/v11.10.1/lib/node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "64407" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else {
        window.location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel]  Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel]   ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;"></span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["../../.nvm/versions/node/v11.10.1/lib/node_modules/parcel-bundler/src/builtins/hmr-runtime.js","index.js"], null)
//# sourceMappingURL=/rbt-overlay-polling.e31bb0bc.js.map